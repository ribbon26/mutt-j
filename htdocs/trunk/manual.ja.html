<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>The Mutt E-Mail Client</TITLE>


</HEAD>
<BODY>
<H1>The Mutt E-Mail Client</H1>

<H2>by Michael Elkins 
<A HREF="mailto:me@cs.hmc.edu">&lt;me@cs.hmc.edu&gt;</A></H2>version 1.5.7 +20050201
<P><HR>
<EM>``All mail clients suck.  This one just sucks less.'' -me, circa 1995</EM>
<HR>
<H2><A NAME="s1">1. 紹介</A></H2>

<P><B>Mutt</B> は小さいながらも非常にパワフルなテキストベイス MIME
メイルクライアントです。その高い柔軟性に加えて、キー割り当てや
キーボードマクロ、メイルのスレッド表示、正規表現検索、さらには
メッセイジ選択用の強力なパターン言語といった高度な機能により、
まさしくメイルのパワーユーザにぴったりであると言えます。
<BLOCKQUOTE>
「メイルクライアントはぜんぶ腐ってる。こいつはそれほど腐っちゃいない
ってだけのことさ」 - 作者 Michael Elkins, 1995 年頃の発言
</BLOCKQUOTE>
<P>
<H2>1.1 ホウムペイジ</H2>

<P>
<A HREF="http://www.mutt.org/">http://www.mutt.org/</A><P>
<H2>1.2 メイリングリスト</H2>

<P>以下のメイリングリストを講読するにはメッセイジ本文に <EM>subscribe</EM>と書いて
<CODE>mutt-○○</CODE><EM>-request</EM><CODE>@mutt.org</CODE> に送ってください。
<P>
<UL>
<LI>
<A HREF="mailto:mutt-announce-request@mutt.org">mutt-announce@mutt.org</A> ―　流量の少ない、アナウンス用リスト</LI>
<LI>
<A HREF="mailto:mutt-users-request@mutt.org">mutt-users@mutt.org</A> ―　質問、バグ報告、要望</LI>
<LI>
<A HREF="mailto:mutt-dev-request@mutt.org">mutt-dev@mutt.org</A> ―　開発メイリングリスト</LI>
</UL>
<P><B>メモ</B>: <EM>mutt-announce</EM> への投稿は自動的に
<EM>mutt-users</EM> に転送されるので、両方を講読する必要はありません。
<P>
<H2>1.3 ソフトウェア配布サイト</H2>

<P>
<UL>
<LI>
<A HREF="ftp://ftp.mutt.org/mutt/">ftp://ftp.mutt.org/mutt/</A></LI>
</UL>
<P>ミラーサイトについては 
<A HREF="http://www.mutt.org/download.html">http://www.mutt.org/download.html</A> をご覧ください。
<P>
<H2>1.4 IRC</H2>

<P>
<A HREF="http://www.freenode.net/">irc.freenode.net (www.freenode.net)</A> のチャンネル
<EM>#mutt</EM> に行けば、Mutt に関心のある人と会話できます。
(訳注：ただし、英語。なお、このチャンネル利用者の心得が
<A HREF="http://wiki.mutt.org/">wiki.mutt.org</A>
に書いてある。必ずしも即座に反応があるわけではないので、
「だれかいる?」というような質問をせず、だまって相談し、しばらく待つべし、
とのこと。日本語の Mutt チャンネルはどこかにあるのだろうか……。)
<P>
<H2>1.5 USENET</H2>

<P>ニューズグループ 
<A HREF="news:comp.mail.mutt">comp.mail.mutt</A> を見てください。
<P>
<H2>1.6 Copyright (著作権)</H2>

<P>Mutt is Copyright (C) 1996-2000 Michael R. Elkins
&lt;me@cs.hmc.edu&gt; and others
<P>This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
<P>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
<P>You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
<P>(参考訳)
<P>このプログラムはフリーソフトウェアです。Free Software Foundation による GNU General Public License のヴァージョン 2 もしくはそれ以降のヴァージョン (自由選択) のいずれかに従う限り、自由に変更および再配布できます。
<P>このプログラムは役に立つことを願って配布されていますが、「まったく無保証」です。商品能力や特定の目的への適性について、暗黙の保証さえありません。詳細は GNU General Public License を参照してください。
<P>GNU General Public License の文面は、このプログラムに付いてきたはずです。そうでなければ、Free Software Foudation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111, USA に手紙をください。
<P>
<H2><A NAME="s2">2. 開始</A></H2>

<P>
<P>この章の目的は Mutt の使い方を概観することです。
ほかにもマニュアルの別の場所で説明されている機能はたくさんあります。
さらには Mutt FAQ や種々のウェブペイジで手に入る情報もあります。
詳しくは 
<A HREF="http://www.mutt.org/mutt/">Mutt Page</A>
を参照してください。
<P>この章では、配布されているままの既定のキー割り当てで説明します。
自分のサイトではシステム管理者が既定値を変えてしまっている
かもしれません。どのメニューでも &quot;?&quot; を押して
現在のキー割り当てを表示できます。
<P>まず必要なのは Mutt を起動することです。コマンドラインから mutt
と入力するだけです。コマンドラインの種々のオプションについては
mutt の man ペイジか
<A HREF="#commandline">「早見」の章</A>を
参照してください。
<P>
<H2>2.1 メニュー内で動きまわる</H2>

<P>
<P>情報はメニューの中に、ELM そっくりの形式で表示されます。
以下は各メニューでの操作に共通のキーの表です。
<P>
<BLOCKQUOTE><CODE>
<PRE>
j と Down       next-entry      次の項目へ移動
k と Up         previous-entry  前の項目へ移動
z と PageDn     page-down       次のペイジに行く
Z と PageUp     page-up         前のペイジに行く
= と Home       first-entry     最初の項目に飛ぶ
* と End        last-entry      最後の項目に飛ぶ
q               quit            現在のメニューを終了
?               help            現在のメニューのキー割り当てを表示
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="editing"></A> 2.2 入力領域を編集する</H2>

<P>Muttには内蔵ラインエディタがあり、これが
メイルアドレスやファイル名のような文字デイタ入力の主要な手段となっています。
編集中に動きまわるためのキーは Emacs によく似ています。
<P>
<BLOCKQUOTE><CODE>
<PRE>
^A or &lt;Home>    bol             行頭に移動
^B or &lt;Left>    backward-char   一文字戻る
Esc B           backward-word   一語戻る
^D or &lt;Delete>  delete-char     カーソル位置の文字を削除
^E or &lt;End>     eol             行末に移動
^F or &lt;Right>   forward-char    一文字進む
Esc F           forward-word    一語進む
&lt;Tab>           complete        ファイル名やエイリアスを補完
^T              complete-query  問い合わせでアドレスを補完
^K              kill-eol        行末まで削除
ESC d           kill-eow        単語の終わりまで削除
^W              kill-word       カーソルの前の一語を消す
^U              kill-line       一行全体を削除
^V              quote-char      次に入力するキーに引用符を付ける
&lt;Up>            history-up      履歴から前の入力文字列を呼び出す
&lt;Down>          history-down    履歴から次の入力文字列を呼び出す
&lt;BackSpace>     backspace       カーソルの前の一文字を削除
Esc u           upcase-word     単語を大文字に変換
Esc l           downcase-word   単語を小文字に変換
Esc c           capitalize-word 単語の最初の文字を大文字に変換
^G              n/a             取消
&lt;Return>        n/a             編集を終了
</PRE>
</CODE></BLOCKQUOTE>
<P>エディタ (<EM>editor</EM>) の関数を割り当て直すには
<A HREF="#bind">bind</A> コマンドを使います。
例えば、Delete キーを押したときに、カーソルの乗っている文字ではなく
カーソルの前にある文字を消すようにするには、こうしてください。
<P><CODE>bind editor &lt;delete&gt; backspace</CODE>
<P>
<H2>2.3 メイルを読む　―　インデックスとペイジャ</H2>

<P>
<P>他の多くのメイルクライアントと同様、Mutt ではメイルを読むモウドが二つあります。
第一のモウドはメイルボックス内のメッセイジ一覧です。
これを Mutt では「インデックス」 (index) と呼んでいます。
第二のモウドはメッセイジの内容表示です。これは「ペイジャ」 (pager) といいます。
<P>続く数節で、これらのモウドそれぞれに提供されている関数を説明します。
<P>
<H3>メッセイジインデックス</H3>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
c               メイルボックスを変更
ESC c           フォルダを読み出し専用モウドに変更
C               現在のメッセイジを別のメイルボックスにコピー
ESC C           メッセイジを復号化してフォルダにコピー
ESC s           メッセイジを復号化してフォルダにセイヴ (移動)
D               パターンに合致するメッセイジを削除
d               現在のメッセイジを削除
F               大事だとして印付け
l               パターンに合致するメッセイジを表示
N               新しいとして印付け
o               現在の整列方法を変更
O               メイルボックスを逆順に整列
q               変更を保存して終了
s               メッセイジをセイヴ (移動)
T               パターンに合致するメッセイジにタグ付け
t               メッセイジのタグを切替
ESC t           メッセイジスレッド全体のタグを切替
U               パターンに合致するメッセイジの削除を解除
u               メッセイジの削除を解除
v               添付ファイルを閲覧
x               変更を破棄して終了
&lt;Return>        メッセイジを表示
&lt;Tab>           次の新しいメッセイジに飛ぶ
@               差出人の完全なメイルアドレスを表示
$               変更をメイルボックスへ保存
/               検索
ESC /           逆順に検索
^L              画面を消して再描画
^T              パターンに合致するメッセイジのタグをはずす
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3>ステイタスフラグ</H3>

<P>
<P>メッセイジ送信者と題に加えて、各メッセイジの状態の短い要約が
メッセイジ番号のそばに書かれます。
次の「フラグ」の中に適合するものがあれば表示されます。意味は以下の通りです。
<P>
<P>
<DL>
<DT><B>D</B><DD><P>削除メッセイジである (削除予定の印が付いている)
<DT><B>d</B><DD><P>メッセイジ中に、削除予定の添付ファイルがある
<DT><B>K</B><DD><P>PGP 公開鍵を含んでいる
<DT><B>N</B><DD><P>メッセイジが新しい
<DT><B>O</B><DD><P>メッセイジが古い
<DT><B>P</B><DD><P>メッセイジが暗号化されている
<DT><B>r</B><DD><P>メッセイジが返信済み
<DT><B>S</B><DD><P>メッセイジが署名されており、その署名が検証済み
<DT><B>s</B><DD><P>メッセイジが署名されている
<DT><B>!</B><DD><P>メッセイジが重要フラグ付き
<DT><B>*</B><DD><P>メッセイジがタグ付き
</DL>
<P>ステイタスフラグの一部は、次のコマンドを使ってオン／オフできます。
<UL>
<LI><B>set-flag</B> (既定では w)</LI>
<LI><B>clear-flag</B> (既定では W)</LI>
</UL>
<P>
<P>さらに、次のフラグはメッセイジが誰にあてられたものなのかを反映するものです。
これは 
<A HREF="#to_chars">$to_chars</A> 変数によって
変更できます。
<P>
<P>
<DL>
<DT><B>+</B><DD><P>メッセイジが To で自分だけに宛てられている
<DT><B>T</B><DD><P>メッセイジが To で自分に宛てられているが、他の人にも To か Cc されている
<DT><B>C</B><DD><P>メッセイジが自分に Cc されている
<DT><B>F</B><DD><P>メッセイジが自分発
<DT><B>L</B><DD><P>メッセイジが購読しているメイリングリストに送られている
</DL>
<P>
<H3>ペイジャ</H3>

<P>
<P>既定では、Mutt は内蔵ペイジャを使ってメッセイジ本文を表示します。
このペイジャは Unix プログラムの <EM>less</EM> によく似ていますが、
<EM>less</EM> ほど多機能ではありません。
<P>
<BLOCKQUOTE><CODE>
<PRE>
&lt;Return>        一行下に移動
&lt;Space>         次のペイジ (メッセイジの終わりでは次のメッセイジ) を表示
-               前のペイジに戻る
n               次の合致部分を検索
S               引用文を飛ばす
T               引用文の表示を切替
?               キー割り当てを表示
/               正規表現 (パターン) を検索
ESC /           正規表現を逆順に検索
\               検索パターン着色を切替
^               メッセイジの一番上に飛ぶ
$               メッセイジの一番下に飛ぶ
</PRE>
</CODE></BLOCKQUOTE>
<P>上記に加えて、<EM>インデックス</EM>の関数の多くがペイジャでも使えます。
例えば <EM>delete-message</EM> (削除) や <EM>copy-message</EM>
(コピー) などです (これは、外部ペイジャでメッセイジ閲覧するよりも
便利な点の一つです)。
<P>また、内部ペイジャはさらに二つの優れた機能をサポートしています。
第一に、nroff の「標準」シークウェンスを受け付け、太字や下線を解釈します。
シーケンスは連続で「文字、バックスペイス (^H)、同じ文字」なら太字、
「文字、バックスペイス、&quot;_&quot;」なら下線付き文字です。
端末がサポートしていれば、これを Mutt はそれぞれ太字と下線付き文字として
表示しようとします。サポートしていなければ
bold (太字) と underline (下線) という 
<A HREF="#color">color</A>
のオブジェクトを使って色属性か白黒属性を指定できます。
<P>さらに、内部ペイジャは ANSI エスケイプシークウェンスの文字属性を
サポートしています。
Mutt がそのシークウェンスを正しい色や文字設定に解釈してくれるのです。
Mutt がサポートしているシークウェンスは以下の通りです。
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
ESC [ Ps;Ps;Ps;...;Ps m
Ps は
0    全属性解除
1    太字あり
4    下線付き
5    点滅あり
7    反転表示
3x   文字色を x に
4x   背景色を x に

色は
0    黒
1    赤
2    緑
3    黄
4    青
5    赤紫 (マゼンタ)
6    青緑 (シアン)
7    白
</PRE>
</CODE></BLOCKQUOTE>
<P>Mutt はこれらの属性を text/enriched メッセイジの取り扱いに使いますし、
外部の 
<A HREF="#auto_view">自動閲覧</A> スクリプトから
着色の目的で使うこともあります。
<B>注意:</B> 画面の色を変更すると、上記と違う色になります。
例えば xterm で color2 に対応する色を変更すると、
緑色のはずの部分に xterm ではその変更した色が使われます。
<P>
<H3><A NAME="threads"></A> スレッドモウド</H3>

<P>メイルボックスが<EM>スレッド</EM>で
<A HREF="#sort">整列</A>されているときは、さらにいくつかの関数が
<EM>インデックス</EM>モウドと<EM>ペイジャ</EM>モウドで利用できます。
<P>
<BLOCKQUOTE><CODE>
<PRE>
^D      delete-thread        現在のスレッドのメッセイジをすべて削除
^U      undelete-thread      現在のスレッドのメッセイジの削除をすべて解除
^N      next-thread          次のスレッドの始点に飛ぶ
^P      previous-thread      前のスレッドの始点に飛ぶ
^R      read-thread          現在のスレッドを既読にする
ESC d   delete-subthread     現在のサブスレッドのメッセイジをすべて削除
ESC u   undelete-subthread   現在のサブスレッドのメッセイジの削除予定をすべて解除
ESC n   next-subthread       次のサブスレッドの始点に移動
ESC p   previous-subthread   前のサブスレッドの始点に移動
ESC r   read-subthread       現在のサブスレッドを既読にする
ESC t   tag-thread           現在のスレッドのタグを切替
ESC v   collapse-thread      現在のスレッドの折りたたみを切替
ESC V   collapse-all         すべてのスレッドの折りたたみを切替
P       parent-message       スレッド中の親メッセイジに飛ぶ
</PRE>
</CODE></BLOCKQUOTE>
<P><B>メモ</B>: スレッドを折りたたむと、スレッドの
最初のメッセイジだけが表示されて、他は隠れます。
これは、一つのスレッドにメッセイジがたくさん含まれていて、
画面にほんの一握りのスレッドしか見えないというときに便利です。
<A HREF="#index_format">$index_format</A> の
%M を見てください。例えば 
<A HREF="#index_format">$index_format</A> に
"%?M?(#%03M)&amp;(%4l)?"
という設定を使って、スレッドが折りたたまれているときに
隠れているメイルの数を表示するようにできます。
<P>参照: 
<A HREF="#strict_threads">$strict_threads</A><P>
<H3>その他の機能</H3>

<P><B>エイリアスの作成</B> / <B>create-alias</B>
<A NAME="create-alias"></A>  (既定値: a)<BR>
<P>現在のメッセイジをもとに (あるいは新規プロンプトで) 新しいエイリアスを
作成します。編集を終えると、
<A HREF="#alias_file">$alias_file</A>
で指定したファイルに 
<A HREF="#alias">alias</A>
コマンドが追加されて、あとから使えるようになります。
<B>注意:</B> 
<A HREF="#alias_file">$alias_file</A> を指定しただけでは、中の alias
を追加することになりません。そのファイルを
<A HREF="#source">source</A> する必要もあります。
<P>
<P><B>伝統的 PGP のチェック</B> / <B>check-traditional-pgp</B>
<A NAME="check-traditional-pgp"></A>  (既定値: ESC P)<BR>
<P>この関数は現在のメッセイジを調べて、「伝統的な」方法で PGP
の署名・暗号化がなされている内容を探します。
「伝統的」というのは、つまり適切な MIME タグのないもののことです。
技術的なことを言うと、この関数は、PGP デイタを含むパートの
MIME content type を一時的に変更します。つまり
<A HREF="#edit-type">edit-type</A> 関数の効果と似ています。
<P>
<P>
<P><B>へッダ間引きの切替</B> / <B>display-toggle-weed</B>
<A NAME="display-toggle-weed"></A>  (既定値: h)<BR>
<P>
<A HREF="#ignore">ignore</A> コマンドで指定された
ヘッダフィールドの間引き表示を切り替えます。
<P>
<P><B>編集</B> / <B>edit</B>
<A NAME="edit"></A>  (既定値: e)<BR>
<P>このコマンド (インデックスとペイジャで利用可) は、
現在のメッセイジを「なま」で編集する、つまり、
メイルフォルダにある姿のままで編集するコマンドです。
編集を終えると、変更されたメッセイジは現在いるフォルダに追加され、
オリジナルのメッセイジは削除のために印付けられます。
<P><B>content-type の編集</B> / <B>edit-type</B>
<A NAME="edit-type"></A> <BR>
(既定値: 添付ファイルメニュー、ぺイジャ、およびインデックスメニューでは ^E, コンポウズメニューでは ^T)
<P>このコマンドは添付ファイルの content type を一時的に編集するために使い、
例えば偽装してある文字セットのパラメータを修正したりします。
インデックスやペイジャから使うと最上位の添付ファイルの
content type を編集できます。
<A HREF="#attach_menu">添付ファイルメニュー</A>から使えば、どの添付ファイルの
content type でも変更できます。この変更は永続的なものではなく、
フォルダ変更によって消えてしまいます。
<P>このコマンドは
<A HREF="#compose_menu">コンポウズメニュー</A>でも使える
ということを覚えておいてください。このメニューでは、
送信する添付ファイルの性質を調整するために使います。
(訳注：この場合は永続的な変更)
<P>
<P><B>コマンドの入力</B> / <B>enter-command</B>
<A NAME="enter-command"></A>  (既定値: &quot;:&quot;)<BR>
<P>このコマンドは、通常だと設定ファイルの中に入れるようなコマンドを
動作中の Mutt 上で実行するために使います。
一般的な使い方としては、変数の設定をチェック
(訳注：&quot;:set ?変数名&quot;) したり、
<A HREF="#macro">macro</A> と組み合わせて動作中に設定を変更するために
使ったりします。
<P>
<P><B>公開鍵の抽出</B> / <B>extract-keys</B>
<A NAME="extract-keys"></A>  (既定値: ^K)<BR>
<P>このコマンドは PGP 公開鍵を現在のメッセイジやタグ付きメッセイジから
抽出して自分の PGP 公開鍵束に追加します。
<P>
<P><B>パスフレイズの忘却</B> / <B>forget-passphrase</B>
<A NAME="forget-passphrase"></A>  (既定値: ^F)<BR>
<P>このコマンドはパスフレイズをメモリ上から消去します。
パスフレイズを誤入力したときに使います。
<P>
<P><B>メイリングリストへの返信</B> / <B>list-reply</B>
<A NAME="list-reply"></A>  (既定値: L)<BR>
<P>現在のメッセイジやタグ付きメッセイジから
<A HREF="#lists">lists や subscribe</A>
コマンドで指定されている正規表現に合致するアドレスを抽出して、
そこに返信するコマンドです。それだけではなく、もし 
<A HREF="#honor_followup_to">$honor_followup_to</A> 変数が設定されていると
<CODE>Mail-Followup-To</CODE> へッダを信用します。
メイリングリストに投稿されたメッセイジに返信するときに
これを使えば、返信する元メッセイジの差出人とメイリングリストへ
二重に送信するのを避ける助けになります。
<P><B>メッセイジのパイプ</B> / <B>pipe-message</B>
<A NAME="pipe-message"></A>  (既定値: |)<BR>
<P>外部 Unix コマンドの入力を要求して、現在のメッセイジやタグ付き
メッセイジをそこにパイプします。
<A HREF="#pipe_decode">$pipe_decode</A>,
<A HREF="#pipe_split">$pipe_split</A>,
<A HREF="#pipe_sep">$pipe_sep</A>,
<A HREF="#wait_key">$wait_key</A> 変数が
この関数の動作を精密に制御します。
<P><B>メッセイジの再送</B> / <B>resend-message</B>
<A NAME="resend-message"></A>  (既定値: ESC e)<BR>
<P>resend-message を使うと、Mutt は現在のメッセイジを雛型として
新しいメッセイジを作成します。
この関数は「任意のフォルダの復元」と説明するのが最適でしょう。
MIME メッセイジを、もともとのメイル構造を保ったまま転送するのに便利です。
このときに含まれるへッダは 
<A HREF="#weed">$weed</A> 変数に
依存しているということに注意してください。
(訳注：ただ添付ファイルごと転送したいだけであれば、添付ファイルメニューから
すべてのファイルにタグを付けて「;f」、すなわち tag-prefix, forward-message
をする方が、余計なヘッダが付かなくて良いかもしれない。)
<P>この関数は添付ファイルメニューからも利用できます。
これを使えば message/rfc822 パートとして転送されてきたメッセイジを
簡単に再送できます。
<P><B>シェルコマンドの実行</B> / <B>shell-escape</B>
<A NAME="shell-escape"></A>  (既定値: !)<BR>
<P>外部 UNIX コマンドの入力を要求し、それを実行します。
<A HREF="#wait_key">$wait_key</A> を使って、コマンドが終了したときに
(おそらくコマンドの出力をユーザが読めるようにするため) 何かキーが押されるまで
待つかどうかをコマンドの戻り値で制御するようにできます。
(訳注：$wait_key が no だと、戻り値が 0 以外のときのみ
キー入力を待つ。)
<P><B>引用文表示の切替</B> / <B>toggle-quoted</B>
<A NAME="toggle-quoted"></A>  (既定値: T)<BR>
<P>メッセイジ本文の表示中に、<EM>ペイジャ</EM>は 
<A HREF="#quote_regexp">$quote_regexp</A> 変数を使って引用文を検出します。
この関数はメッセイジ中の引用部分を表示するかどうかを切り替えます。
特に、返事だけに興味があるのに大量の引用文があって邪魔だというようなときに
役に立ちます。
<P><B>引用文をとばして移動</B> / <B>skip-quoted</B>
<A NAME="skip-quoted"></A>  (既定値: S)<BR>
<P>内部ペイジャにおいて、この関数は、
引用文の行のあとの非引用文の行に移動します。
<P>
<H2>2.4 メイルを送信する</H2>

<P>
<P>以下のコマンドがメイル送信のために<EM>インデックス</EM>で利用できます。
<P>
<BLOCKQUOTE><CODE>
<PRE>
m       compose      新規メッセイジを作成
r       reply        差出人へ返信
g       group-reply  受信者全員へ返信
L       list-reply   メイリングリストのアドレスへ返信
f       forward      メッセイジを転送
b       bounce       メッセイジを中継 (再送)
ESC k   mail-key     だれかに PGP 公開鍵を送信
</PRE>
</CODE></BLOCKQUOTE>
<P>メッセイジの中継は、指定した宛先に「あるがまま」のメッセイジを送信します。
メッセイジの転送は、転送するメッセイジにコメントを付けたり変更したりできます。
これらに関しては次の節
<A HREF="#forwarding_mail">「メイルを転送・中継する」</A>
で詳しく論じられています。
<P>上記のコマンドを使うと Mutt はコンポウズ (<EM>compose</EM>) メニューに入り、
&quot;To:&quot; ヘッダフィールドに入れる宛先の入力を促します。
次にメッセイジの &quot;Subject:&quot; フィールドを聞いてきますが、
メッセイジの返信や転送のときは既定値が入っています。
このとき Mutt がどう質問するのかを変更するには、
<A HREF="#askcc">$askcc</A>,
<A HREF="#askbcc">$askbcc</A>,
<A HREF="#autoedit">$autoedit</A>,
<A HREF="#fast_reply">$fast_reply</A> を参照してください。
<P>それから Mutt はメッセイジ本文に対して 
<A HREF="#editor">エディタ ($editor)</A> を起動します。
<A HREF="#edit_headers">$edit_headers</A> 変数が設定されているときは、
メッセイジの上にヘッダもあります。
メッセイジには、返信するメッセイジが整列の順に取り込まれ、それぞれに適切な
<A HREF="#attribution">由来 ($attribution)</A>,
<A HREF="#indent_string">引用文字列 ($indent_string)</A>,
<A HREF="#post_indent_string">引用終了文字列 ($post_indent_string)</A>
が付きます。メッセイジ転送時、
<A HREF="#mime_forward">$mime_forward</A> 変数が設定されていなければ、
転送するメッセイジのコピーも本文に取り込まれます。また、
<A HREF="#signature">署名ファイル ($signature)</A> を指定してあれば、
そのファイルも付加されます。
<P>送信メッセイジの本文を編集し終えると、<EM>コンポウズ</EM>メニューに戻ります。
以下の選択肢があります。
<P>
<BLOCKQUOTE><CODE>
<PRE>
a      attach-file          ファイルを添付
A      attach-message       メッセイジにメッセイジを添付
ESC k  attach-key           PGP 公開鍵を添付
d      edit-description     添付ファイルの内容説明を編集
D      detach-file          添付ファイルをはずす
t      edit-to              To フィールドを編集
ESC f  edit-from            From フィールドを編集
r      edit-reply-to        Reply-To フィールドを編集
c      edit-cc              Cc フィールドを編集
b      edit-bcc             Bccフィールドを編集
y      send-message         メッセイジを送信
s      edit-subject         題名を編集
S      smime-menu           S/MIME オプションを選択
f      edit-fcc             &quot;Fcc&quot; メイルボックスを指定
p      pgp-menu             PGP オプションを選択
P      postpone-message     メッセイジを次回まで延期
q      quit                 メッセイジ送信を中断 (または中止)
w      write-fcc            メッセイジをフォルダに書き込む
i      ispell               綴りを確認 (利用可能なシステムならば)
^F     forget-passphrase    メモリからパスフレイズを拭い去る
</PRE>
</CODE></BLOCKQUOTE>
<P><B>注意:</B> attach-message 関数は、添付したいメッセイジのあるフォルダを
入力するよう促します。そこのフォルダでメッセイジにタグを付ければ、
そのメッセイジを送信メッセイジに添付できます。(訳注：タグを付けたあとは
q でコンポウズメニューに戻れる。)
このフォルダにいるときは新規メッセイジ作成や返信、転送などの操作が
できないということに注意してください。
<A HREF="#status_format">$status_format</A> に %r があれば、
それが A に変わって、メッセイジ添付 (attach-message)
モウドにいることを示します。
<P>
<H3>メッセイジヘッダを編集する</H3>

<P>送信メッセイジのヘッダを編集するときには、
いくつか特別な機能が利用できます。
<P><CODE>Fcc:</CODE> <EM>ファイル名</EM><BR>
を指定すると、あたかも<EM>コンポウズ</EM>メニューで
<EM>edit-fcc</EM> 関数を使ったかのように<EM>ファイル名</EM>を扱います。
<P>また、<BR>
<CODE>Attach:</CODE> <EM>ファイル名</EM> [ <EM>内容説明</EM> ]<BR>
を指定してメッセイジにファイルを添付することもできます。
ここで <EM>ファイル名</EM> は添付するファイルで、
<EM>内容説明</EM> は添付ファイルの説明に使う付加的な文字列です。
<P>メッセイジに返信するときにヘッダフィールドから <EM>In-Reply-To:</EM>
フィールドを削除すると Mutt は <EM>Reference:</EM> フィールドを生成しません。
このようにして新規のメッセイジスレッドを作成することができます。
<P>
<A HREF="#edit_headers">edit_headers</A> も参照してください。
<P>
<H3>Mutt で PGP を使う</H3>

<P>PGP を使いたい場合は
<P><CODE>Pgp:</CODE> [ <CODE>E</CODE> | <CODE>S</CODE> | <CODE>S</CODE><EM>&lt;id&gt;</EM> ] <BR>
<P>を指定してください。&quot;E&quot; は暗号化、&quot;S&quot; は署名、
&quot;S&lt;id&gt;&quot; は指定した鍵で署名します。
鍵は 
<A HREF="#pgp_sign_as">$pgp_sign_as</A> で
恒久的に設定できます。
<P>メッセイジを PGP で暗号化するよう Mutt に言うと、
メッセイジを送信しようとするときに鍵選択プロセスを通るよう指示されます。
Mutt は、信用できるユーザ ID があってメッセイジ宛先のメイルアドレスに合致する鍵
については何も尋ねません。
しかしながら、鍵が複数あったり、ユーザ ID フィールドの信用度が弱かったり、
合致する鍵がひとつも見つからないという状況もありえます。
<P>こういう場合には、鍵を選択できる一覧のメニューに行かされます。
そのメニューを終了したり、合致する鍵を Mutt が見つけられなかったりすると、
ユーザ ID の入力を促されます。普段どおり、このプロンプトは <CODE>^G</CODE>
を使って中止できます。そうすると Mutt はコンポウズ画面に戻ります。
<P>正しく鍵選択を完了すると、そのメッセイジは
選択した公開鍵を使って暗号化され送信されます。
<P>鍵選択メニューの項目 (
<A HREF="#pgp_entry_format">$pgp_entry_format</A> も参照) の
ほとんどのフィールドの意味は明白ですが、
能力 (capabilities), フラグ (flags), 信用度 (validity) のフィールドについて
少し説明しておいても良いでしょう。
<P>フラグシークウェンス (%f) は以下のフラグのいずれかに展開されます。
<BLOCKQUOTE><CODE>
<PRE>
R            鍵は破棄されており、使えない
X            鍵は期限切れになっており、使えない
d            自分で鍵を使用不可に印付けた
c            未知の重要な自己署名パケットがある
</PRE>
</CODE></BLOCKQUOTE>
<P>能力フィールド (%c)
は、鍵の能力を表わす二文字シークウェンスに展開されます。
第一の文字は暗号化能力です。
マイナス (<B>-</B>) は暗号化に使えないという意味です。
ドット (<B>.</B>) はいずれかのユーザ ID の署名鍵として印付けられているけれども
暗号化にも使えるという意味です。&quot;<B>e</B>&quot; の文字は
暗号化 (encryption) に使えるという意味です。
<P>第二の文字は鍵の署名能力を表しています。こちらもやはり、
&quot;<B>-</B>&quot; は「署名用ではない」という意味で、&quot;<B>.</B>&quot;
はあるユーザ ID の暗号化鍵として印付けられているという意味、
&quot;<B>s</B>&quot; は署名に使えるという意味です。
<P>最後に、信用度フィールド (%t) は
ユーザ ID がどれほどしっかり確証されているかを示します。
疑問符 (<B>?</B>) は信用度が未定義だという意味で、
マイナス (<B>-</B>) は信用できない関係、
スペイス文字は部分的に信用できる関係、
プラス (<B>+</B>) は完全な信用度を表しています。
<P>
<H3>匿名メッセイジを Mixmaster 経由で送信する</H3>

<P>Mutt を Mixmaster 匿名リメイラ (remailer) と共働するよう
設定してあるかもしれません。(訳注：日本では法律に抵触するかもしれない。)
Mixmaster はリメイラのチェインを使って匿名でメッセイジを送信できます。
Mutt の Mixmaster サポートは Mixmaster version 2.04 (beta 45 が最新のようです)
と 2.03 に対するものです。これ以前のヴァージョンと、これ以降の
version 3 beta と呼ばれるヴァージョン (2.9b23 が最新のようです) は
サポートしていません。
<P>Mixmaster を使うにはいくつかの制限に従わなくてはなりません。
最も重要なのは <CODE>Cc</CODE> と <CODE>Bcc</CODE> へッダを使えないということです。
Mutt から Mixmaster を使うには、まずコンポウズメニューで mix 関数を使って
リメイラチェインを選ばなくてはなりません。
<P>チェイン選択画面はふたつの部分に分かれています。
上の (広い方の) 部分では使えるリメイラの一覧を見ることができます。
下の部分では現在選択されているリメイラチェインを参照できます。
<P>このチェインの中を <CODE>chain-prev</CODE> 関数と
<CODE>chain-next</CODE> 関数を使って渡り歩けます。
この関数は既定では左右の矢印キーと
<CODE>h</CODE> と <CODE>l</CODE> キーに割り当てられています
(vi のキーバインドを考えてください)。
新しいリメイラを現在のチェイン位置に挿入するには
<CODE>insert</CODE> 関数を使ってください。
リメイラを現在のチェイン位置の後に追加するには
<CODE>select-entry</CODE> か <CODE>append</CODE> を使ってください。
<CODE>delete</CODE> 関数を使ってチェインから項目を消すこともできます。
最後に、メニューをそのまま抜けて変更を破棄するか、
(既定値では) リターンキーを押して承認 (<CODE>accept</CODE>) してください。
<P>リメイラごとに持っている能力が違うということに注意してください。
その能力はリメイラメニューの %c の項目で表示されています
(
<A HREF="#mix_entry_format">$mix_entry_format</A>
を参照してください)。
一番重要なのは大文字の &quot;M&quot; で示される &quot;middleman&quot;
能力です。
これは問題のリメイラが、チェインの最終要素にはなれないとはいえ、
他の mixmaster リメイラにメッセイジを転送することはできるという意味です。
他の能力の詳細については Mixmaster の文書を見てください。
<P>
<H2><A NAME="forwarding_mail"></A> 2.5 メイルを転送・中継する</H2>

<P>
<P>中継と転送は、既存メッセイジを自分で指定した宛先に送信できる機能です。
メッセイジの中継とは、コピーを別のアドレスに送信することですが、
その際、あたかもそこが元々の宛先であるかのように送信する方法で
<A HREF="#sendmail">sendmail</A> コマンドを使います。
一方、メッセイジの転送は、再送の前にメッセイジを変更できます
(例えばコメントを加えるなど)。
<P>既定では次のキーが割り当てられています。
<P>
<BLOCKQUOTE><CODE>
<PRE>
f       forward         メッセイジを転送
b       bounce          メッセイジを中継 (再送)
</PRE>
</CODE></BLOCKQUOTE>
<P>転送は 
<A HREF="#mime_forward">$mime_forward</A>
変数の値によって、オリジナルのメッセイジを新規メッセイジの本文に
(それとわかるように示す行で囲んで) 取り込むか、もしくは
MIME 添付ファイルとして取り込みます。
添付ファイルをペイジャのように復号化するかどうかは、それぞれ
<A HREF="#forward_decode">$forward_decode</A> 変数と
<A HREF="#mime_forward_decode">$mime_forward_decode</A>
変数で制御できます。どちらの転送方法が良いかは内容によります。
そのため <EM>$mime_forward</EM> は四択オプション (quadoption)
になっていて、例えば &quot;ask-no&quot; にすることができます
(訳注： ask-no は「質問の際に Return だけ入力したときは no とみなす」
という意味)。
<P>
<A HREF="#mime_forward">$mime_forward</A>
が設定されていない限り、へッダの取り込みはその時点の 
<A HREF="#weed">$weed</A> 変数の設定によって制御されます。
<P>転送のためのメッセイジ編集は、新規送信や返信と同じ手順に従います。
<P>
<H2><A NAME="postponing_mail"></A> 2.6 メイルを延期する</H2>

<P>
<P>たまに、メッセイジをすでに書き始めたものの、
送信は後にしたいということがあります。
<EM>postpone-message</EM> 関数を<EM>コンポウズ</EM>メニューで
使うと、メイルの本文と添付ファイルは 
<A HREF="#postponed">$postponed</A>
変数で指定されたメイルボックスに格納されます。
これはつまり、Mutt を終了して次回また起動したとしても、
そのメッセイジを呼び出せるということです。
<P>メッセイジを延期したあとで再開するには、いくつかの方法があります。
コマンドラインからは &quot;-p&quot; オプションが使えますし、
<EM>インデックス</EM>や<EM>ペイジャ</EM>から新規作成 (<EM>compose</EM> 関数)
を実行すると、延期したメッセイジがあるときには再開するかどうか聞かれます。
延期メッセイジが複数あるときは、<EM>延期 (postponed)</EM> メニューが出てきて、
どのメッセイジを再開したいか選択できます。
<P><B>注意:</B> メッセイジに対する返信を延期したならば、返信済みフラグが
更新されるのは返信メッセイジを実際に完成させて送信したときだけだということに
注意してください。しかも、その親メッセイジと同じフォルダにいなければ
状態がきちんと更新されません。
<P>
<A HREF="#postpone">$postpone</A> という quadoption
(四択オプション) についてもご覧下さい。
(訳注： postponed とは違う。末尾の &quot;d&quot; に注意！)
<P>
<H2><A NAME="s3">3. 設定</A></H2>

<P>
<P>既定の設定 (すなわち初期値) は、そのままでも Mutt が使えるように
なっていますが、Mutt を自分の好みにあわせて仕立てたいということもよくあります。
起動したとき、
<A HREF="#commandline">コマンドライン</A>
オプションの &quot;-n&quot; が指定されていなければ
Mutt は最初に「システム」設定ファイル (システム管理者が設定した既定値)
を読み出そうとします。この設定ファイルは多くの場合、
<CODE>/usr/local/share/mutt/Muttrc</CODE> か <CODE>/etc/Muttrc</CODE> です
(訳注：FreeBSD などでは <CODE>/usr/local/etc/Muttrc</CODE> も多いと思う)。
次に Mutt はホウムディレクトリの <CODE>.muttrc</CODE> というファイルがないか探します。
もしこのファイルが存在せず、ホウムディレクトリに
<CODE>.mutt</CODE> というサブディレクトリがあれば、<CODE>.mutt/muttrc</CODE>
というファイルを読み込もうとします。
<P><CODE>.muttrc</CODE> は、普段から自分用の
<A HREF="#commands">コマンド</A>を入れておいて Mutt を設定するためのファイルです。
<P>それに加えて Mutt は、上で説明した既定のファイルの代わりに実行する、
特定ヴァージョンの設定ファイルをサポートしています。例えば
システム設定ディレクトリに <CODE>Muttrc-0.88</CODE> というファイルがあって
Mutt のヴァージョン 0.88 を使っていると、<CODE>Muttrc</CODE> ではなく
そのファイルが読み込まれます。
ユーザ設定ファイルに関しても同じことが言えます。
ホウムディレクトリに <CODE>.muttrc-0.88.6</CODE> というファイルがあると、
ヴァージョン 0.88.6 の Mutt を走らせたときには
既定の <CODE>.muttrc</CODE> の代わりにこのファイルを読み込みます。
ヴァージョン番号は、
<A HREF="#commandline">コマンドライン</A>スウィッチの
&quot;-v&quot; を使ったり、インデックスメニューから
<CODE>show-version</CODE> のキー (既定値: V) を使ったりして表示されるものと
同じです。
<P>
<H2><A NAME="muttrc-syntax"></A> 3.1 初期化ファイルの構文</H2>

<P>
<P>初期化ファイルは一連の「コマンド」から成っています。
ファイルの各行には、ひとつでも複数でもコマンドを入れられます。
複数コマンドを使うときはセミコロン (;) で区切らなければなりません。
<BLOCKQUOTE><CODE>
<PRE>
set realname='Mutt ユーザ' ; ignore x-
</PRE>
</CODE></BLOCKQUOTE>

ハッシュマーク、別名ポンド記号 (&quot;#&quot;) は
「コメント」文字として使われます。これは初期化ファイルへの注釈に使えます。
コメント文字以降の文章はすべて無視されます。例えば
<P>
<BLOCKQUOTE><CODE>
<PRE>
my_hdr X-Disclaimer: Why are you listening to me? # ここはコメントです
</PRE>
</CODE></BLOCKQUOTE>
<P>シングルクウォウト (') とダブルクウォウト (&quot;) を使って、
スペイスその他の特殊な文字を含む文字列を扱えます。
この二種類の引用符の違いは、多くの一般的なシェルプログラムに似ています。
つまり、シングルクウォウトはその字面どおりの (シェル変数にも変換されず、
バックスラッシュでの文字指定 [次の段落を参照] も変換されないままの)
文字列を指定するために使う一方、ダブルクウォウトは、中の文字列を解釈すべきだ
ということを示します。
例えば、バックティック (`) はダブルクウォウトの中では解釈されますが、
シングルクウォウトの中では解釈され<B>ません</B>。
<P>\ は、その次の文字をそのまま指定 (原語：quote) します。
ちょうど bash や zsh のようなシェルと同じです。
例えば引用符「&quot;」を文字列の中に入れて使いたいときに
「\」を使って、解釈しない文字どおりの引用符にすることができます。
<BLOCKQUOTE><CODE>
<PRE>
set realname="Michael \"MuttDude\" Elkins"
</PRE>
</CODE></BLOCKQUOTE>
<P>「\\」は「\」そのものを意味します。
「\n」と「\r」は通常の C での意味合いと同じで、
それぞれ改行 (LF = linefeed) と復帰 (CR = carriage-return) を意味します。
<P>行末に \ を使えば、コマンドを複数の行に分割できます。
ただし分割地点がコマンド名の途中であってはなりません。
<P>さらには初期化ファイルの中で、一部を Unix コマンドの出力に
置き換えることも可能です。
これはコマンドをバッククウォウト二つ (``) ではさむことによって行なえます。
例えば、
<BLOCKQUOTE><CODE>
<PRE>
my_hdr X-Operating-System: `uname -a`
</PRE>
</CODE></BLOCKQUOTE>

この `uname -a` の部分は、行を実行する前に「uname -a」という Unix コマンドの
出力で置き換えられます。
ここで注意すべきなのは、初期化ファイルが行指向であるゆえ、
Unix コマンドの出力の最初の行だけにしか置換されないということです。
<P>UNIX 環境変数には、sh や bash といったシェルでやるようにしてアクセスできます。
環境変数の名前の前に &quot;$&quot; を付けるのです。
例えばこうです。
<BLOCKQUOTE><CODE>
<PRE>
set record=+sent_on_$HOSTNAME
</PRE>
</CODE></BLOCKQUOTE>
<P>Mutt が解釈できるコマンドについては、次節以降で説明していきます。
全コマンド一覧は
<A HREF="#commands">コマンド早見表</A>を見てください。
<P>
<H2><A NAME="alias"></A> 3.2 エイリアスを定義・使用する</H2>

<P>
<P>使い方: <CODE>alias</CODE> <EM>エイリアス</EM>　<EM>アドレス</EM> [ , <EM>アドレス</EM>, ... ]
<P>連絡を取ろうとしている人のアドレスをいちいち思い出したり入力したりするのは、
通常とても面倒なことです。
Mutt では、アドレスに割り当てる短い文字列「エイリアス (alias)」を作成できます。
<P><B>注意:</B> グループに対してエイリアスを作成したい
(複数のメイルアドレスを指定したい) 場合は、アドレスを読点 (,)
で区切る<B>必要</B>があります。
<P>エイリアスを削除するには、こうします。
(&quot;*&quot; はエイリアス全部という意味です)
<P><CODE>unalias</CODE> [ * | <EM>キー</EM> <EM>...</EM> ]
<P>
<BLOCKQUOTE><CODE>
<PRE>
alias muttdude me@cs.hmc.edu (Michael Elkins)
alias theguys manny, moe, jack
</PRE>
</CODE></BLOCKQUOTE>
<P>他のメイラとは違い、Mutt は
エイリアスを特別のファイルに定義する必要がありません。
コマンド <CODE>alias</CODE> は、
<A HREF="#source">source</A>
などで読み込まれるファイルであれば、どこにでも書けます。
したがって、複数のエイリアスファイルを使うこともできますし、
muttrc の中にすべて定義してしまうこともできます。
<P>その一方で、
<A HREF="#create-alias">create-alias</A> 関数は
ひとつのファイルしか使えません。
<A HREF="#alias_file">$alias_file</A> 変数
で指定されるファイルだけ (既定では <CODE>~/.muttrc</CODE>) です。
しかし、このファイルは特別扱いされるわけではありません。
というのも、Mutt はどのファイルにでもエイリアスを追加できますし、
このファイルもきちんと 
<A HREF="#source">source</A> しなければ
新規エイリアスが有効にならないのです。
<P>例えばこうです。
<P>
<BLOCKQUOTE><CODE>
<PRE>
source /usr/local/share/Mutt.aliases
source ~/.mail_aliases
set alias_file=~/.mail_aliases
</PRE>
</CODE></BLOCKQUOTE>
<P>エイリアスの使い方は、いつでも Mutt が <EM>To:</EM> や <EM>Cc:</EM>
といったプロンプトでアドレスの入力を促すときに、
エイリアスを入力するだけです。
また 
<A HREF="#edit_headers">$edit_headers</A>
変数を設定してあれば、エディタでも適切なヘッダにエイリアスを入力できます。
<P>加えて、種々のアドレス入力プロンプトにおいては、Tab を使えば
一部だけ入力したエイリアスから完全なエイリアスに展開させることができます。
合致するものが複数あると、Mutt は合致したエイリアスのメニューを出します。
エイリアスの完全な一覧を表示させるには、書きかけのエイリアスのない状態で
Tab を打たなくてはなりません。
例えばプロンプトの最初や、アドレスが複数あることを示すコンマ
(&quot;,&quot;) の後です。
<P>エイリアスメニューでは、エイリアスを好きなだけ <EM>select-entry</EM> キー
(既定値: RET) で選択してから <EM>exit</EM> キー (既定値: q)
を使ってアドレスのプロンプトに戻れます。
<P>
<H2><A NAME="bind"></A> 3.3 既定のキー割り当てを変更する</H2>

<P>使い方: <CODE>bind</CODE> <EM>マップ</EM>　<EM>キー</EM>　<EM>関数</EM>
<P>このコマンドで既定のキー割り当て
(キーを押したときに起動する命令) を変更することができます。
<P><EM>マップ</EM>は、その割り当てがどのメニューのものなのかを指定します。
複数のマップをコンマ (,) で区切って指定することもできます
(ただし空白を入れてはいけません)。
現状で定義されているマップはこうなっています。
<P>
<A NAME="maps"></A> 
<DL>
<DT><B>generic</B><DD><P>これは実際のメニュー名ではなく、ペイジャとエディタ以外の全メニューにおける
最終候補となるものです。Mutt は、キーが実際のメニューで定義されていないとき、
generic の割り当てを使うのです。これによって、関数を複数のメニューのキーに
割り当てることができますので、同じ効果を得るためにいくつも
bind を書かなくて済みます。
(訳注：ただし、いちど bind されたキーは noop に bind しても generic
を見てくれないので、あまり意味がない。今ではマップを複数指定できるので、
alias,attach,browser,index,compose,postpone,pgp と書く方が確実。)
<DT><B>alias</B><DD><P>エイリアスメニューは、muttrc に定義されている個人的エイリアスの一覧です。
短いエイリアス名から完全なメイルアドレスへの割り当てです。
<DT><B>attach</B><DD><P>この添付ファイルメニューを使って、受信したメッセイジの添付ファイルを扱います。
<DT><B>browser</B><DD><P>ブラウザは、ロウカルのディレクトリ構造を閲覧するためにも使いますし、
受信メイルボックスを一覧するためにも使います。
<DT><B>editor</B><DD><P>このエディタは、ユーザがテキストデイタを入力する一行エディタです。
<DT><B>index</B><DD><P>インデックスとは、メイルボックスに含まれているメッセイジの一覧です。
(訳注：このマニュアルやソースコウドでは「メインメニュー」とも呼ばれる。)
<DT><B>compose</B><DD><P>コンポウズメニューは、新規メッセイジを送信するときに使われる画面のことです。
<DT><B>pager</B><DD><P>このペイジャは、メッセイジおよび添付ファイルのデイタや
ヘルプ一覧を表示するために使われるモウドのことです。
<DT><B>pgp</B><DD><P>PGP メニューを使って、送信メッセイジの暗号に使う OpenPGP 鍵を選択します。
<DT><B>postpone</B><DD><P>延期メニューはインデックスメニューに似ていますが、作成して送信せず
次回まで保存しておいたようなメッセイジを復元するときに使うものです。
</DL>
<P><EM>キー</EM> は割り当てたいキー (または
キーシークウェンス = キーの組み合わせ) です。コントロウル文字を指定するには
<EM>\Cx</EM> というキーシークウェンスを使ってください。
この <EM>x</EM> がコントロウル文字です (例えば Control-A を指定するには
&quot;\Ca&quot; とします)。<EM>x</EM> と <EM>\C</EM> が大文字であるか
小文字であるかは無視されるので注意してください。つまり <EM>\CA</EM>,
<EM>\Ca</EM>, <EM>\cA</EM>, <EM>\ca</EM> はすべて等価です。
別の方式は、&quot;\&quot; に続く三桁の 8 進数としてキーを指定します
(例えば <EM>\177</EM> は <EM>\c?</EM> と等価です)。
<P>さらに、これも <EM>キー</EM> に含められます。
<P>
<BLOCKQUOTE><CODE>
<PRE>
\t              タブ (Tab)
&lt;tab>           タブ (Tab)
\r              キャリッジリターン
\n              改行
\e              エスケイプ (Esc)
&lt;esc>           エスケイプ (Esc)
&lt;up>            上矢印 (↑)
&lt;down>          下矢印 (↓)
&lt;left>          左矢印 (←)
&lt;right>         右矢印 (→)
&lt;pageup>        Page Up
&lt;pagedown>      Page Down
&lt;backspace>     Backspace
&lt;delete>        Delete
&lt;insert>        Insert
&lt;enter>         Enter
&lt;return>        Return
&lt;home>          Home
&lt;end>           End
&lt;space>         スペイス
&lt;f1>            ファンクションキー 1  (F1)
&lt;f10>           ファンクションキー 10 (F10)
</PRE>
</CODE></BLOCKQUOTE>
<P><EM>キー</EM> は、スペイスを含まない限り引用符でくくる必要はありません。
<P><EM>関数</EM> は <EM>キー</EM> が押されたときに取る行動を指定します。
関数すべての一覧については 
<A HREF="#functions">関数早見表</A>
を参照して下さい。また、特殊な関数 noop を指定すると、
そのキーシークウェンスへの割り当てをなくします。
(訳注：はじめから割り当てられていないキーは generic が有効だが、
noop に割り当てられたキーは常に何もしない。)
<P>
<H2><A NAME="charset-hook"></A> 3.4 文字セットのエイリアスを定義する </H2>

<P>使い方: <CODE>charset-hook</CODE> <EM>エイリアス</EM>　<EM>文字セット</EM><BR>
使い方: <CODE>iconv-hook</CODE> <EM>文字セット</EM>　<EM>独自の文字セット</EM>
<P><CODE>charset-hook</CODE> コマンドは文字セット (charset) へのエイリアスを定義します。
これは、Mutt の知らない文字セット名が付いたメッセイジを
正しく表示するために使えます。
<P><CODE>iconv-hook</CODE> コマンドは文字セットに対してシステム特有の名前を定義します。
これは、システムの文字変換ライブラリが、文字セットに
システム特有のおかしな名前を使うよう主張するときの助けになります。
(訳注：拡張的な文字セットを使うときに、mutt-j:02343 のパッチを当てて
&quot;iconv-hook 標準的なセット名 拡張セット名&quot;
というような使い方も可能。)
<P>
<P>
<H2><A NAME="folder-hook"></A> 3.5 メイルボックスに基づいて変数を設定する</H2>

<P>使い方: <CODE>folder-hook</CODE> [!]<EM>パターン</EM>　<EM>コマンド</EM>
<P>多くの場合、どのメイルボックスを読んでいるかに合わせて
設定を変更できれば便利です。<CODE>folder-hook</CODE> コマンドは、
そのようにしてどんな設定コマンドでも実行できる手段を提供します。
<EM>パターン</EM>は、どのメイルボックスで (読み出す前に)
<EM>コマンド</EM>を実行するかを指定する正規表現です。
メイルボックスが複数の folder-hook に合致したときには
muttrc で出て来る順番に実行されます。
<P><B>注意:</B> もし 
<A HREF="#spoolfile">$spoolfile</A> への
ショートカットの  &quot;!&quot; をパターンの最初に使うなら、
正規表現の論理演算子 <EM>not</EM> (否定) と区別するために
ダブルかシングルの引用符でくくらなければなりません。
<P>設定はメイルボックスを出るときに復帰<EM>しない</EM>ので注意してください。
例えば、実行したいコマンド動作が、読み出すメイルボックスに合わせて
整列方法を変更することだとします。
<P>
<BLOCKQUOTE><CODE>
<PRE>
folder-hook mutt set sort=threads
</PRE>
</CODE></BLOCKQUOTE>
<P>このようにしたとしても、違うメイルボックスを読み出すときに整列方法が
以前の値に復帰するわけではありません。<EM>既定</EM> のコマンドを指定するには
&quot;.&quot; というパターンを使ってください。
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
folder-hook . set sort=date-sent
</PRE>
</CODE></BLOCKQUOTE>
<P>(訳者の蛇足：つまり、上記のふたつの folder-hook を組み合わせて使えば、
普段は送信日付で整列するし、&quot;mutt&quot; というパターンに
合致するメイルボックスではスレッド整列になる。
&quot;mutt&quot; に合致するメイルボックスから
合致しないメイルボックスに移るときに送信日付へ戻すために、
二番目の folder-hook が必要だというわけ。)
<P>
<H2><A NAME="macro"></A> 3.6 キーボードマクロ</H2>

<P>使い方: <CODE>macro</CODE> <EM>メニュー</EM>　<EM>キー</EM>　<EM>シークウェンス</EM> [ <EM>説明</EM> ]
<P>マクロは、キーひとつで連続作業を実行したいときに便利です。
その<EM>メニュー</EM>でその<EM>キー</EM>を押すと、
<EM>シークウェンス</EM>を入力したのと同様に振る舞うのです。
ですから、よく連続して入力するコマンドがあれば、
マクロを作成してキーひとつでそのコマンドを実行するようにできます。
<P><EM>メニュー</EM>は、マクロを割り当てる
<A HREF="#maps">マップ</A>です。
複数のマップを指定することもできます。
複数メニューをコンマ (,) で区切れば良いのです。
ただし、メニューとコンマの間に空白を使うことはできません。
<P><EM>キー</EM>と<EM>シークウェンス</EM>は
<A HREF="#bind">キー割り当て</A>と
同じルールで展開されます。ただ、いくつか追加があります。
第一点は、<EM>シークウェンス</EM>におけるコントロウル文字を
<EM>^x</EM> とも指定できることです。
カレット (&quot;^&quot;) を使うには
<EM>^^</EM> とする必要があります。
第二に、<EM>Up</EM> などの一部のキーを指定したり、
関数を直接起動したりするために <EM>&lt;キー名&gt;</EM> と
<EM>&lt;関数名&gt;</EM> というフォーマットを使えます。
キー名の一覧については
<A HREF="#bind">キー割り当ての節</A>を
参照してください。関数は
<A HREF="#functions">関数早見表</A>で
一覧になっています。
<P>マクロに関数名を直接使う利点は、それによって
動作時のキー割り当てと関係なくマクロが動くので、
特定のキー定義をしてあるユーザでなくとも使えるということです。
これでマクロは堅固かつ可搬 (ポータブル) になり、何人かで使うファイル
(例えばシステムの Muttrc) の中でマクロを定義するのも容易になります。
(訳注：ここで逆に考えてみれば、関数名を直接指定<EM>しない</EM>マクロは、
folder-hook 等で bind を実行するたびに違う結果を得ることができるので
面白いことができるかもしれない。)
<P>必須ではありませんが、説明文を<EM>シークウェンス</EM>の後ろに指定できます。
これはヘルプ画面に表示されます。
<P><B>注意:</B> ヘルプ画面に表示されるマクロ定義 (定義されていればですが) は、
自動的に画面の幅に切り取られてしまい、折り返し表示はされません。
<P>
<H2><A NAME="color"></A> 3.7 色と白黒の画面属性を使う</H2>

<P>使い方: <CODE>color</CODE> <EM>対象</EM>　<EM>前景</EM>　<EM>背景</EM> [ <EM>正規表現</EM> ]<BR>
使い方: <CODE>color</CODE> index <EM>前景</EM>　<EM>背景</EM>　<EM>パターン</EM><BR>
使い方: <CODE>uncolor</CODE> index <EM>パターン</EM> [ <EM>パターン</EM> ...  ]<BR>
<P>端末がカラー表示をサポートしていれば、独自の色構成を創作して
一味ちがう Mutt にすることができます。ある対象 (情報の型) の色を定義するには
前景色<B>と</B>背景色の両方を指定しなければなりません
(前景だけや背景だけを指定することは不可能です)。
<P><EM>対象</EM>は次のどれかになります。
<P>
<UL>
<LI>attachment (添付ファイル情報)</LI>
<LI>body (メッセイジの本文で<EM>正規表現</EM>に合致する部分)</LI>
<LI>bold (メッセイジの本文の太字強調部分)</LI>
<LI>error (Mutt が出力するエラーメッセイジ)</LI>
<LI>header (メッセイジヘッダで<EM>正規表現</EM>に合致する部分)</LI>
<LI>hdrdefault (ペイジャにおけるメッセイジヘッダの既定の色)</LI>
<LI>index (メッセイジインデックスで<EM>パターン</EM>に合致する部分)</LI>
<LI>indicator (メニューで現在の項目を指し示す矢印もしくはバー
[
<A HREF="#arrow_cursor">$arrow_cursor</A> 参照])</LI>
<LI>markers (ペイジャで折り返された行の行頭にある &quot;+&quot; マーク)</LI>
<LI>message (情報メッセイジ [訳注：エラーでない情報、という意味のように思われる])</LI>
<LI>normal (普通の部分)</LI>
<LI>quoted (メッセイジの本文で 
<A HREF="#quote_regexp">$quote_regexp</A> に合致する文章)</LI>
<LI>quoted1, quoted2, ... quoted<B>N</B> (何段階か重なっている引用)</LI>
<LI>search (ペイジャでの検索語句の強調)</LI>
<LI>signature (署名)</LI>
<LI>status (モウドに合わせて、メイルボックスやメッセイジに関する情報を表示する行)</LI>
<LI>tilde (ペイジャの空行を埋める &quot;~&quot; の部分)</LI>
<LI>tree (メッセイジインデックスと添付ファイルメニューで描かれる
スレッドトゥリー)</LI>
<LI>underline (メッセイジ本文の下線つきパターンを強調する
[訳注：カラーでは下線を使えないのでこれで代用する] )</LI>
</UL>
<P><EM>前景</EM>と<EM>背景</EM>には以下のどれかを使えます。
<P>
<UL>
<LI>white</LI>
<LI>black</LI>
<LI>green</LI>
<LI>magenta</LI>
<LI>blue</LI>
<LI>cyan</LI>
<LI>yellow</LI>
<LI>red</LI>
<LI>default</LI>
<LI>color<EM>x</EM></LI>
</UL>
<P><EM>前景</EM>には先頭に bright というキーワードを付けて
太字にすることもできます
(例えば brightred)。
<P>端末がサポートしていれば、特別なキーワードである <EM>default</EM> を
透明色として使えます。また <EM>brightdefault</EM> という値も有効です。
Mutt が <EM>S-Lang</EM> ライブラリにリンクされていれば、
透明色が正しく動作するように <EM>COLORFGBG</EM> 環境変数を
端末の既定色として設定しておく必要もあります。
例えば (Bourne 系シェルの場合) こうです。
<P>
<BLOCKQUOTE><CODE>
<PRE>
set COLORFGBG="green;black"
export COLORFGBG
</PRE>
</CODE></BLOCKQUOTE>
<P><B>注意</B>: この変数を設定するとき、<EM>S-Lang</EM> ライブラリでは
<EM>white</EM> や <EM>yellow</EM> を使わず、白には <EM>lightgray</EM>, 黄色には <EM>brown</EM>
というキーワードを使う必要があります。
<P><B>注意</B>: uncolor コマンドは index 対象にのみ適用できます。
これは項目をリストから消去します。
消去するには<B>必ず</B> color コマンドで指定したのと同じパターンを指定
しなければなりません。&quot;*&quot; というパターンは特別な印で、
color index のリストを全項目消去することを意味します。
<P>Mutt は <EM>color0</EM>, <EM>color1</EM>, ..., <EM>color</EM><B>N-1</B>
(<B>N</B> は端末でサポートされている色の数) といったキーワードも認識できます。
これは、画面の色を (例えば xterm の color2 に関連付けてある色を変更したりして)
割り当て直したときに有用です。色名が通常の意味を失ってしまうからです。
<P>端末がカラー表示をサポートしていなくとも、画面属性を
&quot;mono&quot; コマンドの使用によって変更することが可能です。
<P>使い方: <CODE>mono</CODE> <I>&lt;対象&gt; &lt;属性&gt;</I> [ <EM>正規表現</EM> ]<BR>
使い方: <CODE>mono</CODE> index <EM>属性</EM>　<EM>パターン</EM><BR>
使い方: <CODE>unmono</CODE> index <EM>パターン</EM> [ <EM>パターン</EM> ... ]<BR>
<P><EM>属性</EM>の部分は以下のどれかです。
<P>
<UL>
<LI>none</LI>
<LI>bold (太字)</LI>
<LI>underline (下線)</LI>
<LI>reverse (反転)</LI>
<LI>standout (点滅等 [語義：くっきりと見やすい])</LI>
</UL>
<P>
<H2><A NAME="ignore"></A> 3.8 不要なメッセイジヘッダを無視 (間引き) する </H2>

<P>使い方: <CODE>[un]ignore</CODE> <EM>パターン</EM> [ <EM>パターン</EM> ... ]
<P>多くのメッセイジには、自動処理システムによって付加された、すなわち、
画面に表示させても役に立つとは思えないようなヘッダフィールドが
たくさん付いています。
このコマンドで、普段は見ないでいたいヘッダフィールドを指定することができます。
<P>ヘッダフィールド名全体を指定する必要はありません。
例えば &quot;ignore content-&quot; は
&quot;content-&quot; で始まるヘッダフィールドをすべて無視します。
<P>以前に追加した項目をリストから外すには &quot;unignore&quot; コマンドを
使ってください。&quot;unignore&quot; コマンドは、指定したパターンの
ヘッダフィールドを表示させます。例えば &quot;ignore x-&quot;
としているとき、&quot;unignore x-mailer&quot; で x-mailer:
を表示することができます。
<P>&quot;unignore *&quot; は無視リストから全項目を消去します。
<P>以下は一例です。
<BLOCKQUOTE><CODE>
<PRE>
# Sven の冷徹なヘッダ間引き設定
ignore *
unignore from date subject to cc
unignore organization organisation x-mailer: x-newsreader: x-mailing-list:
unignore posted-to:
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="alternates"></A> 3.9 代替アドレス</H2>

<P>使い方: <CODE>[un]alternates</CODE> <EM>正規表現</EM> [ <EM>正規表現</EM> ... ]<BR>
<P>Mutt は種々の関数において、自分で送信したメッセイジか
他人から受信したメッセイジかに応じて違う扱い方をします。
例えば、かつて自分が別の団体へ送信したメッセイジに返信を書くとき、
Mutt は自動的にその元メッセイジの宛先へ返事を送るよう提案します。
多くの場合、自分に返事を書くなどということは意味をなさないからです。
(
<A HREF="#reply_to">$reply_to</A> 参照。)
<P>多くのユーザは複数の異なるアドレスでメイルを受信します。
この場合 Mutt の機能をフル活用するには、どのアドレスで自分がメイルを
受信するのかを Mutt が理解できるようにしなくてはなりません。
これこそが <CODE>alternates</CODE> コマンドの目的とするところです。
このコマンドは正規表現のリストを受け取り、それらを使って、
自分がメイルを受信するアドレスを識別するのです。
<P>リストから正規表現を削除するには <CODE>unalternates</CODE> コマンドを使います。
<P>
<H2><A NAME="lists"></A> 3.10 メイリングリスト</H2>

<P>使い方: <CODE>[un]lists</CODE> <EM>正規表現</EM> [ <EM>正規表現</EM> ... ]<BR>
使い方: <CODE>[un]subscribe</CODE> <EM>正規表現</EM> [ <EM>正規表現</EM> ... ]
<P>Mutt には
<A HREF="#using_lists">メイリングリストの扱い</A>に関する
優れた機能が幾つかあります。その益にあずかるには、
どのアドレスがメイリングリストに属するのか、
そして自分がどのメイリングリストを講読しているのかを指定しなければなりません。
そうすれば、
<A HREF="#list-reply">list-reply</A> 関数は
既知のメイリングリストすべてに動作します。
そのうえ、購読しているリストにメッセイジを送るときには Mutt が
Mail-Followup-To へッダを付けて、返信を自分のアドレスにも送ることのないよう
他の人のメイルユーザエイジェント (原語：Mail User Agents = MUA) に
伝えてくれます。
ただ、Mail-Followup-To へッダは非標準的な拡張であって、すべての
MUA でサポートされているわけではないことに注意してください。
このへッダを付けても、リストのメッセイジが自分宛てに CC: で来るのを防ぐ
防弾チョッキにはなりません。
Mail-Followup-To へッダの生成は設定変数 
<A HREF="#followup_to">$followup_to</A> によって制御されることも
覚えておいてください。
<P>さらに正確に言うと、Mutt が管理しているのは、
既知および購読中のメイリングリストのアドレスを表すパターンのリストです。
購読しているメイリングリストはすべて既知になります。
あるメイリングリストを既知であるということにするには
lists コマンドを使ってください。
購読中にするには subscribe コマンドを使います。
<P>どちらのコマンドにも正規表現を使えます。
例えば、Mutt のバグトラッキングシステムにおける
各バグレポートのアドレスに送信されたメッセイジを、
メイリングリストのメイルであるということにするには
&quot;subscribe [0-9]*@bugs\.guug\.de&quot; とすれば良いわけです。
多くの場合は、単にリストのメイルアドレスの一部分を指定するだけで十分です。
<P>十分な長さでアドレスを指定して、あいまいさをなくしてください。
例えば、Mutt のメイリングリストを購読していれば
<EM>mutt-users@mutt.org</EM> に宛てられたメイルを受信することになります。
それで、このアドレスがメイリングリストだということを Mutt に教えるには、
初期化ファイルに &quot;lists mutt-users&quot; を追加できます。
これを購読していることを Mutt に教えるには、代わりに
&quot;subscribe mutt-users&quot; を追加してください。
万一 <EM>mutt-users@example.com</EM> というアドレスの人からメイルを
受け取ることがあるなら、&quot;lists mutt-users@mutt.org&quot;
か &quot;subscribe mutt-users@mutt.org&quot;
を使って、実際にリストから来たメイルにだけ一致させることができます。
<P>unlists コマンドは、既知と購読中のメイリングリストのリストから
項目を消去するために使います。項目をすべて消去するには
&quot;unlists *&quot; を使って下さい。
<P>メイリングリストを、購読中のメイリングリストのリストからは消去しつつ、
既知のメイリングリストのリストに残しておくためには、
&quot;unsubscribe&quot; を使ってください。
<P>
<H2><A NAME="mbox-hook"></A> 3.11 複数のスプールメイルボックスを使う</H2>

<P>使い方: <CODE>mbox-hook</CODE> [!]<EM>パターン</EM>　<EM>メイルボックス</EM>
<P>このコマンドは、終了時やフォルダ変更時に、
既読メッセイジを特定のメイルボックスから違うメイルボックスへと、
自動で移動させるのに使います。
<EM>パターン</EM>は「スプール」のメイルボックスとして扱うメイルボックスを指定する
正規表現で、<EM>メイルボックス</EM>は、既読時にメイルをどこにセイヴ (移動)
すべきかを指定します。
<P>一部の <EM>hook</EM> コマンドと違って、<EM>最初に</EM>合致したパターンだけが
使われます (既読メイルを一度に複数のメイルボックスへセイヴ [移動] することは
できません)。
<P>
<H2><A NAME="mailboxes"></A> 3.12 メイルを受信するメイルボックスを定義する</H2>

<P>使い方: <CODE>mailboxes</CODE> [!]<EM>ファイル名</EM> [ <EM>ファイル名</EM> ... ]
<P>このコマンドは、メイルを受信することがあるフォルダを指定します。
指定したフォルダは、新着メッセイジがあるかどうかチェックされることになります。
既定では、このフォルダのうちのいくつに新着メッセイジがあるかを、
メインメニュー (訳注：インデックスメニュー) のステイタス行が表示します。
<P>フォルダ変更時に<EM>スペイス</EM>を押すと、新着メイルのあるフォルダを
次々に表示します。
<P>ディレクトリブラウザで TAB キーを押すと、
<CODE>mailboxes</CODE> コマンドで指定したファイルを表示するメニューが出ます。
コマンドラインから <CODE>-y</CODE> オプション付きで起動されると、
Mutt は自動的にこのモウドに入ります。
<P>&quot;unmailboxes&quot; コマンドを使って、メイルを受信するフォルダの
リストから項目を削除できます。すべて削除するには &quot;unmailboxes *&quot;
を使います。
<P>
<P><B>注意:</B> 新着メイルは、最終変更時刻と最終アクセス時刻との比較によって
検出されます。<CODE>biff</CODE> や <CODE>frm</CODE> のようなユーティリティや、
メイルボックスにアクセスするその他のプログラムがアクセス時刻を
適切に再設定しなければ、そのメイルボックスでは Mutt が新着メイルを
検出できなくなってしまいます。
バックアップツールもまた、アクセス時刻を更新してしまう一般的な原因です。
<P>
<P><B>注意:</B> <CODE>mailboxes</CODE> コマンド中のファイル名は
コマンド実行時に解決されますので、
<A HREF="#shortcuts">ショートカット文字</A> (&quot;=&quot; や &quot;!&quot; など)
を含んでいるなら、その文字に影響する変数
(
<A HREF="#folder">$folder</A> や 
<A HREF="#spoolfile">$spoolfile</A>など) の定義は <CODE>mailboxes</CODE> コマンドの
前に実行すべきです。
<P>
<H2><A NAME="my_hdr"></A> 3.13 ユーザ定義へッダ</H2>

<P>使い方:<BR>
<CODE>my_hdr</CODE> <EM>文字列</EM><BR>
<CODE>unmy_hdr</CODE> <EM>フィールド</EM> [ <EM>フィールド</EM> ... ]
<P>&quot;my_hdr&quot; コマンドで
自分独自のヘッダフィールドを創作できます。
このヘッダフィールドは送信するメッセイジすべてに付加されます。
<P>例えば送信メッセイジすべてに &quot;Organization:&quot; ヘッダフィールドを
付加したいのであれば、
<P>
<BLOCKQUOTE>
my_hdr Organization: 大会社 (株)
</BLOCKQUOTE>
<P>というコマンドを <CODE>.muttrc</CODE> に入れればいいのです。
<P><B>注意:</B> キーワードとコロン (&quot;:&quot;) の間に
スペイスを入れることは許され<EM>ません</EM>。
電子メイルの規格 (RFC822 [訳注：現在は 2822 か]) で、
そこにスペイスを入れるのは違反だと言われています。
それで Mutt はその規則を強制するというわけです。
<P>単独のメッセイジにヘッダフィールドを付加したい場合は、
<A HREF="#edit_headers">$edit_headers</A> 変数を
設定しておくか、送信メニュー (訳注：コンポウズメニューのことか) で
<EM>edit-headers</EM> 関数 (既定値: E) を使うかのいずれかによって、
メッセイジの本文と一緒にヘッダを編集できます。
<P>ユーザ定義のヘッダフィールドを消去するには
&quot;unmy_hdr&quot; コマンドを使ってください。
アスタリスク (&quot;*&quot;) を指定して
すべてのヘッダフィールドを消去することもできますし、
消去するフィールドを指定することもできます。
例えば、&quot;To&quot; と &quot;Cc&quot; ヘッダフィールドを
すべて削除するには、こうすればよいのです。
<P>
<BLOCKQUOTE>
unmy_hdr to cc
</BLOCKQUOTE>
<P>
<H2><A NAME="hdr_order"></A> 3.14 メッセイジ閲覧時のヘッダの順序を定義する</H2>

<P>使い方: <CODE>hdr_order</CODE> <EM>ヘッダ1</EM> [ <EM>ヘッダ2</EM> <EM>ヘッダ3</EM> ... ]
<P>このコマンドによって、
メッセイジ閲覧時に Mutt がヘッダを表示する順序を指定できます。
<P>&quot;unhdr_order *&quot; は以前に指定したヘッダをすべて
順序リストから解除しますから、システム全体の初期化ファイルによって設定された
ヘッダ順序の効果も消去してしまいます。
<P>
<BLOCKQUOTE><CODE>
<PRE>
hdr_order From Date: From: To: Cc: Subject:
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="save-hook"></A> 3.15 既定のセイヴファイル名を指定する</H2>

<P>使い方: <CODE>save-hook</CODE> [!]<EM>パターン</EM>　<EM>ファイル名</EM>
<P>このコマンドは、メッセイジをセイヴ (移動) するときに使うファイル名の
既定値を上書きするのに使います。
<EM>ファイル名</EM>は、<EM>正規表現パターン</EM>に合致するアドレスが <EM>From:</EM>
のときか、自分が差出人でメッセイジの <EM>To:</EM> が<EM>正規表現パターン</EM>
に合致するときに、既定のファイル名として使われます。
(訳注：send-hook, save-hook, fcc-hook, fcc-save-hook には
printf風シークウェンスが使えるらしい。% 記号を使った書式については
<A HREF="#index_format">$index_format</A> と
<A HREF="#status_format">$status_format</A>
を参照。)
<P><EM>パターン</EM>の正確な書式の情報については
<A HREF="#pattern_hook">「フックにおけるメッセイジの合致」の節</A>を参照してください。
<P>例:
<P>
<BLOCKQUOTE><CODE>
<PRE>
save-hook me@(turing\\.)?cs\\.hmc\\.edu$ +elkins
save-hook aol\\.com$ +spam
</PRE>
</CODE></BLOCKQUOTE>
<P>
<A HREF="#fcc-save-hook">fcc-save-hook</A> コマンドも参照して下さい。
<P>
<H2><A NAME="fcc-hook"></A> 3.16 メッセイジ作成時の既定の Fcc: メイルボックスを指定する</H2>

<P>使い方: <CODE>fcc-hook</CODE> [!]<EM>パターン</EM>　<EM>メイルボックス</EM>
<P>このコマンドは送信メッセイジを 
<A HREF="#record">$record</A>
以外のメイルボックスに保存するために使います。
Mutt はまず、メッセイジ宛先リストの中で<EM>正規表現パターン</EM>を検索して、
最初に合致したものの<EM>メイルボックス</EM>を
既定の Fcc: メイルボックスとして使います。
合致するものが見付からなければ 
<A HREF="#record">$record</A>
つまり「記録」メイルボックスに保存します。
<P><EM>パターン</EM>の正確な書式の情報については
<A HREF="#pattern_hook">「フックにおけるメッセイジの合致」の節</A>を参照してください。
<P>例: <CODE>fcc-hook aol.com$ +spammers</CODE>
<P>上のようにすると、aol.com ドメインに行くことになっているメッセイジは
すべて既定で +spammers メイルボックスにコピーが保存されます
(訳注：もしあれば some@aolicom や any@mx.maol.com なんていうのも
該当してしまうけれど)。
<A HREF="#fcc-save-hook">fcc-save-hook</A> コマンドの節も参照してください。
<P>
<H2><A NAME="fcc-save-hook"></A> 3.17 既定のセイヴファイル名と既定の Fcc:メイルボックスを同時に指定する</H2>

<P>使い方: <CODE>fcc-save-hook</CODE> [!]<EM>パターン</EM>　<EM>メイルボックス</EM>
<P>このコマンドはショートカット (訳注：短縮コマンドのような意味) であり、
同じ引数で 
<A HREF="#fcc-hook">fcc-hook</A> と 
<A HREF="#save-hook">save-hook</A> を両方とも実行するのと等価です。
<P>
<H2><A NAME="send2-hook"></A> <A NAME="reply-hook"></A> <A NAME="send-hook"></A> 3.18 メッセイジの宛先によって設定を変更する</H2>

<P>使い方: <CODE>reply-hook</CODE> [!]<EM>パターン</EM>　<EM>コマンド</EM><BR>
使い方: <CODE>send-hook</CODE> [!]<EM>パターン</EM>　<EM>コマンド</EM><BR>
使い方: <CODE>send2-hook</CODE> [!]<EM>パターン</EM>　<EM>コマンド</EM>
<P>このコマンドを使って、メッセイジの宛先に基づいて任意のコマンドを実行できます。
<EM>パターン</EM>は望みのアドレスに合致する正規表現です。
<EM>コマンド</EM>は、<EM>パターン</EM>がメッセイジの宛先に合致するときに実行されます。
<P><CODE>reply-hook</CODE> は<EM>送信する</EM>メッセイジの代わりに<EM>返信</EM><B>元</B><EM>の</EM>
メッセイジに対して検索されます。<CODE>send-hook</CODE> は<EM>新規</EM>メッセイジにも
<EM>返信</EM>メッセイジに対しても検索されます。
<B>注意:</B> <CODE>reply-hook</CODE> はユーザの設定ファイルに指定されている順番に
<B>関わらず</B> <CODE>send-hook</CODE> より<B>先に</B>検索されます。
<P><CODE>send2-hook</CODE> はメッセイジが変更されるたびに実行されます。
すなわち、編集したか、コンポウズメニューで宛先や題名を変更したときです。
<CODE>send2-hook</CODE> は <CODE>send-hook</CODE> の後に実行されるので、
例えば 
<A HREF="#sendmail">$sendmail</A> 変数のようなパラメータを
自分の送信アドレスに応じたものとするために使うことができます。
<P><CODE>send-hook</CODE> および <CODE>reply-hook</CODE> の各タイプとも、
複数の該当結果が生じたときにコマンドが実行される順番は
(そのタイプのフックのうちでは) muttrc に書かれている順です。
(訳注：それで、変数の設定は後に実行されたほうが先の設定を上書きする。)
<P><EM>パターン</EM>の正確な書式の情報については
<A HREF="#pattern_hook">「フックにおけるメッセイジの合致」の節</A>を参照してください。
<P>例: <CODE>send-hook mutt &quot;set mime_forward signature=''&quot;</CODE>
<P>このコマンドの別の典型的な使い方は、署名と出典の言語を
宛先に応じて変更するために 
<A HREF="#attribution">$attribution</A>,
<A HREF="#signature">$signature</A>,
<A HREF="#locale">$locale</A> 変数の値を切り換えることです。
<P><B>注意</B>: send-hook は最初に宛先リストができた直後に<EM>《一度》</EM>
実行されるだけです。返信を書いたり編集したりしてから宛先を追加しても、
send-hook は《実行され<EM>ません</EM>》。
また、宛先ヘッダや題名を変える my_hdr コマンドが
send-hook から実行されたとき、そのメッセイジには何の影響も与えない
ということにも注意してください。(訳注：
unmy_hdr 等で変更されなければ、<EM>次の</EM>メッセイジには適用される)
<P>
<H2><A NAME="message-hook"></A> 3.19 メッセイジ整形前に設定を変更する</H2>

<P>使い方： <CODE>message-hook</CODE> [!]<EM>パターン</EM>　<EM>コマンド</EM>
<P>このコマンドを使って、メッセイジの閲覧や整形の前に、
そのメッセイジに関する情報に基づいて任意の設定コマンドを実行できます。
表示しようとしているメッセイジに<EM>パターン</EM>が合致していれば
<EM>コマンド</EM>が実行されます。(訳注：無限ループに入らないよう注意！)
複数の合致が生じるときは、muttrc にある順番でコマンドが実行されます。
<P><EM>パターン</EM>の正確な書式の情報については
<A HREF="#pattern_hook">「フックにおけるメッセイジの合致」の節</A>を参照してください。
<P>例：
<BLOCKQUOTE><CODE>
<PRE>
message-hook ~A 'set pager=builtin'
message-hook '~f freshmeat-news' 'set pager="less \"+/^  subject: .*\""'
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="crypt-hook"></A> 3.20 宛先の人の暗号鍵を選ぶ</H2>

<P>使い方: <CODE>crypt-hook</CODE> <EM>パターン</EM>　<EM>鍵ID</EM>
<P>メッセイジを暗号化するとき、
ある特定の鍵をそのメイルアドレスに自動で割り当てたいと思うかもしれません。
それは宛先の公開鍵が目的のアドレスからは推測できないからであったり、
Mutt の通常の選択をなんらかの理由で上書きする必要があるからであったりします。
crypt-hook コマンドは、特定の宛先へのメッセイジを暗号化するときに使う公開鍵の
ID を指定する手段を提供するのです。
<P>ここでは広い意味で「鍵 ID」と言っています。数字の鍵 ID を入れることも
できますし、メイルアドレスも使えます。本名でも構いません。
<P>
<H2><A NAME="push"></A> 3.21 キーボードバッファにキーシークウェンスを加える</H2>

<P>使い方: <CODE>push</CODE> <EM>文字列</EM>
<P>このコマンドは、指名した文字列をキーボードバッファに入れます。この文字列には
<A HREF="#macro">macro</A> コマンドのシークウェンスのように、
コントロウル文字、キーの名前、関数名を含められます。
これを使って、起動時や特定のフォルダへの移動時に、
複数のコマンドを連続実行することもできます。
(訳注：これぞ Mutt 最強のコマンド。修得すべし。)
<P>
<H2><A NAME="exec"></A> 3.22 関数を実行する</H2>

<P>使い方: <CODE>exec</CODE> <EM>関数</EM> [ <EM>関数</EM> ... ]
<P>このコマンドは、あらゆる関数の実行に使えます。
関数は
<A HREF="#functions">関数早見表</A>で一覧にしてあります。
&quot;exec 関数&quot; は &quot;push &lt;関数&gt;&quot; と等価です。
<P>
<H2><A NAME="score-command"></A> 3.23 メイルの得点付け</H2>

<P>使い方: <CODE>score</CODE> <EM>パターン</EM>　<EM>値</EM><BR>
使い方: <CODE>unscore</CODE> <EM>パターン</EM> [ <EM>パターン</EM> ... ]
<P><CODE>score</CODE> コマンドは、<EM>パターン</EM>がメッセイジに合致するなら、指定した
<EM>値</EM>をそのメッセイジの得点に加えます。<EM>パターン</EM>は
<A HREF="#patterns">「パターン」</A>の節に説明してある書式の文字列です
(注意: 効率上の理由から、インデックスで扱えない情報を走査するパターン、
例えば <CODE>~b</CODE>, <CODE>~B</CODE>, <CODE>~h</CODE> 等は
使えません)。
<EM>値</EM>は正か負の整数です。メッセイジの
最終的な得点は、合致する <CODE>score</CODE> コマンドすべての合計です。
しかしながら、<EM>値</EM>の前に等号 (=) を付けて、特定の score
コマンドに合致すればそこで計算を止めさせる (訳注：確定させる)
ということもできます。負数の最終得点は 0 に丸められます。
<P><CODE>unscore</CODE> コマンドは score コマンドのリストから項目を
除去します。<CODE>score</CODE> コマンドで指定したのと<B>同じ</B>パターンを
指定しなければ除去できません。
&quot;*&quot; というパターンは score コマンドのリストを
すべて消去するという意味の特殊記号です。
<P>
<H2><A NAME="spam"></A> 3.24 スパム検出</H2>

<P>使い方: <CODE>spam</CODE> <EM>パターン</EM>　<EM>書式</EM><BR>
使い方: <CODE>nospam</CODE> <EM>パターン</EM>
<P>Mutt には、外部のスパム得点フィルタに対する一般化されたサポートがあります。
自分のスパムパターンを <CODE>spam</CODE> と <CODE>nospam</CODE> で定義することによって、
外部フィルタが決定したスパム属性にもとづいてメイルを
<EM>limit</EM> (表示制限)、<EM>search</EM> (検索)、<EM>sort</EM> (整列)
することができるのです。さらに、スパム属性をインデックス画面に
表示することもできます。<CODE>%H</CODE> を 
<A HREF="#index_format">$index_format</A> 変数に使うのです。(便利ワザ:
<CODE>%?H?[%H] ?</CODE> としてみると、スパムタグがメッセイジに定義されている場合
のみ表示される。)
<P>はじめの一歩として、外部フィルタのスパムパターンを <CODE>spam</CODE> コマンドで
定義します。<EM>パターン</EM> は正規表現で、メイルメッセイジのヘッダに
合致するものであるべきです。メイルボックス中のメッセイジは、
この正規表現に合致すると「スパムタグ」すなわち「スパム属性」を
受け取ります (ただし後述の <CODE>nospam</CODE> パターンに合致している場合は除く)。
この「属性」の表示方法は、自分で完全に制御することができます。
その制御をおこなうのは <EM>書式</EM> パラメータです。<EM>書式</EM> は
静的テキストでも構いませんが、<EM>パターン</EM> からの後方参照を含めることも
できます。(正規表現の「後方参照」とは、括弧の中に含まれた表現を参照するもの。)
<CODE>%1</CODE> は正規表現中の最初の後方参照に置換され、<CODE>%2</CODE> は
二番目の後方参照に置換されるのです。
<P>複数のスパムフィルタを利用していると、メッセイジに
複数のスパム関連ヘッダが付くことがあります。そこで、<CODE>spam</CODE>
コマンドのパターンを各々のフィルタのために複数定義することができます。
メッセイジが複数のパターンに合致したとき、
<A HREF="#spam_separator">$spam_separator</A> 変数が
文字列 (訳注：空文字列を含む) であれば、そのメッセイジのスパムタグは
すべての <EM>書式</EM> 文字列が連結されたものになります。その際、
それぞれの値が 
<A HREF="#spam_separator">$spam_separator</A>
変数で区切られます。
<P>例えば DCC, SpamAssassin, PureMessage を使っているとします。
すると、このようなスパム設定をするかもしれません。
<BLOCKQUOTE><CODE>
<PRE>
spam "X-DCC-.*-Metrics:.*(....)=many"         "90+/DCC-%1"
spam "X-Spam-Status: Yes"                     "90+/SA"
spam "X-PerlMX-Spam: .*Probability=([0-9]+)%" "%1/PM"
set spam_separator=", "
</PRE>
</CODE></BLOCKQUOTE>
<P>このとき、受信したメッセイジが DCC の Fuz2 チェックサムで many と判定され、
PureMessage でスパム確率が 97% と判定された場合に、そのメッセイジの
スパムタグは <CODE>90+/DCC-Fuz2, 97/PM</CODE> となります。(DCC ヘッダで
「=many」の前の四文字は使用したチェックサムを示しています。この場合は
Fuz2 でした。)
<P>
<A HREF="#spam_separator">$spam_separator</A>
変数が解除されていると、<EM>spam</EM> パターンの合致は以前の合致を上書きします。
連結された <EM>書式</EM> 文字列ではなく、最後の合致のみが返されることになります。
<P>スパムタグは、<CODE>%H</CODE> を <CODE>$index_format</CODE> 変数で使用した際に
インデックスへ表示される文字列です。また、<EM>search</EM> (検索) および
<EM>limit</EM> (表示制限) 関数で <CODE>~H</CODE> というパターン合致表現が合致する
文字列でもあります。さらに、スパム属性で整列する際に使うカギでもあります。
<P>これは非常に混み入った例でした。ほとんどの人が実際に利用している環境では、
スパムフィルタはひとつだけでしょう。設定が単純であればあるほど、
Mutt の動作を効果的にすることができます。特に整列に関してそう言えます。
<P>一般的に言って、スパムタグで整列する際に Mutt は <EM>辞書的</EM> に、
すなわち、文字列を一文字ずつ英数字順に評価して整列します。しかしながら、
スパムタグがもしも数字で始まっているならば、まず数値順に整列して、
数値が同じ場合にのみ辞書的に整列します。(これは UNIX の <CODE>sort -n</CODE>
に似ています。) スパム属性が何もないメッセイジ、すなわち、どの
<CODE>spam</CODE> パターンも合致しなかったメッセイジは、最低の順位で整列されます。
数値がそれに続いて、0 から順に高い順位で整列されます。
最後に数字以外の文字列が整列されます。a は z より低い順位になります。
明らかにスパムタグの整列は、フィルタで強制的に数値を返させることが
できれば、概して最も効果的になると言えます。しかし
それができない場合でも、Mutt はまずまず有用な動作をするわけです。
<P><CODE>nospam</CODE> コマンドは <CODE>spam</CODE> パターンの例外を書くために使います。
もしヘッダが <CODE>spam</CODE> コマンドに合致した場合でもスパムタグを付けたくない
条件があるなら、そうしたより詳細なパターンを <CODE>nospam</CODE> コマンドで
列挙することができるのです。
<P><CODE>nospam</CODE> に与えられた <EM>パターン</EM> が既存の <CODE>spam</CODE> リストにある
<EM>パターン</EM> とまったく同一のときには、例外を追加するのではなく
<CODE>spam</CODE> リストからその項目を消去する効果があります。
同様に、<CODE>spam</CODE> コマンドの <EM>パターン</EM> が <CODE>nospam</CODE> リストの
項目に合致する場合には、その <CODE>nospam</CODE> 項目が消去されます。
もし <CODE>nospam</CODE> の <EM>パターン</EM> が &quot;*&quot; であれば、
<EM>リスト双方のすべての項目</EM> が消去されます。<CODE>spam</CODE> や <CODE>nospam</CODE>
を <CODE>folder-hook</CODE> と組み合わせて使う際にはこれを既定動作にすることでしょう。
<P><CODE>spam</CODE> コマンドと <CODE>nospam</CODE> コマンドは、いくつでも好きなだけ
使うことができます。Mutt だけで初歩的なスパム検出をすることも可能です。
例えば <CODE>MAILER-DAEMON</CODE> からのメイルをすべてスパムとみなすのであれば、
このように <CODE>spam</CODE> コマンドを使うことができるでしょう。
<P>
<BLOCKQUOTE><CODE>
<PRE>
spam "^From: .*MAILER-DAEMON"       "999"
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<H2><A NAME="set"></A> 3.25 変数を設定する</H2>

<P>使い方: <CODE>set</CODE> [no|inv]<EM>変数</EM>[=<EM>値</EM>] [ <EM>変数</EM> ... ]<BR>
使い方: <CODE>toggle</CODE> <EM>変数</EM> [<EM>変数</EM> ... ]<BR>
使い方: <CODE>unset</CODE> <EM>変数</EM> [<EM>変数</EM> ... ]<BR>
使い方: <CODE>reset</CODE> <EM>変数</EM> [<EM>変数</EM> ... ]
<P>このコマンドは
<A HREF="#variables">設定変数</A>を設定したり解除したり
するのに使います。変数には基本的な四つの型があります。boolean (二値),
number (数値), string (文字列), quadoption (四値) です。
<EM>boolean</EM> の変数は <EM>設定されている</EM> (真) か <EM>設定されていない</EM> (偽)
かのいずれかです (訳注：訳者の気分により、設定 (yes) と解除 (no) という表現も使う)。
<EM>number</EM> 変数には正の整数を割り当てることができます。
<P><EM>string</EM> 型の変数はいくつかの表示文字 (原語：printable characters,
つまりコントロウル文字以外の文字) で構成されます。
スペイスやタブを含むならば引用符で括らなければなりません。
また &quot;C&quot; のエスケイプシークウェンス <B>\n</B> と <B>\t</B>
を、それぞれ改行とタブの代わりに使用できます。
<P><EM>quadoption</EM> 型の変数は、特定の動作について実行前に質問
するかどうかを制御したり、既定 (訳注：リターンだけを押したとき) の
動作を指定したりするのに使います。<EM>yes</EM> という値は、あたかも質問に
yes と答えたかのような動作を
自動で引き起こします。それと同様、<EM>no</EM> という値は、no と答えたかのような
動作を引き起こします。<EM>ask-yes</EM> という値は既定の答えを yes にして
質問しますし、<EM>ask-no</EM> は既定の答えを no にします。
<P>&quot;no&quot; を変数の前に付けると、変数を解除します。
例: <CODE>set noaskbcc</CODE>
<P><EM>boolean</EM> 型の変数に関しては、変数名の前に <CODE>inv</CODE> を付けて
値を切り替えられます (on ⇔ off)。これはマクロを書くときに便利です。
例: <CODE>set invsmart_wrap</CODE>
<P><CODE>toggle</CODE> コマンドは、指定した変数すべての頭に自動で <CODE>inv</CODE> を付けます。
<P><CODE>unset</CODE> は指定した変数すべての頭に <CODE>no</CODE> を付けるコマンドです。
<P><EM>インデックス</EM>メニューで enter-command 関数を使えば、
変数の名前の前に疑問符を付けることによって、変数の値を問い合わせられます。
<P>
<BLOCKQUOTE><CODE>
<PRE>
set ?allow_8bit
</PRE>
</CODE></BLOCKQUOTE>
<P>この疑問符は、実際には boolean 変数と quadoption 変数にしか
必要ありません。(訳注：ほかは set だけで値を参照できる)
<P><CODE>reset</CODE> コマンドは与えられた変数すべてをコンパイル時の既定値
(おそらく、このマニュアルに書いてある値) に戻します。
<CODE>set</CODE> コマンドで変数の前に &quot;&amp;&quot; を付けると
<CODE>reset</CODE> コマンドと同じ挙動となります。
<P><CODE>reset</CODE> コマンドには特別な変数 &quot;all&quot; が存在し、
これですべての変数をシステムの既定値に戻すことができます。
<P>
<H2><A NAME="source"></A> 3.26 初期化コマンドを別のファイルから読み込む</H2>

<P>使い方: source <I>ファイル名</I>
<P>このコマンドで、初期化コマンドを他のファイルから取り込めます。
例えばエイリアスファイルを <CODE>~/.mail_aliases</CODE> に配置すれば、
<CODE>~/.muttrc</CODE> を (訳注：他ユーザから) 読めるようにしても、
エイリアスは秘密にしておけます。
<P>ファイル名の最初がティルド (&quot;~&quot;) であれば、
自分のホウムディレクトリのパスに展開されます。
<P>ファイル名が縦線 (|) で終わっていれば、指定した<EM>ファイル名</EM>のファイルは
実行プログラムとみなされ、そこから入力を読み出します。(例:
<CODE>source ~/bin/myscript|</CODE>)
<P>
<H2><A NAME="unhook"></A> 3.27 フックを取り除く</H2>

<P>使い方: <CODE>unhook</CODE> [ * | <EM>フック</EM> ]
<P>このコマンドで、それまでに設定してきたフックを流し去ることができます。
あらゆるフックを消すのも &quot;*&quot; を引数として与えることによって
できますし、<CODE>unhook send-hook</CODE> のようにして特定のタイプのフックを
すべて消すということもできます。
<P>
<H2><A NAME="s4">4. 高度な使い方</A></H2>

<H2><A NAME="regexp"></A> 4.1 正規表現</H2>

<P>Mutt における文字列パターンは、より複雑な
<A HREF="#patterns">パターン</A>における文字列パターンも含めて、すべて正規表現
(regular expressions = regexp) の「POSIX 拡張」文法 (egrep や
GNU awk で使われている文法とほぼ同じです) を使って指定しなくてはなりません。
便宜のため、以下にこの文法の簡単な説明を含めました。
<P>検索は、パターンに一つでも大文字があれば文字の大小を意識し、
それ以外は大小を意識しません。&quot;\&quot; を
初期化コマンド中の正規表現に使うには
&quot;\\&quot; とする必要があるので注意してください。
<P>正規表現は一つのパターンで何種類かの文字列を表します。
正規表現は代数表現と同じように、
より小さな式を色々な演算子で組み合わせて構築されます。
<P>正規表現は、「&quot;」や「'」で囲んだり区切ったりできます。
これは正規表現が空白文字を含む場合に便利です。区切り記号「&quot;」と「'」の
処理に関するさらに詳細な情報は、
<A HREF="#muttrc-syntax">「初期化ファイルの構文」</A>の項を参照してください。
そのままの記号として「&quot;」や「'」に合致させるには、
記号の前に「\」(バックスラッシュ [訳注：半角「￥」が表示される
フォントもあるが、英語圏では逆向きスラッシュ]) をつけてください。
<P>基本となる単位は文字ひとつに合致する正規表現です。
すべてのアルファベットと数字を含めて、ほとんどの文字は
自分自身に合致する正規表現です。
特殊な意味を持つメタ文字記号は、前にバックスラッシュを付けることによって
本来の記号に合致します。(訳注：つまり &quot;.&quot; に合致する正規表現は
&quot;\.&quot;)
<P>ピリオド &quot;.&quot; はどんな文字にでも合致します。
カレット &quot;^&quot; とドル記号 &quot;$&quot; はそれぞれ、
行の最初と最後という、文字ではない部分に合致するメタ文字です。
<P>文字を &quot;[&quot; と &quot;]&quot; で囲んだリストは、
その中のどの文字 (一字) にでも合致します。
そのリストの最初の文字がカレット &quot;^&quot; であれば、
そのリストに<B>ない</B>文字に合致します。
例えば <B>[0123456789]</B> は十進数の数字ひとつに合致します。
ある範囲内における最初と最後の文字の間にハイフン &quot;-&quot;
を置けば、その範囲の ASCII 文字全体を指定できます。
リストの中ではほとんどのメタ文字から特別な意味がなくなります。
&quot;]&quot; という記号そのものを含めるには、リストの最初に置きます。
同様に、&quot;^&quot; そのものを含めたい場合はリストの最初以外のどこかに
置けば大丈夫です。そしてハイフン記号 &quot;-&quot;
そのものを含めるにはリストの最後に置くというわけです。
<P>あるクラスの文字は、前もって特定の名前で定義してあります。
文字クラスは、「[:クラスを表すキーワード:]」という構成です。
以下のクラスは POSIX 標準で定められているものです。
<P>
<DL>
<DT><B>[:alnum:]</B><DD><P>アルファベットと数字
<DT><B>[:alpha:]</B><DD><P>アルファベット
<DT><B>[:blank:]</B><DD><P>スペイスとタブ
<DT><B>[:cntrl:]</B><DD><P>コントロウル文字
<DT><B>[:digit:]</B><DD><P>数字
<DT><B>[:graph:]</B><DD><P>表示文字であり可視文字でもある文字 (スペイスは表示文字だが不可視。
一方で &quot;a&quot; は表示文字かつ可視な文字)
<DT><B>[:lower:]</B><DD><P>小文字のアルファベット
<DT><B>[:print:]</B><DD><P>表示文字 (コントロウル文字でない文字のこと)
<DT><B>[:punct:]</B><DD><P>記号 (アルファベット、数字、コントロウル文字、空間文字のどれでもない文字のこと)
<DT><B>[:space:]</B><DD><P>空間文字 (幾つか挙げてみると、
スペイス、タブ、改ペイジといったところ)
<DT><B>[:upper:]</B><DD><P>大文字のアルファベット
<DT><B>[:xdigit:]</B><DD><P>16 進数
</DL>
<P>文字クラスは、文字リストの括弧内の正規表現でのみ有効です。
注意してほしいのは、このクラス名に付いている角括弧はシンボル名の一部であり、
リストを囲む角括弧に加えて、さらに必要になるということです。
例えば <B>[[:digit:]]</B> が
<B>[0-9]</B> と等価です。
<P>さらに二つの特殊シークウェンスを文字リスト中で使えます。
これは非 ASCII 文字セットに適用されるもので、以下のように、
そうした文字セットでは単一のシンボル (照合要素 collating elements
と呼ばれる) が、照合や整列において等価な複数の文字列や文字を
象徴することがあります。
<P>
<DL>
<DT><B>照合記号</B><DD><P>照合記号は複数文字の照合要素を &quot;[.&quot; と
&quot;.]&quot; で括ったもの。
例えば ch が照合要素だとすると、<B>[[.ch.]]</B> が
この照合要素に合致する正規表現。一方、<B>[ch]</B> だと
c または h のどちらかに合致する正規表現ということになってしまう
<DT><B>等価クラス</B><DD><P>等価クラスとは、特定の言語における一連の等価な文字を指す名前のこと。
その名前は &quot;[=&quot; と &quot;=]&quot; で括る。
例えば e という名前で、アクセント記号付きのものも含めた三種類の e を
すべて表わせる。この場合 [[=e=]] は
右下がりアクセントの e (0xE8), 右上がりアクセントの e (0xE9), 普通の e
のどれかであれば合致する正規表現である
</DL>
<P>一字に合致する正規表現は、幾つかある繰り返し演算子のうちの
いずれかを後に付けることができます。
<P>
<DL>
<DT><B>?</B><DD><P>この記号の前にあるアイテムは、あってもなくても良く、
あっても一回しか合致しない (訳注：0 〜 1 回)
<DT><B>*</B><DD><P>この記号の前のアイテムは 0 回でもそれ以上でも合致する (訳注：0 〜 ∞回)
<DT><B>+</B><DD><P>この記号の前のアイテムは一回以上あれば合致する (訳注：1 〜 ∞回)
<DT><B>{n}</B><DD><P>この前のアイテムは、きっちり <EM>n</EM> 回なら合致する
<DT><B>{n,}</B><DD><P>この前のアイテムは <EM>n</EM> 回以上で合致する (訳注：n 回も含む)
<DT><B>{,m}</B><DD><P>この前のアイテムは <EM>m</EM> 回まで合致する (訳注：0 〜 m 回)
<DT><B>{n,m}</B><DD><P>この前のアイテムは <EM>n</EM> 回以上 <EM>m</EM> 回までなら合致する
</DL>
<P>二つの正規表現を連結することができます。その結果できた正規表現が
合致するのは、それぞれに合致する文字列をその順番に並べたものです。
(訳注：訳が悪いので補足すると、例えば [A-Z][0-9] は、
A3 や B5 といった、大文字アルファベットの次に数字が来るような文字列
に合致する一つの正規表現である、ということ。)
<P>二つの正規表現は中間演算子 &quot;|&quot; で連結することもでき、
二つをこのようにつないでできる正規表現は、
いずれかの「子表現」の合致する文字列に合致します。
(訳注：例えば [A-Z]|[0-9] だと、D2 等ではなく
C や 0  や R に合致することになり、[A-Z0-9] と等価になる。
a1B2c3 という文字列に対して、[A-Z][0-9] は B2 にのみ合致し、
[A-Z]|[0-9] は 1 にも B にも 3 にも合致する。)
<P>繰り返し演算子は単なる連結よりも優先されます。
連結はというと、こちらは代替表現より優先されます。
子表現にしたい部分を括弧で囲めば、この優先順位を上書きできます。
(訳注：[a-z][0-9]+ は繰り返し演算子の効力が [0-9] にしかなくて、
aaa777 のうち a777 の部分に合致。
これを ([a-z][0-9])+ にすると括弧内全体に効力が及ぶので、
aaa777 に対しては a7 の部分にのみ合致。a7a7a7 なら全体に合致。)
<P><B>メモ:</B> Mutt を GNU <EM>rx</EM> パッケイジと共にコンパイルしていれば、
次の演算子も正規表現の中で使えます。
<P>
<DL>
<DT><B>\\y</B><DD><P>単語が開始または終了する部分 (訳注：単語とスペイスの間の部分など) に合致する
<DT><B>\\B</B><DD><P>単語の内部 (訳注：文字と文字の間の部分) に合致する
<DT><B>\\&lt;</B><DD><P>単語の開始部分 (訳注：単語の最初の文字とその前のスペイスの間など) に合致する
<DT><B>\\&gt;</B><DD><P>単語の終了部分 (訳注：最後の文字とそれに続くスペイスの間など) に合致する
<DT><B>\\w</B><DD><P>単語要員の文字 (アルファベット、十進数字、アンダスコア [下線]) の
いずれにも合致する
<DT><B>\\W</B><DD><P>単語要員でないあらゆる文字に合致する
<DT><B>\\`</B><DD><P>バッファ (文字列) の開始部分に合致する
<DT><B>\\'</B><DD><P>バッファの終了部分に合致する
</DL>
<P>とはいえご注意いただきたいのは、
これらの演算子が POSIX で定められていないため、これらを
普段のライブラリで使えるシステムも使えないシステムもあるということです。
<P>
<H2><A NAME="patterns"></A> 4.2 パターン</H2>

<P>Mutt コマンドには、パターンを指定して合致したものにだけ適用することの
できるものが多数あります (limit, tag-pattern, delete-pattern 等)。
いくつかの方法でメッセイジを選択できます。
<P>
<BLOCKQUOTE><CODE>
<PRE>
~A              全てのメッセイジ
~b EXPR         メッセイジ本文 (body) に EXPR を含むメッセイジ
~B EXPR         メッセイジ全体のどこかに EXPR を含むメッセイジ
~c USER         USER に CC 送付されているメッセイジ
~C EXPR         To: か Cc: に EXPR のあるメッセイジ
~D              削除される (deleted) メッセイジ
~d [MIN]-[MAX]  送信日 ("date-sent") が範囲内にあるメッセイジ
~E              期限切れ (expired) メッセイジ
~e EXPR         "Sender" フィールドに EXPR を含むメッセイジ
~F              フラグ付き (flagged) メッセイジ
~f USER         USER から送られた (from USER) メッセイジ
~g              暗号で署名されているメッセイジ
~G              暗号化されているメッセイジ
~h EXPR         ヘッダ (header) に EXPR を含むメッセイジ
~k              PGP 鍵 (key) を含むメッセイジ
~i ID           "Message-ID" フィールドに ID が合致するメッセイジ
~L EXPR         EXPR が出したか受けとったか、いずれかのメッセイジ
~l              既知のメイリングリスト (list) へ宛てたメッセイジ
~m [MIN]-[MAX]  番号が MIN から MAX の範囲のメッセイジ *)
~n [MIN]-[MAX]  得点が MIN から MAX の範囲のメッセイジ *)
~N              新着 (new) メッセイジ
~O              古い (old) 未読メッセイジ
~p              自分宛てのメッセイジ (alternates を考慮する)
~P              自分が出したメッセイジ (alternates を考慮する)
~Q              返信済みのメッセイジ
~R              既読 (read) メッセイジ
~r [MIN]-[MAX]  受信日付 "date-received" が範囲内にあるメッセイジ
~S              置き換えられた (superseded) メッセイジ
~s SUBJECT      "Subject" フィールドに SUBJECT を持つメッセイジ
~T              タグ付き (tagged) メッセイジ
~t USER         USER に宛てられた (to USER) メッセイジ
~U              未読 (unread) メッセイジ
~v              折りたたんだスレッドにあるメッセイジ
~x EXPR         "References" フィールドに EXPR を含むメッセイジ
~y EXPR         "X-Label" フィールドに EXPR を含むメッセイジ
~z [MIN]-[MAX]  サイズが MIN から MAX までの範囲にあるメッセイジ *)
~=              重複しているメッセイジ ($duplicate_threads 参照)
~$              参照されていないメッセイジ (スレッド表示が必要)
</PRE>
</CODE></BLOCKQUOTE>
<P>EXPR, USER, ID, SUBJECT の部分は
<A HREF="#regexp">正規表現</A>です。
<P>*) <CODE>&lt;[MAX]</CODE>, <CODE>&gt;[MIN]</CODE>,
<CODE>[MIN]-</CODE>, <CODE>-[MAX]</CODE> という形式も使えます。
<P>
<H3>パターン修飾子</H3>

<P>
<P>アドレスの「リスト」に合致させる種類のパターン (特に
~c, ~C, ~p, ~P, ~t) は、
リストの中に一つでも合致するものがあれば合致してしまうので注意してください。
そのリストの要素すべてに合致する場合に限るには、
パターンの前に ^ を付ける必要があります。
これはドイツの人だけに宛てられたメイルすべてに合致する例です。
<P>
<BLOCKQUOTE><CODE>
<PRE>
^~C \.de$
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3>複雑なパターン</H3>

<P>
<P>複数の条件を指定することによって論理積 AND が計算されます。
例えば、
<P>
<BLOCKQUOTE><CODE>
<PRE>
~t mutt ~f elkins
</PRE>
</CODE></BLOCKQUOTE>
<P>これは、宛先のリストに &quot;mutt&quot; という語を含み、<B>かつ</B>
&quot;From&quot; ヘッダフィールドに &quot;elkins&quot; という語のある
メッセイジを選択します。
<P>Mutt は以下の演算子も認識するので、
さらに複雑な検索パターンを作成できます。
<P>
<UL>
<LI>! -- 論理演算子 NOT (否定)</LI>
<LI>| -- 論理演算子 OR (論理和)</LI>
<LI>() -- グループ化論理演算子</LI>
</UL>
<P>ここに、複雑な検索パターンをよく表している例があります。
このパターンは、メッセイジのうち、&quot;mutt&quot; を
&quot;To&quot; および &quot;Cc&quot; フィールドに含まず、
かつ &quot;elkins&quot; から来ているものすべてを選択します。
<P>
<BLOCKQUOTE><CODE>
<PRE>
!(~t mutt|~c mutt) ~f elkins
</PRE>
</CODE></BLOCKQUOTE>
<P>次は、空白を正規表現内で使う例です (「'」と「&quot;」に注目してください)。
これが合致するのは、メイルの題名が &quot;^Junk +From +Me$&quot;
に合致し、差出人が &quot;Jim +Somebody&quot; か
&quot;Ed +SomeoneElse&quot; であるメッセイジです。
(訳注：「+」は一回以上の繰り返しを表すということを思い出してください。)
<P>
<BLOCKQUOTE><CODE>
<PRE>
 '~s "^Junk +From +Me$" ~f ("Jim +Somebody"|"Ed +SomeoneElse")'
</PRE>
</CODE></BLOCKQUOTE>
<P>正規表現に括弧や垂直棒 ("|") があるときは<B>必ず</B>ダブルクウォウトか
シングルクウォウトで囲まなくてはなりません。それらの記号は Mutt
のパターン言語において別の部分を区切るためにも使われるからです。例えば、
<P>
<BLOCKQUOTE><CODE>
<PRE>
~f "me@(mutt\.org|cs\.hmc\.edu)"
</PRE>
</CODE></BLOCKQUOTE>
<P>これにクウォウトがなかったら、括弧が終わらないことになります。
「<EM>~f me@(mutt\.org</EM>」と「<EM>cs\.hmc\.edu)</EM>」という
二つのパターンが OR されることになるのです。これは絶対に間違いですね。
<P>
<H3>日付で検索する</H3>

<P>Mutt は二種類の日付、すなわち<EM>絶対日付</EM>と
<EM>相対日付</EM>に対応しています。
<P><B>絶対日付</B>。　日付は<B>必ず</B> DD/MM/YY
という形式で指定しなければなりません
(ただし、月と年は現在の月と年が既定になっており、省略できます)。
正しい日付範囲の例は次のとおり (訳注：limit 関数の例)。
<P>
<BLOCKQUOTE><CODE>
<PRE>
メッセイジの表示を制限するパターン: ~d 20/1/95-31/10
</PRE>
</CODE></BLOCKQUOTE>
<P>最小値 (一番目) の日付を省略して &quot;-DD/MM/YY&quot; だけ指定すると、
その日付<EM>以前</EM>のメッセイジがすべて選択されます。
最大値 (二番目) の日付を省略して &quot;DD/MM/YY-&quot; と指定すると、
その日付<EM>以後</EM>のメッセイジがすべて選択されます。
ダッシュ (&quot;-&quot;) なしでひとつだけ日付を指定すると、
その日付に送信されたメッセイジだけが選択されます。
<P><B>誤差範囲</B>。　絶対日付には誤差範囲を付けられます。誤差範囲は、
符号 (+ か -), 次に数字、その次に単位という形式で指定します。
<PRE>
y       年
m       月
w       週
d       日
</PRE>

特例として、符号を &quot;*&quot; にすることができます。
これは正と負に同じだけ誤差を与えるのと等価です。
<P>例: 2001 年 1 月 15 日の前後二週間ずつのメッセイジを選択するには、
次のようなパターンを使えます。
<BLOCKQUOTE><CODE>
<PRE>
 
メッセイジの表示を制限するパターン: ~d 15/1/2001*2w
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P><B>相対日付</B>。　このタイプの日付は、現在の日付から
相対的に見たものです。このように指定できます。
<UL>
<LI>&gt;<EM>offset</EM> (<EM>offset</EM> より長く経過したメッセイジ)</LI>
<LI>&lt;<EM>offset</EM> (経過期間が <EM>offset</EM> より短いメッセイジ)</LI>
<LI>=<EM>offset</EM> (ちょうど <EM>offset</EM> だけ経過したメッセイジ)</LI>
</UL>
<P><EM>offset</EM> は正の数に以下の単位のいずれかを付けたものです。
<PRE>
y       年
m       月
w       週
d       日
</PRE>
<P>例: 生後一ヵ月未満のメッセイジを選択するには次のようにします。
<BLOCKQUOTE><CODE>
<PRE>
メッセイジの表示を制限するパターン: ~d &lt;1m
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<P><B>注意</B>: 検索時に使う日付はすべて<B>ロウカル</B>時間に対する
相対日付ですから、
<A HREF="#index_format">$index_format</A>
の設定を変更して <CODE>%[...]</CODE> フォーマットを
含むようにしないと、必ずしもインデックスに表示されている日付と
<B>同じではありません</B>。
<P>
<H2><A NAME="tags"></A> 4.3 タグを使う</H2>

<P>
<P>操作を実行するときに、一通ずつ扱うよりも、ひとまとめにしたメッセイジを
一度に扱った方が良いことがあります。
例としては、あるメイリングリスト宛てのメッセイジを別のフォルダにセイヴ (移動)
するとか、指定した題名のメッセイジをすべて削除するといったものがあるでしょう。
パターンに合致したメッセイジにタグをつけるには tag-pattern 関数を使います。
これは既定で &quot;shift-T&quot; に割り当てられています。
また、個々のメッセイジを手作業で選択するため &quot;tag-message&quot;
関数を使うこともできます。こちらは既定で &quot;t&quot;
に割り当てられています。Mutt のパターン検索の構文については
<A HREF="#patterns">「パターン」</A>の節を参照して下さい。
<P>お望みのメッセイジにタグをつけたら、&quot;tag-prefix&quot; 演算子を使えます。
これは既定値では &quot;;&quot; (セミコロン) キーです。
&quot;tag-prefix&quot; 演算子が使われると、<B>次の</B>操作は、
タグの付いたメッセイジすべてに適用されます (そのような使い方の
できる操作であれば、ですが)。
もし 
<A HREF="#auto_tag">$auto_tag</A> 変数が
セットされていれば、次の操作が自動的にタグ付きメッセイジへ適用されるので、
&quot;tag-prefix&quot; 演算子は必要ありません。
<P>
<A HREF="#macro">macro</A> や 
<A HREF="#push">push</A> コマンドには
&quot;tag-prefix-cond&quot; 演算子を使うことができます。
タグの付いたメッセイジがない場合には Mutt が残りのマクロを「食って」、
実行されないようにしてくれるのです。
マクロに &quot;end-cond&quot; 演算子が出てきたところで食うのをやめて、
その後の残りのマクロは通常通りに実行されるようになります。
(訳注：特にパターンでタグを付ける際、
必ずしも一つ以上のメッセイジにタグが付いているとは限らない。
タグがない場合に単なる &quot;tag-prefix&quot; を使うと、
カーソルの位置にあるメッセイジへ操作が適用されてしまう。
それで、tag-prefix-cond が追加された。例えば
<CODE>macro index i &lt;tag-pattern&gt;~d*1w\n&lt;tag-prefix-cond&gt;&lt;save-message&gt;=recent\n&lt;end-cond&gt;</CODE>
と設定すると、ここ一週間のメイルを移動するマクロができる。
注意すべき点は、これが単なる条件分岐であるということだ。
&quot;tag-prefix-cond&quot; から &quot;end-cond&quot; までの部分を
タグ付きメッセイジすべてに適用するというわけではなく、
タグ付きメッセイジへ適用されるのは &quot;tag-prefix&quot; と同様、
&quot;tag-prefix-cond&quot; 直後の操作のみである。)
<P>
<H2><A NAME="hooks"></A> 4.4 フックを使う</H2>

<P><EM>フック</EM>とは EMACS エディタから借りてきた概念で、
ある操作の実行前に任意のコマンドを実行できるようにするものです。
例えば、読もうとしているメイルボックスや送ろうとしているメイルのあて先に
基づいて設定を調整したいと思うことがあります。
Mutt の世界において、<EM>フック</EM>は設定オプションやコマンドに合った
<A HREF="#regexp">正規表現</A>や
<A HREF="#patterns">パターン</A>
で構成されます。
利用できる各種<EM>フック</EM>の詳細については、以下を参照してください。
<UL>
<LI>
<A HREF="#folder-hook">folder-hook</A></LI>
<LI>
<A HREF="#send-hook">send-hook</A></LI>
<LI>
<A HREF="#message-hook">message-hook</A></LI>
<LI>
<A HREF="#save-hook">save-hook</A></LI>
<LI>
<A HREF="#mbox-hook">mbox-hook</A></LI>
<LI>
<A HREF="#fcc-hook">fcc-hook</A></LI>
<LI>
<A HREF="#fcc-save-hook">fcc-save-hook</A></LI>
</UL>
<P><B>注意:</B> フックが設定を変更した場合、変更の効果は
その mutt セッションの終わりまで続きます。
これは一般的に望み通りの動作ではありませんので、
既定のフックを他のフックの前に追加して
設定の既定値に復帰する必要があります。
次に挙げるのは send-hook と my_hdr 命令の例です。
(訳注：b@bab や b@b.b といったアドレスを To か Cc に含むメッセイジを
送信するときにのみ自分のアドレスを c@c.c とする、という設定。
最初の send-hook がないと、そのようなメッセイジを送ったあとは
ずっと From: c@c.c のままになる。最初の send-hook があるおかげで
他の宛先には my_hdr が解除されて、from 変数の値が使用される。)
<P>
<BLOCKQUOTE><CODE>
<PRE>
send-hook . 'unmy_hdr From:'
send-hook ~Cb@b.b my_hdr from: c@c.c
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3><A NAME="pattern_hook"></A> フックにおけるメッセイジ合致条件</H3>

<P>メッセイジに対して働くフック (<CODE>send-hook, save-hook, fcc-hook,
message-hook</CODE>) は、他とは少し違う方法で評価されます。
他のタイプのフックコマンドには
<A HREF="#regexp">正規表現</A>で十分ですが、
メッセイジを扱うときには、合致に関して、よりきめ細かな制御が必要です。
目的が異なれば、合致させたいと思う条件も異なるものだからです。
<P>Mutt では、フックコマンドにおけるメッセイジ合致条件に
<A HREF="#patterns">検索パターン</A>言語を使えます。
これは、演算子のうち、メッセイジのへッダ (すなわち from, to, cc, date,
subject 等) から抽出した情報に関するものしか使えない点を除けば、
メイルボックスを <EM>search</EM> (検索) したり
<EM>limit</EM> (表示制限) したりするときとまったく同じように動作します。
<P>例えば、送信メッセイジに基づいて返信先を特定のアドレスに設定したい場合、
次のようにすることができます。
<BLOCKQUOTE><CODE>
<PRE>
send-hook '~t ^me@cs\.hmc\.edu$' 'my_hdr From: Mutt User &lt;user@host>'
</PRE>
</CODE></BLOCKQUOTE>

これは、<EM>me@cs.hmc.edu</EM> 宛てにメイルを送るときに
所定のコマンドを実行する例です。
<P>とはいえ、合致パターンは完全な形の検索言語で書かなければならない
というわけではありません。
他のフック同様、単なる<EM>正規表現</EM>を使っても良く、
この場合 Mutt がそのパターンを完全な言語に翻訳してくれます。
翻訳には 
<A HREF="#default_hook">$default_hook</A>
変数によって指定されている方法を使います。
パターンはそのフックが宣言された時点で翻訳されるので、
その当時有効だった 
<A HREF="#default_hook">$default_hook</A>
の値が使われます。
<P>
<H2><A NAME="query"></A> 4.5 アドレスの外部問い合わせ</H2>

<P>Mutt は、LDAP, ph/qi, bbdb, NIS といった
外部ディレクトリデイタベイスへの接続をサポートしており、これは
簡単なインタフェイスで Mutt に接続するラッパスクリプトを通して実現します。
<A HREF="#query_command">$query_command</A> 変数を使って、
利用するラッパコマンドを指定します。例えばこうです。
<P>
<BLOCKQUOTE><CODE>
<PRE>
set query_command = "mutt_ldap_query.pl '%s'"
</PRE>
</CODE></BLOCKQUOTE>
<P>ラッパスクリプトはコマンドライン上で問い合わせを受け付けることになっています。
一行メッセイジを返し、次に合致結果がそれぞれ一行ずつ並び、
その各行は「アドレス、名前、その他付加情報」をこの順に
タブ区切りで含んでいるべきです。
エラー時、および合致するアドレスがない場合は
0 以外の終了コウドと一行のエラーメッセイジを返します。
<P>複数回答の出力例
<BLOCKQUOTE><CODE>
<PRE>
Searching database ... 20 entries ... 3 matching:
me@cs.hmc.edu           Michael Elkins  mutt dude
blong@fiction.net       Brandon Long    mutt and more
roessler@guug.de        Thomas Roessler mutt pgp
</PRE>
</CODE></BLOCKQUOTE>
<P>Mutt の問い合わせ機能にアクセスする仕組みは二つあります。
一つは問い合わせをインデックスメニューから query 関数 (既定値: Q)
を使って行なう仕組みです。問い合わせ内容を聞かれるので入力すると、
問い合わせメニューが出て合致結果の一覧が表示されるのです。
問い合わせメニューからは、選んだアドレスにエイリアスを作成したり
メイルしたりすることができます。
タグを付けて複数アドレスにメイルすることや、
新しく問い合わせを始める、つまり新規問い合わせを現在の結果内容に追加する
こともできます。
<P>問い合わせ機能にアクセスするもう一つの仕組みは、アドレス補完という、
エイリアス補完と同じような仕組みです。アドレス入力のプロンプトならどれででも
complete-query 関数 (既定値: ^T) を使って、アドレスのうちの、
その時点までに入力済みの部分に基づいた問い合わせを実行できます。
エイリアス のように、どこまで入力済みかについて Mutt は
最後のスペイスかコンマまで戻って調べます。
その問い合わせに結果が一つだけであれば、Mutt はその場でアドレスを展開します。
結果が複数ならば Mutt は問い合わせメニューに移ります。問い合わせメニューでは、
プロンプトに追加するアドレスを一つでも複数でも選択することができます。
<P>
<H2>4.6 メイルボックスの形式</H2>

<P>Mutt は四種類のメイルボックス　―　mbox, MMDF, MH, Maildir　―　の読み書きを
サポートしています。メイルボックスの種類は自動判定されるので、
種類の違いを指示する必要はありません。
新規メイルボックス作成時には 
<A HREF="#mbox_type">$mbox_type</A> 変数で指定される既定値を使います。
<P><B>mbox</B>.　これは UNIX でもっとも広く使われている形式です。
メッセイジは一つのファイルにすべて格納されます。各メッセイジには、
<P>
<BLOCKQUOTE><CODE>
<PRE>
From me@cs.hmc.edu Fri, 11 Apr 1997 11:44:56 PST
</PRE>
</CODE></BLOCKQUOTE>
<P>という形式の行が一行あり、メッセイジの始まりを表しています (これは
しばしば &quot;From_&quot; 行として言及されます)。
<P><B>MMDF</B>.　これは <EM>mbox</EM> 形式の亜種です。それぞれのメイルが
^A^A^A^A (Ctrl-A 四つ) という行で囲まれています。
<P><B>MH</B>.　<EM>mbox</EM> と <EM>MMDF</EM> からの革新的な変形であり、
メイルボックスはディレクトリで構成され、
各メッセイジが別々のファイルに格納されています。
ファイル名はメッセイジ番号を示します (しかし、この番号は
Mutt が表示するメッセイジ番号とは関係ありません)。
削除されたメッセイジはファイル名が変更されて、
先頭にコンマ (,) が付くだけです。
<B>注意:</B> Mutt は、<CODE>.mh_sequences</CODE> か <CODE>.xmhcache</CODE>
がないか探すことによってこの形式を検知します (普通のディレクトリと
MH メイルボックスを区別するために必要です [訳注：西岡・人見訳 1.4-0 では、Mutt
がこれらのファイルを更新しないことが併記されていた。それらのファイルは
MH かどうかを調べるためにのみ使われるということだ])。
<P><B>Maildir</B>.　メイルボックス形式の最新版で、Qmail MTA (sendmail の競合品)
で使われています。<EM>MH</EM> とよく似ていますが、違うのはメイルボックスの
サブディレクトリを三つ (<EM>tmp</EM>, <EM>new</EM>, <EM>cur</EM>)
追加してある点です。
メッセイジのファイル名は、二つのプログラムが同じメイルボックスを
NFS 越しに書き込んでいるときでさえも重ならないような方法で選ばれています。
これはつまり、ファイルのロックが必要ないということを意味します。
<P>
<H2><A NAME="shortcuts"></A> 4.7 メイルボックスの省略形</H2>

<P>特定のメイルボックスを指す組み込みショートカット (省略形) が
幾つか用意されています。
ショートカットは、ファイルやメイルボックスの場所を入力する場面なら
どこででも使えます。
<P>
<UL>
<LI>!　……　
<A HREF="#spoolfile">$spoolfile</A> (受信用) メイルボックスを指す</LI>
<LI>&gt;　……　
<A HREF="#mbox">$mbox</A> メイルボックスを指す</LI>
<LI>&lt;　……　
<A HREF="#record">$record</A> メイルボックスを指す</LI>
<LI>- と !!　……　前にいたメイルボックスを指す</LI>
<LI>~　……　ホウムディレクトリを指す</LI>
<LI>= と +　……　
<A HREF="#folder">$folder</A> メイルボックスを指す</LI>
<LI>@<EM>エイリアス名</EM>　……　このエイリアスのアドレスで識別される
<A HREF="#save-hook">既定のセイヴフォルダ</A>を指す</LI>
</UL>
<P>
<H2><A NAME="using_lists"></A> 4.8 メイリングリストを扱う</H2>

<P>
<P>Mutt には、大量のメイルの取り扱いを容易にする設定オプションが二、三あります。
まず最初にしなければならないのは、どのアドレスを
メイリングリストだとみなすか (仕組みとしてはメイリングリストでなくても
構いませんが、これがもっともよく使われる用途です)、および、
どのリストを講読しているかを Mutt に知らせることです。
これは muttrc で 
<A HREF="#lists">lists および subscribe</A>
コマンドを使って行ないます。
<P>これで Mutt は何がメイリングリストかを知っているので、
できることが幾つか増えました。その一つ目は、
どのリストを経由してメッセイジを受信したか (つまり、講読中のリスト名) を
<EM>インデックス</EM>メニューの画面に表示できることです。
これは同じメイルボックス内にある私用メイルとリストメイルを
区別するのに役立ちます。
<A HREF="#index_format">$index_format</A> 変数の中で使う
&quot;%L&quot; というエスケイプは
&quot;To&quot; フィールドに「リスト名」があれば
&quot;To &lt;リスト名&gt;&quot; という文字列を返し、
&quot;Cc&quot; フィールドなら &quot;Cc &lt;リスト名&gt;&quot;
を返します (どちらでもなければメイルを書いた人の名前を返します)。
<P>メイリングリストのメッセイジには、
&quot;To&quot; と &quot;Cc&quot; のフィールドがどんどん
膨れ上がっていってしまうということが頻繁に見られます。
ほとんどの人は、返信しようとするメッセイジの差出人をわざわざ
そうしたフィールドから削除したりせず、
結果として同じものが複数その人に送られてしまうことになります。
<A HREF="#list-reply">list-reply</A> 関数は、既定では
<EM>インデックス</EM>メニューと<EM>ペイジャ</EM>において
&quot;L&quot; キーに割り当てられていますが、
宛先すべてにではなく既知のメイリングリストのアドレスにのみ返信するので、
こうしたゴミを減らす助けになります
(<CODE>Mail-Followup-To</CODE>で指定してある場合を除きます。以下参照)。
<P>Muttは <CODE>Mail-Followup-To</CODE> へッダもサポートしています。
購読中のメイリングリストが宛先リストに一つでもあって、
<A HREF="#followup_to">$followup_to</A> 変数が
設定されていれば、Mutt はそのメッセイジの送信時に、送り先すべてから
自分を除いた <CODE>Mail-Followup-To</CODE> へッダを生成してくれます。
このヘッダは、このメッセイジへのグループ返信 [group-reply] や
リスト返信 [list-reply] (フォロウアップ [followup] とも言う) が、
そのメッセイジの元々の送り先にのみ送られるべきであって、
それと別に自分へ送る必要はないということ　―　自分の分は
購読しているメイリングリストを通して受け取るということ　―　を示すものです。
<P>逆に自分が <CODE>Mail-Followup-To</CODE> へッダのあるメッセイジに
group-reply したり list-reply したりする場合にも、設定変数の
<A HREF="#honor_followup_to">$honor_followup_to</A>
が設定されていれば Mutt がこのへッダを考慮してくれます。
この場合、list-reply を使うと <CODE>Mail-Followup-To</CODE> の返信先リストで
指定されていなくても返信がメイリングリストへ行くようにしてくれます。
<P>へッダ編集が有効なときは自分で <CODE>Mail-Followup-To</CODE>
へッダを作成できるということを覚えておいてください。
Mutt は、送信時にこのへッダが存在しない場合にだけ、
このへッダを自動生成するのです。
<P>
<P>一部のメイリングリスト管理者が使っている別の手法は、メッセイジの
差出人ではなく、メイリングリストのアドレスを指す &quot;Reply-To&quot;
フィールドを生成するというものです (訳注：日本ではこれが多いかも)。
これは、差出人へ私的に直接返信しようとするときに
問題を引き起こすかもしれません。なぜなら大半のメイルクライアントは、
自動的に &quot;Reply-To&quot; フィールドのアドレスへ返信するからです。
Mutt は、
<A HREF="#reply_to">$reply_to</A> 変数を使って、
どちらのアドレスに返信するか決めさせてくれます。(訳注：ask-yes か ask-no に)
設定されていると、&quot;Reply-To&quot; フィールドにあるアドレスを
使うのかどうかを聞いてきて、使わないと答えると
&quot;From&quot; フィールドのアドレスに直接返信します。
この変数が設定されていない (訳注：yes の) 場合は、あれば &quot;Reply-To&quot;
フィールドが使われます。
<P>&quot;X-Label:&quot; フィールドを使って、メイリングリストや
リストで話題となっている事柄をさらに特定することができます (あるいは
単に、メッセイジへ個別に註釈を付けることも)。
<A HREF="#index_format">$index_format</A> 変数の
&quot;%y&quot; および &quot;%Y&quot; エスケイプを使えば
&quot;X-Label:&quot; フィールドをインデックスに展開できますし、
Mutt のパターン検索では &quot;~y&quot; 選択子を使って正規表現で
&quot;X-Label:&quot; に検索をかけることができます。
&quot;X-Label:&quot; は標準的なへッダフィールドではありませんが、
procmail その他のメイルフィルタリングエイジェントで簡単に挿入できます。
<P>最後の点として、Mutt にはメイルボックスを
<A HREF="#threads">スレッド</A>で
<A HREF="#sort">整列</A>させる能力があります。
スレッドとは、同じ話題でつながっているメッセイジの集まりです。
これは通常、木のような (訳注：枝分かれしている) 構造へとまとめられ、
あるメッセイジとそれに対する返信すべてが画像的に表現されます。
スレッド化されたニューズクライアントを使ったことがあれば、
それと同じ概念だと思ってください。
これによって流量の大きなメイリングリストの扱いが容易になります。
なぜなら、興味がなければ簡単にスレッドごと削除することができ、
価値ある話題を素早く見つけられるからです。
<P>
<H2>4.9 配送状況通知 (Delivery Status Notification = DSN) サポート</H2>

<P>RFC1894 は、電子メイルメッセイジの状態に関する情報を伝達するための、
一連の MIME コンテントタイプを定義しています。
これは「受領証」と考えることができます。
現在 Berkeley sendmail 8.8.x には、
どの種類の状況メッセイジを返させれば良いかを
メイルクライアントが要求できるような、
幾つかのコマンドラインオプションがあります。
<P>これをサポートするための変数が二つあります。
<A HREF="#dsn_notify">$dsn_notify</A> は、
結果の違いによって証書を要求したりしなかったりするために使います
(失敗メッセイジ、配信済みメッセイジ、等)。
<A HREF="#dsn_return">$dsn_return</A> は、
証書に付けて返す元メッセイジをどれだけ要求するか (ヘッダだけか
メッセイジ全体か) です。
DSN に関するさらに詳細な点については
sendmailの man ペイジを参照してください。
<P>
<H2>4.10 POP3 サポート (オプション)</H2>

<P>
<P>Mutt は、POP3 サポートありで (<EM>configure</EM> スクリプト実行時に
<EM>--enable-pop</EM> フラグを付けて) コンパイルしてあれば、
リモウトの POP3 サーバ上にあるメイルボックスを扱ったり、
ロウカル閲覧用にメイルを取りに行ったりすることができます。
<P><CODE>pop://POPサーバ/</CODE> というフォルダを選択することによって、
リモウト POP3 メイルボックスにアクセスできます。
<P>代替ポートの選択も、サーバと一緒に、つまり
<CODE>pop://POPサーバ:ポート/</CODE> と指定することによって可能です。
<P>フォルダごとに違うユーザ名を指定する、つまり
<CODE>pop://ユーザ名@POPサーバ[:ポート]/</CODE> と
指定することもできます。
<P>POP3 経由だと、新着メイル情報の取得にロウカルより負担がかかります。
このため、Mutt がリモウトでメイルチェックする頻度を
<A HREF="#pop_checkinterval">$pop_checkinterval</A> 変数で
制御できます。既定値は 60 秒ごとです。
<P>Mutt が SSL サポートありで (<EM>configure</EM>スクリプト実行時に
<EM>--with-ssl</EM> フラグを付けて) コンパイルしてあれば、
POP3 サーバとの通信は暗号化できます。
これには当然、そのサーバが SSL 暗号化通信をサポートしている必要があります。
POP3/SSL でフォルダにアクセスするには pops: を使います。
つまり <CODE>pops://[ユーザ名@]POPサーバ[:ポート]/</CODE>
です。
<P>POP3 のメイルにアクセスする別の方法は
<EM>fetch-mail</EM> 関数 (既定値: G) です。
POP3 ホスト (
<A HREF="#pop_host">$pop_host</A>) に接続し、
新着メイルをすべて取ってきて、ロウカルのスプール (
<A HREF="#spoolfile">$spoolfile</A>) に置いてくれるのです。
Mutt はそれ以降、そのメイルがまるでずっとロウカルにあったかのように
動作します。
<P><B>メモ:</B>　ロウカルのメイルボックスに全メッセイジを取って来る
だけで良ければ、専門の、例えば
<A HREF="http://www.ccil.org/~esr/fetchmail">fetchmail</A>
のようなプログラムの使用を検討すべきです。
(訳注：これは Mutt 開発者の「本体をできるだけ小さくして、
よそに任せられるところは任せたい」という姿勢を反映しているようだ。
訳者自身は <EM>fetch-mail</EM> を使っていて何の問題もない。
開発者の意図としては <CODE>macro index G !fetchmail\n</CODE>
のように設定すれば事足りるのだから無駄な機能だということであろう。)
<P>
<H2>4.11 IMAP サポート (オプション)</H2>

<P>
<P>IMAPサポートありで (<EM>configure</EM> スクリプト実行時に
<EM>--enable-imap</EM> フラグを付けて) コンパイルされていれば、
Mutt はリモウト IMAP サーバ上にあるフォルダを扱うことができます。
<P>IMAP サーバの名前を <CODE>imapserver</CODE> とすると、
<CODE>imap://imapserver/INBOX</CODE> というフォルダを選択すれば
リモウトの受信箱 (inbox) にアクセスできます。
この <CODE>INBOX</CODE> は、IMAP サーバ上でスプールメイルボックスを表す
特別な名前です。
IMAP サーバの別のメイルフォルダーにアクセスしたい場合は、
そのフォルダのパスが <CODE>path/to/folder</CODE> なら
<CODE>imap://imapserver/path/to/folder</CODE> とします。
<P>サーバと一緒に、つまり
<CODE>imap://imapserver:ポート/INBOX</CODE>
と指定することによって代替ポートも指定できます。
<P>フォルダごとに違うユーザ名を指定することもできます。つまり
<CODE>imap://ユーザ名@imapserver[:ポート]/INBOX</CODE>
です。
<P>Mutt が SSL サポートありで (<EM>configure</EM>スクリプト実行時に
<EM>--enable-ssl</EM> フラグをつけて) コンパイルしてあれば、
IMAP サーバへの接続を暗号化できます。これには当然、サーバが
SSL 暗号化接続をサポートしていることも求められます。
フォルダに IMAP/SSL を使ってアクセスするには、フォルダパスに
<CODE>imaps://[ユーザ名@]imapserver[:ポート]/path/to/folder</CODE>
と指定します。
<P>Pine 互換の書き方もサポートしています。つまり
<CODE>{[ユーザ名@]imapserver[:ポート][/ssl]}path/to/folder</CODE>
です。
<P>すべてのサーバが階層分離記号 (hierarchy separator) に
/ を使っているわけではないことを覚えていてください。
Mutt はどの分離記号がサーバで使われているかを正しく認識し、
それに応じてパスを変換してくれるはずです。
<P>IMAP サーバ上のフォルダを閲覧しているときに、
自分が購読しているフォルダだけを見るか、それともあらゆるフォルダを見るかを、
<EM>toggle-subscribed</EM> コマンドで切り換えられます。
<A HREF="#imap_list_subscribed">$imap_list_subscribed</A> 変数についても
見てください。
<P>IMAP サーバ上の新着メイルを確認すると、動作が遅くなって気になることがあります。
それで、
<A HREF="#mail_check">$mail_check</A> および
<A HREF="#timeout">$timeout</A> 変数は慎重に調整したいと思うことでしょう。
私個人として使っているのは
<BLOCKQUOTE><CODE>
<PRE>
set mail_check=90
set timeout=15
</PRE>
</CODE></BLOCKQUOTE>

ですが、遅いモデム回線にしては、結果は比較的良好です。
<P>v12.250 以前の UW サーバでメイルの格納に mbox を使っている場合は
注意してください。別のクライアントが同じフォルダを選ぶと
接続が切断されてしまうと報告されています。
<P>
<H3>フォルダブラウザ</H3>

<P>
<P>ヴァージョン 1.2 から Mutt は IMAP サーバ上のメイルボックスの
閲覧 (browsing) をサポートしています。
これはロウカルファイルブラウザとほとんど同じですが、
以下のような違いがあります。
<UL>
<LI>ファイルの属性の代わりに &quot;IMAP&quot; という文字列を表示します。
これの後ろに &quot;+&quot; 記号がつく場合がありますが、
これはその中にメッセイジとサブフォルダの両方が含まれていることを意味します。
Cyrus 系サーバの場合にはしばしばフォルダの中に
メッセイジとサブフォルダが入っています。</LI>
<LI>メッセイジとサブフォルダの両方が含まれている場合、<CODE>select-entry</CODE>
(既定では <CODE>enter</CODE> に割り当てられている) のキーを押すと
そのサブフォルダの中に下りていってしまいます。
もしそのフォルダ自体のメッセイジを見たい場合には (既定では
<CODE>スペイス</CODE> に割り当てられている)
<CODE>view-file</CODE> を使わなければなりません。</LI>
<LI>メイルボックスを消すには <CODE>delete-mailbox</CODE> コマンド
(既定では d) を使います。また、メイルボックスの購読
<CODE>subscribe</CODE> と、購読解除 <CODE>unsubscribe</CODE> もできます
(通常は s と u に割り当てられています)。</LI>
</UL>
<P>
<H3>認証</H3>

<P>
<P>Mutt は IMAP サーバに関して四つの認証方法をサポートしています。
SASL, GSSAPI, CRAM-MD5, LOGIN です (かわいそうな exchange ユーザのために
NTLM 認証を追加する、Grant Edwards によるパッチがありますが、
まだメイントゥリーには統合されていません)。また疑似プロトコル ANONYMOUS
のサポートもあります。これは公開 IMAP サーバにアカウントなしでログイン
するためのものです。ANONYMOUS を使うには、単にユーザ名を入れないでおくか、
または &quot;anonymous&quot; にします。
<P>SASL は特殊な、包括的認証方法です。
自分のホストとサーバ両方で利用可能かつ最も堅牢な方法を、いくつかのプロトコル
(GSSAPI, CRAM-MD5, ANONYMOUS, DIGEST-MD5 を含む) の中から、選びます。
これらのうちのいくつかの方法 (DIGEST-MD5 や、多分 GSSAPI も) を使うと、
セッション全体が暗号化され、そこかしこにいるネットワーク覗きの目から
見えなくなります。利用可能なら、これが最善の選択肢です。
SASL を使うには、システムに Cyrus SASL ライブラリがインストールされていて、
かつ、<EM>--with-sasl</EM> 付きで mutt をコンパイルする必要があります。
<P>Mutt は、コンパイル時に組み込まれ、かつサーバ側の利用可能な方法を
すべて試していきます。順番は SASL, ANONYMOUS, GSSAPI, CRAM-MD5, LOGIN です。
<P>認証を制御する変数がいくつかあります。
<UL>
<LI>
<A HREF="#imap_user">$imap_user</A> ―　IMAP
サーバへ認証を要求するユーザ名です。すべての認証方法に使われます。
これはメイルボックスのパスに明示的に含まれるユーザ名
(つまり <CODE>{ユーザ@ホスト}</CODE> の形のメイルボックスを使うこと)
によって上書きされます。</LI>
<LI>
<A HREF="#imap_pass">$imap_pass</A> ―　パスワードです。
パスワードを必要とするすべての認証方法に使います。</LI>
<LI>
<A HREF="#imap_authenticators">$imap_authenticators</A> ―　試行順序にコロンで区切った、
IMAP 認証方法リストです。設定されていると、この変数が mutt の既定値
(あらゆる方法を上記の順に試す) を上書きします。</LI>
</UL>
<P>
<H2><A NAME="account-hook"></A> 4.12 複数の IMAP/POP アカウントを使う (オプション)</H2>

<P>
<P>いくつもの IMAP や POP サーバにアカウントを持っていると、
認証の設定は、面倒くさくて間違いやすいものですよね。
そんなあなたに account-hook コマンドが役に立ちます。
このフックは folder-hook コマンドと同じような働きをするものですが、
開くときだけではなく、リモウトのメイルボックスにアクセスするたびに
呼び出されます (フォルダブラウザ内も含みます)。
<P>例:
<P>
<BLOCKQUOTE><CODE>
<PRE>
account-hook . 'unset imap_user; unset imap_pass; unset tunnel'
account-hook imap://host1/ 'set imap_user=me1 imap_pass=foo'
account-hook imap://host2/ 'set tunnel="ssh host2 /usr/libexec/imapd"'
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="urlview"></A> 4.13 URL に対して WWW ブラウザを起動する (外部コマンド)</H2>

<P>メイルに URL (<EM>unified resource locator</EM> = WWW 空間における住所。
例えば <EM>http://www.mutt.org/</EM>) が含まれているとき、
そうした URL をすべて含むメニューが出てきて、一つ選ぶと WWW ブラウザが
起動すると効率が良いですよね。
この機能は外部プログラムの urlview と
以下の設定コマンドによって提供されています。
urlview は 
<A HREF="ftp://ftp.mutt.org/mutt/contrib/">ftp://ftp.mutt.org/mutt/contrib/</A>で手に入ります。
<BLOCKQUOTE><CODE>
<PRE>
macro index \cb |urlview\n
macro pager \cb |urlview\n
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="s5">5. Mutt の MIME サポート</A></H2>

<P>Mutt をテキストモウド MIME MUA として最上のものとするため、
これまで多大な努力が払われてきました。眼識ある MIME ユーザの要求する機能と
標準への準拠のために、可能な限りのあらゆる努力が払われてきました。
Mutt の MIME 設定に際しては、二つの外部ファイルがあります。
一つは <CODE>mime.types</CODE> ファイルで、これにはファイル拡張子と
IANA MIME タイプとの対応が書いてあります。もう一つは
<CODE>mailcap</CODE> ファイルで、それぞれの MIME タイプを扱うために
使う外部コマンドが指定されています。
<P>
<H2>5.1 Mutt で MIME を使う</H2>

<P>Mutt は三つの場面において、すなわちペイジャ (メイルを閲覧するとき)、
ファイル添付メニュー、コンポウズメニューで MIME を扱います。
<P>
<H3>ペイジャで MIME メッセイジを閲覧する</H3>

<P>インデックスでメイルを選択してペイジャで閲覧するとき、
Mutt はメイルをテキスト表現へと復号化します。Mutt には、
<CODE>text/plain, text/enriched, message/rfc822, message/news</CODE>
といった、数々の MIME タイプのサポート機能が内蔵されています。
輸出制限ヴァージョンの Mutt では、それに加えて PGP/MIME や
application/pgp といった PGP MIME タイプを理解することもできます。
(訳注：1.5.6i のように「i」が付いていれば PGP 機能が付いているはず。)
<P>Mutt は添付ファイルがあることを二、三行の説明で表します。
こんな形式です。
<BLOCKQUOTE><CODE>
<PRE>
[-- Attachment #1: Description --]
[-- Type: text/plain, Encoding: 7bit, Size: 10000 --]
</PRE>
</CODE></BLOCKQUOTE>

<CODE>Description</CODE> の部分は添付ファイルに関する説明やファイル名で、
<CODE>Encoding</CODE> は <CODE>7bit/8bit/quoted-printable/base64/binary</CODE>
のどれかです。
<P>Mutt が扱うことのできない MIME タイプであれば
次のようなメッセイジを表示します。
<BLOCKQUOTE><CODE>
<PRE>
[-- image/gif is unsupported (use 'v' to view this part) --]
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3><A NAME="attach_menu"></A> 添付ファイルメニュー</H3>

<P>既定で &quot;v&quot; に割り当てられている <CODE>view-attachments</CODE>
は、メッセイジの添付ファイルメニューを表示するものです。
添付ファイルメニューにはメッセイジの添付ファイル一覧が表示され、
このメニューから添付ファイルを保存、印刷、パイプ、削除、
閲覧することができます。&quot;tag-prefix&quot; を使えば、
複数の添付ファイルを一度に処理することも可能です。
また、このメニューからメッセイジに返信することもできます。
その場合は、カーソルのある (もしくはタグ付けされている) 添付ファイルのみ
返信に引用されます。添付ファイルは、テキストとして閲覧したり、
mailcap のヴューワ定義を使って閲覧することもできます。
<P>また <CODE>message/rfc822</CODE> タイプのファイルには、
メッセイジ関連の通常の関数 (例えば 
<A HREF="#resend-message">resend-message</A>, reply, forward など) も使えます。
<P>さらに詳しい情報は、添付ファイルメニューでのヘルプをご覧下さい。
<P>
<H3><A NAME="compose_menu"></A> コンポウズメニュー</H3>

<P>コンポウズメニューはメッセイジを送る前に現れるメニューのことです。
このメニューでは宛先のリストを編集できます。題名を編集できます。
その他にもメッセイジの様々な側面を編集することができます。
このメニューには、メッセイジの添付ファイル (本文も含む) の一覧が表示されます。
一つの添付ファイル、もしくはタグ付けされた複数の添付ファイルを、
印刷したり、フィルタにかけたり、パイプに通したり、編集したり、
作成したり、もう一度確認のために閲覧したり、名前を変更したりすることが
できます。また、添付ファイルに関する情報を変更することもできます。
特に注目すべきなのは、content type, 符号化方式、内容説明を
変更できるという点です。
<P>添付ファイルは次のように表示されます。
<PRE>
-   1 [text/plain, 7bit, 1K]             /tmp/mutt-euler-8082-0 &lt;no description&gt;
    2 [applica/x-gunzip, base64, 422K]   ~/src/mutt-0.85.tar.gz &lt;no description&gt;
</PRE>
<P>左端の &quot;-&quot; は、そのファイルがメッセイジの
送信 (または延期や中止) の後に削除されるということを示しています。
この切替は <CODE>toggle-unlink</CODE> コマンド (既定値: u) でおこなえます。
次の欄 は MIME content-type を示しており、
<CODE>edit-type</CODE> コマンド (既定値: ^T) で変更できます。
その次の欄はファイルの符号化方式を示しています。
符号化 (つまり変換) をすることによって、バイナリのメッセイジを
7bit 通信で配送することができるようになります。変更は
<CODE>edit-encoding</CODE> コマンド (既定値: ^E) です。
次の欄はファイルサイズです。キロバイトかメガバイト単位に丸めてあります。
次の欄はファイル名で、変更には <CODE>rename-file</CODE> コマンド (既定値: R)
を使います。最後の欄は添付ファイルの内容説明です。
<CODE>edit-description</CODE> コマンド (既定値: d) で変更できます。
<P>
<H2>5.2 <CODE>mime.types</CODE> による MIME タイプ設定</H2>

<P>メイルにファイルを添付すると、Mutt は個人用の mime.types ファイルを
<CODE>${HOME}/.mime.types</CODE>
に探しに行き、該当するものがなければ、次にシステムの mime.types
ファイルを <CODE>/usr/local/share/mutt/mime.types</CODE>
か <CODE>/etc/mime.types</CODE> に探しに行きます。
<P>mime.types ファイルを構成する各行には、
MIME タイプとスペイス区切りの拡張子のリストが書かれています。
<BLOCKQUOTE><CODE>
<PRE>
application/postscript          ps eps
application/pgp                 pgp
audio/x-aiff                    aif aifc aiff
</PRE>
</CODE></BLOCKQUOTE>

サンプルの <CODE>mime.types</CODE> が Mutt の配布物に付いています。
使いたい MIME タイプはその中にほとんど含まれているはずです。
<P>添付されたファイルの拡張子から MIME タイプを判断できなかったとき、
Mutt はファイルの中身を見に行きます。ファイルにバイナリ情報がなければ
プレインテキストだとみなして <CODE>text/plain</CODE> にします。
バイナリ情報を含んでいれば <CODE>application/octet-stream</CODE> にします。
Mutt が添付ファイルに付けた MIME タイプは、添付ファイルメニュー
から <CODE>edit-type</CODE> コマンド (既定値: ^T) を使って変更できます。
さて、この MIME タイプは、メジャータイプの後に &quot;/&quot;
とサブタイプの付いたものです。メジャータイプは
application, text, image, video, audio, model の 6 種類が、インターネットでの
各種議論の末に承認されています。mime.types ファイルに適当な項目があるならば、
Mutt はこれらすべてを認識することができます。
また、その他のメジャータイプも認識でき、例えば chemical タイプという、
分子モデリング業界で広く使われているタイプなども使うことができます。
これは様々な形式の分子デイタを種々の分子ヴューワに渡すためのものです。
ただし、未承認の MIME タイプを使うのは、そういう添付ファイルが来ることを
相手がわかっている場合だけにすべきです。
<P>
<H2>5.3 <CODE>mailcap</CODE> による MIME ヴューワの設定</H2>

<P>Mutt は、MIME 設定に関する RFC 1524 をサポートしています。
特に RFC 1524 の Appendix A で規定されている
Unix 用フォーマットをサポートしています。
このファイルフォーマットは一般的に mailcap フォーマットと呼ばれます。
多くの MIME 対応プログラムがこの mailcap フォーマットを利用しているので、
すべてのプログラムでのすべての MIME タイプの扱いを
一か所で指定することができます。
このフォーマットを利用しているプログラムには、
Netscape, XMosaic, lynx, metamail などがあります。
<P>Mutt 単体では扱えない様々な MIME タイプを扱うために、
Mutt は外部の設定ファイルを解析して、
扱うことのできる外部プログラムを探します。
設定ファイルを検索する文字列はコロン区切りリストで、
既定値はこうなっています。
<BLOCKQUOTE><CODE>
<PRE>
${HOME}/.mailcap:/usr/local/share/mutt/mailcap:/etc/mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap
</PRE>
</CODE></BLOCKQUOTE>

<CODE>$HOME</CODE> はホウムディレクトリです。
<P>metamail が普通 mailcap ファイルを <CODE>/usr/local/etc/mailcap</CODE> に
インストールします。これに基本的な項目がある程度含まれています。
<P>
<H3>mailcap ファイルの基本</H3>

<P>mailcap ファイルの各行はコメント、空行、定義のいずれかです。
<P>コメント行は # 文字とそれに続く任意の文字で構成されます。
<P>空行は空の行です。
<P>定義行は、content type 一つと閲覧コマンド一つ、そして任意の数の
付加的な欄で構成されています。
定義行の各欄はセミコロン記号 &quot;;&quot; で分けられています。
<P>content type は MIME 標準の「タイプ/サブタイプ」方式で指定します。
例えば、<CODE>text/plain, text/html, image/gif</CODE>等です。
それに加えて、mailcap フォーマットには二種類のワイルドカードもあります。
一つは特殊なサブタイプ '*' を使う方法で、もう一つは暗にワイルドタイプ
を示すものとして、メジャータイプしか書かないという方法です。
例えば、<CODE>image/*</CODE> と <CODE>video</CODE> は、それぞれ
image タイプと video タイプの全体に相当します。
<P>閲覧コマンドは、特定のタイプを閲覧するための Unix コマンドです。
二種類のコマンドがサポートされています。既定では、その
MIME メッセイジの内容を標準入力でコマンドに渡します。
この動作を変更するには、閲覧コマンドの引数に %s を使います。
こうすると Mutt は MIME メッセイジの内容を一時ファイルに保存し、
%s を一時ファイルの名前に置き換えて閲覧コマンドを呼び出します。
どちらの場合も Mutt は端末を閲覧プログラムに明け渡し、
終了するまで待ちます。終了時、一時ファイルは (あれば) 削除されます。
<P>それで、最も単純な形として、text/plain のメッセイジを外部ペイジャ more
に標準入力で渡すことができます。
<BLOCKQUOTE><CODE>
<PRE>
text/plain; more
</PRE>
</CODE></BLOCKQUOTE>

もしくは、メッセイジをファイルとして渡すこともできます。
<BLOCKQUOTE><CODE>
<PRE>
text/plain; more %s
</PRE>
</CODE></BLOCKQUOTE>

lynx を使って対話的に text/html のメッセイジを閲覧したいと思うかもしれません。
<BLOCKQUOTE><CODE>
<PRE>
text/html; lynx %s
</PRE>
</CODE></BLOCKQUOTE>

その場合、lynx は標準入力からのファイル閲覧をサポートしていないので
%s 構文を使わなければなりません。
<B>注意:</B> <EM>古いヴァージョンの lynx には、一部、「text/html にまで
mailcap ファイルをチェックしてしまう」というバグを含むものがあります。
その場合、ヴューワとして lynx を呼ぶように書いてあっても
そのまま実行してしまいます。すると、いつまでも
自分が自分を呼び出し続けることになってしまいます。</EM>
<P>一方、lynx を対話的に使いたいのではなく、単に text/html を text/plain
に変換したいということもあるでしょう。そのときはこうします。
<BLOCKQUOTE><CODE>
<PRE>
text/html; lynx -dump %s | more
</PRE>
</CODE></BLOCKQUOTE>
<P>おそらく、text/html ファイルの閲覧には lynx を使いたいものの、
ほかの text タイプにはすべてペイジャを使いたいということもあるでしょう。
その場合はこういう書き方ができます。
<BLOCKQUOTE><CODE>
<PRE>
text/html; lynx %s
text/*; more
</PRE>
</CODE></BLOCKQUOTE>

これは mailcap ファイルのもっとも単純な形式です。
<P>
<H3>mailcap の安全な使い方</H3>

<P>一般的に言って、MIME パラメータに埋め込まれたメタ文字を解釈して
シェルに渡すことには、セキュリティ上の問題を引き起こす危険性があります。
Mutt は %s 構文の展開の際に正しくパラメータをくくろうとしますし、
危険な文字を別のものに置き換えようとします。
<A HREF="#mailcap_sanitize">mailcap_sanitize</A>
変数を見てください。
<P>Mutt が mailcap からプログラムを呼び出す手順はおそらく安全ですが、
他のアプリケイションも mailcap を読みますし、
中にはそれほど注意を払わないものもあるかも知れません。
そこで、次のようなルールに注意を払うべきです。
<P><EM>シェルクウォウトに %展開を入れない。</EM>　シングルクウォウト (')
やダブルクウォウト (&quot;) で囲ってはいけません。
(訳注：展開後にスペイスが入っても一つの引数として認識されるように
クウォウトしたいと思うかもしれませんが、その必要はありません。)
その辺りのことは Mutt がきちんとやってくれますし、
mailcap を使う他のプログラムも同じはずです。
バッククウォウトを使った展開の中にも入れないでください。
eval 文には特別な注意が必要です。できればまったく使わないでください。
おかしな挙動をクウォウトで直そうとしても、新しい別の水漏れができるだけです。
クウォウトを使っている限り、正しい方法など最初から存在しないのです。
<P>どうしても %展開の値がクウォウトやバッククウォウトの
中に入っていなければならない場合には、まずその値をシェル変数に代入して、
その変数を使うようにしてください。次の例のようにです
(バッククウォウト展開の中で <CODE>$charset</CODE> を使っていますが、
これは安全です。そこからさらに展開されるわけではないからです)。
<P>
<BLOCKQUOTE><CODE>
<PRE>
text/test-mailcap-bug; cat %s; copiousoutput; test=charset=%{charset} \
        &amp;&amp; test "`echo $charset | tr '[A-Z]' '[a-z]'`" != iso-8859-1
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3>一歩進んだ mailcap の使い方</H3>

<P>
<P>
<H3>付加的な欄</H3>

<P>必須である content-type と閲覧コマンドの欄のほかに、
セミコロン ';' で区切った欄を追加して、
各種フラグを付けたりオプションを設定したりすることができます。
Mutt は以下の付加的な欄をサポートしています。
<DL>
<DT><B>copiousoutput</B><DD><P>このフラグは、そのコマンドがテキストを標準出力へ (もしかすると
大量に) 渡すということを Mutt に教えます。このとき Mutt は
ペイジャ (内部ペイジャ、もしくは pager 変数で決めた外部ペイジャ)
を起動して閲覧コマンドの出力を受け取ります。このフラグがなければ、
そのコマンドは対話的に操作できるものとみなされます。
これを使って、「基本的な使い方」の <CODE>lynx -dump</CODE> の例における
more へのパイプを書き換えることができます。
<BLOCKQUOTE><CODE>
<PRE>
text/html; lynx -dump %s ; copiousoutput
</PRE>
</CODE></BLOCKQUOTE>

こうすれば lynx が text/html の出力を text/plain 変換し、
Mutt が標準のペイジャを使ってその結果を表示することになります。
<DT><B>needsterminal</B><DD><P>Mutt は 
<A HREF="#auto_view">auto_view</A> で
添付ファイルを閲覧するときに、このフラグに合わせて 
<A HREF="#wait_key">$wait_key</A> 変数を扱います。
終了時にキーを押すよう求めるかどうかは、
閲覧に対話的な外部プログラムを使っており、かつ
該当する mailcap 項目に <EM>needsterminal</EM> フラグがあるときにのみ、
<A HREF="#wait_key">$wait_key</A>
とプログラムの終了値から決定することになります。
そのほかの場合はすべて、キーを催促せずに終了します。
<DT><B>compose=&lt;command&gt;</B><DD><P>このフラグは、特定の MIME タイプの添付ファイルを新規作成するときに使う
コマンドを指定します。コンポウズメニューにおいてサポートされています。
<DT><B>composetyped=&lt;command&gt;</B><DD><P>このフラグも、その MIME タイプの添付ファイルを新規作成する
コマンドを指定するものです。compose コマンドとの違いは、そのデイタ内に
標準的な MIME ヘッダが含まれていることが期待されているという点です。
これを使って、パラメータ、ファイル名、内容説明などを指定できます。
Mutt はこれをコンポウズメニューでサポートしています。
<DT><B>print=&lt;command&gt;</B><DD><P>特定の MIME タイプの印刷に使うコマンドを指定します。
Mutt では、ファイル添付メニューとコンポウズメニューでサポートされています。
<DT><B>edit=&lt;command&gt;</B><DD><P>このフラグは、特定の MIME タイプの編集に使うコマンドを指定します。
Mutt はこのコマンドをコンポウズメニューでサポートしており、
新しい添付ファイルを作成するときにも使います。
Mutt は既定では editor 変数に定義されたエディタを
テキストの添付ファイルに使用します。
<DT><B>nametemplate=&lt;template&gt;</B><DD><P>閲覧コマンド欄に %s で示されるファイルのファイル名を指定します。
ある種のプログラムは、ファイル名に特定の拡張子がないと、
正しく閲覧してくれなかったりします。例えば lynx は、ファイル名が
<CODE>.html</CODE> で終わっている場合にのみ <CODE>text/html</CODE> であると
解釈します。それで、lynx を <CODE>text/html</CODE> ヴューワに指定するには
次のように mailcap に書くことになるでしょう。
<BLOCKQUOTE><CODE>
<PRE>
text/html; lynx %s; nametemplate=%s.html
</PRE>
</CODE></BLOCKQUOTE>
<DT><B>test=&lt;command&gt;</B><DD><P>その項目を使うべきなのかどうか確認するためのコマンドを指定します。
そのコマンドは、次の節にあるコマンド展開ルールに沿って定義します。
コマンドが 0 を返した場合にはテスト合格ですから、Mutt はその項目を使います。
0 以外の値を返した場合にはテスト失敗で、Mutt はさらに他の正しい項目を
探し続けます。<B>注意:</B> <EM>まず content-type が合致していた場合に
のみテストが実行されます。</EM>さて、例えば
<BLOCKQUOTE><CODE>
<PRE>
text/html; netscape -remote 'openURL(%s)' ; test=RunningX
text/html; lynx %s
</PRE>
</CODE></BLOCKQUOTE>

上の例で Mutt は RunningX を実行します。このプログラムは
X ウィンドウマネジャが動いていれば 0 を返し、そうでなければ
0 以外を返すというものです。RunningX が 0 を返せば、Mutt は
netscape を呼び出して text/html のファイルを表示させます。
もし 0 を返さなければ、次の項目に移って lynx に表示させます。
</DL>
<P>
<H3>検索順序</H3>

<P>ある項目について mailcap ファイルの中から検索する際、Mutt は
その目的に最も合う項目を見付けようとします。
例えば <CODE>image/gif</CODE> を印刷しようとしているとき、
次のような項目が mailcap ファイルにあれば、
print コマンドのあるものを探すので、
<BLOCKQUOTE><CODE>
<PRE>
image/*;        xv %s
image/gif;      ; print= anytopnm %s | pnmtops | lpr; \
                nametemplate=%s.gif
</PRE>
</CODE></BLOCKQUOTE>

<CODE>image/*</CODE> の項を飛び越して、print コマンドのある
<CODE>image/gif</CODE>の項目を使用します。
<P>さて、これを 
<A HREF="#auto_view">auto_view による自動閲覧</A>
と組み合わせて、添付ファイル閲覧のコマンドを二つ指定することもできます。
一つは自動的に閲覧するためのコマンド、
もう一つは添付ファイルメニューから閲覧する対話的なコマンドです。
そのうえ、test 機能を使えば、どのヴューワを使うかを
自分の環境に合わせて対話的に決定できます。
<BLOCKQUOTE><CODE>
<PRE>
text/html;      netscape -remote 'openURL(%s)' ; test=RunningX
text/html;      lynx %s; nametemplate=%s.html
text/html;      lynx -dump %s; nametemplate=%s.html; copiousoutput
</PRE>
</CODE></BLOCKQUOTE>

Mutt は、
<A HREF="#auto_view">auto_view の自動閲覧</A> には
三番目の項目を選択します。copiousoutput タグがついているからです。
対話的な閲覧には、まずプログラム RunningX を走らせて、一番目の項目を
使うかどうか調べます。プログラムが 0 以外を返せば、二番目の項目を使って
対話的閲覧をおこないます。
<P>
<H3>コマンド展開</H3>

<P>mailcap ファイルに定義されている各種のコマンドは
system() 関数を通して <CODE>/bin/sh</CODE> シェルに渡されます。
コマンドは、<CODE>/bin/sh -c</CODE> に渡される前に解析されて、
Mutt からの情報をもとに各種の特殊パラメータが展開されます。
Mutt が展開するキーワードは以下の通りです。
<DL>
<DT><B>%s</B><DD><P>「mailcap の基本」の節で見たように、この変数はファイル名に展開されます。
ファイル名は、それを呼び出している側のプログラム (訳注：ここでは Mutt)
によって指定されます。
このファイルには、閲覧/印刷/編集するメッセイジ内容が含まれています。
もしくは、ファイルを作成するプログラムがそこに結果を保存します。
補足として言っておきますが、このキーワードを使うと、
Mutt はメッセイジの内容を標準入力からは渡さなくなります。
<DT><B>%t</B><DD><P>Mutt は %t をテキスト表現へ展開します。
メッセイジの content type を、mailcap 定義における
最初のパラメータと同じ形式で表現したものです。つまり
<CODE>text/html</CODE> や <CODE>image/gif</CODE> という形式になります。
<DT><B>%{&lt;パラメータ&gt;}</B><DD><P>Mutt はこれを、メイルの Content-Type: 行における特定のパラメータの
値に展開します。例えば、メイルに次のような行があるとします。
<BLOCKQUOTE><CODE>
<PRE>
Content-Type: text/plain; charset=iso-8859-1
</PRE>
</CODE></BLOCKQUOTE>

すると Mutt は %{charset} を iso-8859-1 に展開します。
metamail の既定 mailcap ファイルでは、この機能を使って
文字セットを調べ、xterm を正しい文字セットで起動してメイルを閲覧できる
ようになっています。
<DT><B>\%</B><DD><P>これは % に置き換えられます。
</DL>

Mutt は RFC 1524 で定義されている %F と %n キーワードを
今のところサポートしていません。これらのパラメータの主にマルティパート
メッセイジのためのものですが、マルティパートは Mutt 内部で扱われるからです。
<P>
<H3>mailcap ファイルの例</H3>

<P>下の mailcap ファイルはとても単純かつ標準的なものです。
<HR>
<PRE>
# 常に X を実行していることにします :)
video/*;        xanim %s > /dev/null
image/*;        xv %s > /dev/null

# 常に Netscape を実行していることにします (今よりメモリがあればそうするでしょうから)
text/html;      netscape -remote 'openURL(%s)'
</PRE>
<HR>
<P>下の mailcap ファイルでは、たくさんの例を示しています。
<P>
<HR>
<PRE>
# 動画には、すべて xanim を使います
# xanim は起動時にヘッダを出力しますが、見なくて済むように
# /dev/null へ送ってしまいます
video/*;        xanim %s > /dev/null

# HTML は、実行中の netscape に remote オプションで送ります
text/html;      netscape -remote 'openURL(%s)'; test=RunningNetscape

# netscape を実行していなくて X を実行しているときは
# そのファイルに対して netscape を起動します
text/html;      netscape %s; test=RunningX

# それ以外のときは lynx を使ってテキストで閲覧します
text/html;      lynx %s

# こちらは text/html を text/plain に変換するものです
text/html;      lynx -dump %s; copiousoutput

# enscript を使ってテキストを二段で印刷します
text/*;         more %s; print=enscript -2Gr %s

# netscape は、jpeg を自分で表示するためにフラグを付けます
image/jpeg;xv %s; x-mozilla-flags=internal

# X 実行中の画像閲覧には xv を使います
# なお、ここでは \ を使って行をのばし、画像のエディタも設定しています
image/*;xv %s; test=RunningX; \
        edit=xpaint %s

# netpbm ツールを使って画像をテキストに変換します
image/*;  (anytopnm %s | pnmscale -xysize 80 46 | ppmtopgm | pgmtopbm | pbmtoascii -1x2 ) 2>&amp;1 ; copiousoutput

# excel の表計算ファイルは NT マシンに送ります
application/ms-excel; open.pl %s
</PRE>
<HR>
<P>
<H2><A NAME="auto_view"></A> 5.4 MIME 自動閲覧</H2>

<P>mailcap ファイルに指定されている MIME のヴューワで添付ファイルを
閲覧するよう Mutt に明示的に言う以外に、
ペイジャの中で MIME 添付ファイルを自動的に閲覧する機能もあります。
<P>機能させるには、mailcap ファイルで <CODE>copiousoutput</CODE> オプションを使って
ヴューワを指定しなくてはなりません。そのヴューワが
対話的コマンドではないということを指示するためです。
普通は、ペイジャで閲覧できるようなテキスト表現へと
添付ファイルを変換するためにもこの項目を使います。
<P>それから <CODE>auto_view</CODE> という muttrc のコマンドを使って、
自動的に閲覧したい content-type を羅列します。
<P>例えば次のように <CODE>auto_view</CODE> を指定しているとします。
<BLOCKQUOTE><CODE>
<PRE>
auto_view text/html application/x-gunzip application/postscript image/gif application/x-tar-gz
</PRE>
</CODE></BLOCKQUOTE>
<P>以下のような mailcap 項目を使えば、
こうした添付ファイルを自動的に閲覧できます。
<BLOCKQUOTE><CODE>
<PRE>
text/html;      lynx -dump %s; copiousoutput; nametemplate=%s.html
image/*;        anytopnm %s | pnmscale -xsize 80 -ysize 50 | ppmtopgm | pgmtopbm | pbmtoascii ; copiousoutput
application/x-gunzip;   gzcat; copiousoutput
application/x-tar-gz;   gunzip -c %s | tar -tf - ; copiousoutput
application/postscript; ps2ascii %s; copiousoutput
</PRE>
</CODE></BLOCKQUOTE>
<P>&quot;unauto_view&quot; を使えば、以前に指定した項目を
自動閲覧リストから削除できます。
message-hook と一緒に使うなら、サイズ等に基づいた自動閲覧もできます。
&quot;unauto_view *&quot; は、指定した項目をすべて削除します。
<P>
<H2><A NAME="alternative_order"></A> 5.5 MIME Multipart/Alternative</H2>

<P>Mutt には、multipart/alternative のうち、どのタイプの添付ファイルを
表示するか決定するための発見的手法があります。まず最初に
alternative_order リストを調べて、選べるタイプのなかで
一番望ましいとされているものがあればそれに決めます。
alternative_order リストには複数の MIME タイプが順に並べられます。
これには明示的および暗示的なワイルドカードのサポートも付いています。
例えばこうです。
<BLOCKQUOTE><CODE>
<PRE>
alternative_order text/enriched text/plain text application/postscript image/*
</PRE>
</CODE></BLOCKQUOTE>
<P>次に Mutt は、いずれかのタイプが 
<A HREF="#auto_view">auto_view</A>
で定義されていないかどうかを調べ、それを使います。それでもだめなら
text タイプを探します。最終手段としては、扱い方のわかるタイプが一つでも
ないかどうかと探します。
<P>MIME タイプを <CODE>alternative_order</CODE> リストから削除するには、
<CODE>unalternative_order</CODE> コマンドを使います。
<P>
<H2><A NAME="mime_lookup"></A> 5.6 MIME 調査</H2>

<P>Mutt の mime_lookup リストは、mailcap の項目に従って扱うべきでは
ない MIME タイプを指定するものです。このオプションは、
application/octet-stream のようなバイナリのタイプを取り扱うように
設計されています。
添付ファイルの MIME タイプが mime_lookup に指定されているときは、
そのファイル名の拡張子を mime.types ファイルの拡張子のリストと見比べて、
拡張子に対応する MIME タイプを使って、mailcap にあるルールや
他の指定された設定オプション (例えば auto_view) に従った処理をします。
一般的な使い方はこうです、
<BLOCKQUOTE><CODE>
<PRE>
mime_lookup application/octet-stream application/X-Lotus-Manuscript
</PRE>
</CODE></BLOCKQUOTE>
<P>なお、unmime_lookup コマンドを使えば、
すでにシステムの muttrc 等で設定されている特定の MIME タイプに対して
この機能を適用しないようにすることもできます。
<P>
<H2><A NAME="s6">6. 早見表</A></H2>

<H2><A NAME="commandline"></A> 6.1 コマンドラインオプション</H2>

<P>引数なしで <CODE>mutt</CODE> だけ実行すると、Mutt はスプールメイルボックスを
読みに行きます。しかし、コマンドラインから指定してやることで、
他のメイルボックスを読んだりメイルを送ったりすることも可能です。
<P>
<BLOCKQUOTE><CODE>
<PRE>
-A      エイリアスを展開
-a      メッセイジにファイルを添付
-b      ブラインドカーボンコピー (BCC) アドレスを指定
-c      カーボンコピー (Cc) アドレスを指定
-e      設定コマンドを指定して、初期化ファイルを読んだ後に実行
-f      読み込むメイルボックスを指定
-F      初期化コマンドを読むファイルとして別のものを指定
-h      コマンドラインオプションについてのヘルプを表示
-H      下書きファイルを指定して、そこからヘッダと本文を読み出す
-i      作成メッセイジに含めるファイルを指定
-m      既定のメイルボックスの種類を指定
-n      システムの Muttrc を読まない
-p      延期していたメッセイジを呼び出す
-Q      設定変数を問い合わせる
-R      メイルボックスを読み出し専用で開く
-s      題を指定 (空白を含むときは引用符で囲むこと)
-v      ヴァージョン番号とコンパイル時の設定を表示
-x      mailx(1) のコンポウズモウドを真似る
-y      mailboxes コマンドで指定されたファイルのメニューを表示
-z      メイルボックスにメッセイジが存在しないときはすぐ終了
-Z      新着メッセイジのある最初のフォルダを開くが、なければすぐ終了
</PRE>
</CODE></BLOCKQUOTE>
<P>メイルボックス内のメッセイジを読むには、こうします。
<P><CODE>mutt</CODE> [ -nz ] [ -F <EM>muttrc</EM> ]
[ -m <EM>メイルボックスの種類</EM> ] [ -f <EM>メイルボックス</EM> ]
<P>新規にメッセイジを作成するには、こうします。
<P><CODE>mutt</CODE> [ -n ] [ -F <EM>muttrc</EM> ]
[ -a <EM>添付ファイル</EM> ] [ -c <EM>CCアドレス</EM> ]
[ -i <EM>引用ファイル</EM> ] [ -s <EM>題名</EM> ] <EM>アドレス</EM>
[ <EM>アドレス</EM> ... ]
<P>Mutt は、準備しておいたメッセイジを送信する &quot;batch&quot; モウドも
サポートしています。
単に、送信したいファイルから入力へリダイレクトしてください。例えば、
<P><CODE>mutt -s &quot;data set for run #2&quot; professor@bigschool.edu
&lt; ~/run2.dat</CODE>
<P>このコマンドは、メッセイジを &quot;professor@bigschool.edu&quot; に
&quot;data set for run #2&quot; という題で送信します。
そのメッセイジの本文にはファイル &quot;~/run2.dat&quot;
の内容が入ります。
<P>
<H2><A NAME="commands"></A> 6.2 設定コマンド</H2>

<P>以下が、Mutt の理解するコマンドです。
<P>
<UL>
<LI><CODE>
<A HREF="#account-hook">account-hook</A></CODE> <EM>パターン</EM>　<EM>コマンド</EM></LI>
<LI><CODE>
<A HREF="#alias">alias</A></CODE> <EM>キー</EM>　<EM>アドレス</EM> [ , <EM>アドレス</EM>, ... ]</LI>
<LI><CODE>
<A HREF="#alias">unalias</A></CODE> [ * | <EM>キー</EM> ... ]</LI>
<LI><CODE>
<A HREF="#alternates">alternates</A></CODE> <EM>正規表現</EM> [ <EM>正規表現</EM> ... ]</LI>
<LI><CODE>
<A HREF="#alternates">unalternates</A></CODE> [ * | <EM>正規表現</EM> ... ]</LI>
<LI><CODE>
<A HREF="#alternative_order">alternative_order</A></CODE> <EM>MIME</EM> [ <EM>MIME</EM> ... ]</LI>
<LI><CODE>
<A HREF="#alternative_order">unalternative_order</A></CODE> <EM>MIME</EM> [ <EM>MIME</EM> ... ]</LI>
<LI><CODE>
<A HREF="#auto_view">auto_view</A></CODE> <EM>MIME</EM> [ <EM>MIME</EM> ... ]</LI>
<LI><CODE>
<A HREF="#auto_view">unauto_view</A></CODE> <EM>MIME</EM> [ <EM>MIME</EM> ... ]</LI>
<LI><CODE>
<A HREF="#bind">bind</A></CODE> <EM>使う場面</EM>　<EM>キー</EM>　<EM>関数</EM></LI>
<LI><CODE>
<A HREF="#charset-hook">charset-hook</A></CODE> <EM>別名</EM>　<EM>文字セット</EM></LI>
<LI><CODE>
<A HREF="#color">color</A></CODE> <EM>対象</EM>　<EM>前景</EM>　<EM>背景</EM> [ <EM>正規表現</EM> ]</LI>
<LI><CODE>
<A HREF="#color">uncolor</A></CODE> <EM>index</EM> <EM>パターン</EM> [ <EM>パターン</EM> ... ]</LI>
<LI><CODE>
<A HREF="#exec">exec</A></CODE> <EM>関数</EM> [ <EM>関数</EM> ... ]</LI>
<LI><CODE>
<A HREF="#fcc-hook">fcc-hook</A></CODE> <EM>パターン</EM>　<EM>メイルボックス</EM></LI>
<LI><CODE>
<A HREF="#fcc-save-hook">fcc-save-hook</A></CODE> <EM>パターン</EM>　<EM>メイルボックス</EM></LI>
<LI><CODE>
<A HREF="#folder-hook">folder-hook</A></CODE> <EM>パターン</EM>　<EM>コマンド</EM></LI>
<LI><CODE>
<A HREF="#hdr_order">hdr_order</A></CODE> <EM>ヘッダ</EM> [ <EM>ヘッダ</EM> ... ]</LI>
<LI><CODE>
<A HREF="#hdr_order">unhdr_order</A></CODE> <EM>ヘッダ</EM> [ <EM>ヘッダ</EM> ... ]</LI>
<LI><CODE>
<A HREF="#charset-hook">iconv-hook</A></CODE> <EM>文字セット</EM>　<EM>ロウカル文字セット</EM></LI>
<LI><CODE>
<A HREF="#ignore">ignore</A></CODE> <EM>パターン</EM> [ <EM>パターン</EM> ... ]</LI>
<LI><CODE>
<A HREF="#ignore">unignore</A></CODE> <EM>パターン</EM> [ <EM>パターン</EM> ... ]</LI>
<LI><CODE>
<A HREF="#lists">lists</A></CODE> <EM>正規表現</EM> [ <EM>正規表現</EM> ... ]</LI>
<LI><CODE>
<A HREF="#lists">unlists</A></CODE> <EM>正規表現</EM> [ <EM>正規表現</EM> ... ]</LI>
<LI><CODE>
<A HREF="#macro">macro</A></CODE> <EM>メニュー</EM>　<EM>キー</EM>　<EM>操作内容</EM> [ <EM>説明</EM> ]</LI>
<LI><CODE>
<A HREF="#mailboxes">mailboxes</A></CODE> <EM>ファイル名</EM> [ <EM>ファイル名</EM> ... ]</LI>
<LI><CODE>
<A HREF="#mbox-hook">mbox-hook</A></CODE> <EM>パターン</EM>　<EM>メイルボックス</EM></LI>
<LI><CODE>
<A HREF="#message-hook">message-hook</A></CODE> <EM>パターン</EM>　<EM>コマンド</EM></LI>
<LI><CODE>
<A HREF="#mime_lookup">mime_lookup</A></CODE> <EM>MIME</EM> [ <EM>MIME</EM> ... ]</LI>
<LI><CODE>
<A HREF="#mime_lookup">unmime_lookup</A></CODE> <EM>MIME</EM> [ <EM>MIME</EM> ... ]</LI>
<LI><CODE>
<A HREF="#color">mono</A></CODE> <EM>属性</EM> [ <EM>正規表現</EM> ]</LI>
<LI><CODE>
<A HREF="#color">unmono</A></CODE> <EM>index</EM> <EM>パターン</EM> [ <EM>パターン</EM> ... ]</LI>
<LI><CODE>
<A HREF="#my_hdr">my_hdr</A></CODE> <EM>文字列</EM></LI>
<LI><CODE>
<A HREF="#my_hdr">unmy_hdr</A></CODE> <EM>フィールド</EM> [ <EM>フィールド</EM> ... ]</LI>
<LI><CODE>
<A HREF="#crypt-hook">crypt-hook</A></CODE> <EM>パターン</EM>　<EM>鍵ID</EM></LI>
<LI><CODE>
<A HREF="#push">push</A></CODE> <EM>文字列</EM></LI>
<LI><CODE>
<A HREF="#reply-hook">reply-hook</A></CODE> [!]<EM>パターン</EM>　<EM>コマンド</EM></LI>
<LI><CODE>
<A HREF="#set">reset</A></CODE> <EM>変数</EM> [<EM>変数</EM> ... ]</LI>
<LI><CODE>
<A HREF="#save-hook">save-hook</A></CODE> <EM>正規表現</EM>　<EM>ファイル名</EM></LI>
<LI><CODE>
<A HREF="#score-command">score</A></CODE> <EM>パターン</EM>　<EM>値</EM></LI>
<LI><CODE>
<A HREF="#score-command">unscore</A></CODE> <EM>パターン</EM> [ <EM>パターン</EM> ... ]</LI>
<LI><CODE>
<A HREF="#send-hook">send-hook</A></CODE> <EM>正規表現</EM>　<EM>コマンド</EM></LI>
<LI><CODE>
<A HREF="#send2-hook">send2-hook</A></CODE> <EM>正規表現</EM>　<EM>コマンド</EM></LI>
<LI><CODE>
<A HREF="#set">set</A></CODE> [no|inv]<EM>変数</EM>[=<EM>値</EM>] [ <EM>変数</EM> ... ]</LI>
<LI><CODE>
<A HREF="#set">unset</A></CODE> <EM>変数</EM> [<EM>変数</EM> ... ]</LI>
<LI><CODE>
<A HREF="#source">source</A></CODE> <EM>ファイル名</EM></LI>
<LI><CODE>
<A HREF="#spam">spam</A></CODE> <EM>パターン</EM>　<EM>書式</EM></LI>
<LI><CODE>
<A HREF="#spam">nospam</A></CODE> <EM>パターン</EM></LI>
<LI><CODE>
<A HREF="#lists">subscribe</A></CODE> <EM>アドレス</EM> [ <EM>アドレス</EM> ... ]</LI>
<LI><CODE>
<A HREF="#lists">unsubscribe</A></CODE> <EM>アドレス</EM> [ <EM>アドレス</EM> ... ]</LI>
<LI><CODE>
<A HREF="#set">toggle</A></CODE> <EM>変数</EM> [<EM>変数</EM> ... ]</LI>
<LI><CODE>
<A HREF="#unhook">unhook</A></CODE> <EM>フック</EM></LI>
</UL>
<P>
<H2><A NAME="variables"></A> 6.3 設定変数</H2>

<P>
<P>
<P>
<H3><A NAME="abort_nosubject"></A> abort_nosubject</H3>

<P>Type: quadoption<BR>
Default: ask-yes
<P>
<P><EM>yes</EM> に設定されていると、メッセイジ作成時の題名入力に対して
題が与えられなかったときに、作成が中止される。
<EM>no</EM> に設定されていると、題がなくても中止されない。
<P>
<P>
<H3><A NAME="abort_unmodified"></A> abort_unmodified</H3>

<P>Type: quadoption<BR>
Default: yes
<P>
<P><EM>yes</EM> に設定されていると、メッセイジ本文の編集後に
ファイルへの変更がなければ作成を自動終了する (このチェックは
そのファイルの<EM>最初の</EM>編集後にのみ発生する)。
<EM>no</EM> に設定されていると、どんなときも作成が中止されない。
<P>
<P>
<H3><A NAME="alias_file"></A> alias_file</H3>

<P>Type: path<BR>
Default: &quot;~/.muttrc&quot;
<P>
<P>
<A HREF="#create-alias">create-alias</A> 関数で作成された
エイリアスを保存する既定ファイル。
<P><B>注意:</B> Mutt は自動でこのファイルを source するわけではない。
明示的に 
<A HREF="#source">source</A> コマンドを使用して
実行しなくてはならない。(訳注：このファイルには alias コマンドが
羅列してあるだけだから「実行」するのである)
<P>
<P>
<H3><A NAME="alias_format"></A> alias_format</H3>

<P>Type: string<BR>
Default: &quot;%4n %2f %t %-10a   %r&quot;
<P>
<P>エイリアスメニューに表示されるデイタの書式を指定する。
次の printf(3) 式のシークウェンスが利用できる。
<P>
<P>
<DL>
<DT><B>%a </B><DD><P>エイリアス名
<DT><B>%f </B><DD><P>フラグ - 現時点では、削除予定のエイリアスに &quot;d&quot; が付くだけ
<DT><B>%n </B><DD><P>インデックス番号
<DT><B>%r </B><DD><P>展開後のアドレス
<DT><B>%t </B><DD><P>使用するためにタグ付けされていることを表す文字
</DL>
<P>
<P>
<H3><A NAME="allow_8bit"></A> allow_8bit</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>メイル送信時に Quoted-Printable か Base64 を使って
8 ビットデイタを 7 ビットに変換するかどうかを制御する。
<P>
<P>
<H3><A NAME="allow_ansi"></A> allow_ansi</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>メッセイジ中の ANSI 色コウド (と、リッチテキストメッセイジの色タグ)
を解釈するかどうかを制御する。こうしたコウドを含むメッセイジは稀だが、
このオプションが設定されていれば、相応に着色される。
注意すべきなのは、自分の色選択を上書きしかねないという点や、
セキュリティ上の問題さえ引き起こしかねないという点である。
というのは、メッセイジに添付ファイルの色で
&quot;[-- PGP output follows ...&quot;
という行を含めてあるかもしれないからだ。
<P>
<P>
<H3><A NAME="arrow_cursor"></A> arrow_cursor</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されているときには、行全体の反転ではなく矢印 (&quot;-&gt;&quot;)
を使って、メニューにおける現在位置を示す。これを使えば、
遅いネットワークやモデム接続で反応を早くすることができる。
なぜなら、メニューで前後の項目へ動く際に
画面上で再描画しなければならない部分が少ないからだ。
<P>
<P>
<H3><A NAME="ascii_chars"></A> ascii_chars</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、スレッドや添付ファイルの枝分かれを表示する際に、
既定の <EM>ACS</EM> 文字ではなくプレイン ASCII 文字を使う。
<P>
<P>
<H3><A NAME="askbcc"></A> askbcc</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、送信メッセイジ編集前にブラインドカーボンコピー
(Bcc) の宛先を入力するよう Mutt が促してくる。
<P>
<P>
<H3><A NAME="askcc"></A> askcc</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、Mutt は送信メッセイジの編集前にカーボンコピー
(Cc) の宛先を尋ねてくる。
<P>
<P>
<H3><A NAME="attach_format"></A> attach_format</H3>

<P>Type: string<BR>
Default: &quot;%u%D%I %t%4n %T%.40d%&gt; [%.7m/%.10M, %.6e%?C?, %C?, %s] &quot;
<P>
<P>この変数は添付ファイルメニューの書式を記述する。
下記の printf 式シークウェンスが理解できる。
<P>
<P>
<DL>
<DT><B>%C  </B><DD><P>文字セット
<DT><B>%c  </B><DD><P>文字セット変換の必要性 (n=無変換, c=変換)
<DT><B>%D  </B><DD><P>削除予定フラグ
<DT><B>%d  </B><DD><P>内容説明
<DT><B>%e  </B><DD><P>MIME content-transfer-encoding (通信時の符号化方法)
<DT><B>%f  </B><DD><P>ファイル名
<DT><B>%I  </B><DD><P>disposition (I=inline, A=attachment)
<DT><B>%m  </B><DD><P>メジャー MIME タイプ
<DT><B>%M  </B><DD><P>MIME サブタイプ
<DT><B>%n  </B><DD><P>添付ファイル番号
<DT><B>%s  </B><DD><P>サイズ
<DT><B>%t  </B><DD><P>タグフラグ
<DT><B>%T  </B><DD><P>視覚的な枝分かれ文字
<DT><B>%u  </B><DD><P>アンリンク (=送信後削除) フラグ
<DT><B>%&gt;X </B><DD><P>以降の文字列を右寄せし、余白を &quot;X&quot; で詰める
<DT><B>%|X </B><DD><P>行の末尾まで、文字 &quot;X&quot; で詰める
</DL>
<P>
<P>
<H3><A NAME="attach_sep"></A> attach_sep</H3>

<P>Type: string<BR>
Default: &quot;\n&quot;
<P>
<P>複数のタグ付き添付ファイルを処理 (保存、印刷、パイプ等々)
する際に、各添付ファイルの間に付ける区切り。
<P>
<P>
<H3><A NAME="attach_split"></A> attach_split</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>この変数が設定されていないと、複数のタグ付き添付ファイルを処理
(保存、印刷、パイプ等々) するときに Mutt が添付ファイルを連結して
一つのファイルのように扱うことになる。その際
<A HREF="#attach_sep">$attach_sep</A>
が各ファイルの後に追加される。なお、この変数が設定されているときには
添付ファイルを一つずつ別々に処理する。
<P>
<P>
<H3><A NAME="attribution"></A> attribution</H3>

<P>Type: string<BR>
Default: &quot;On %d, %n wrote:&quot;
<P>
<P>これは、返信で引用されるメッセイジの前に付く文字列である。
定義されている printf() 風シークウェンスの完全な一覧は
<A HREF="#index_format">$index_format</A>
の節を見よ。
<P>
<P>
<H3><A NAME="autoedit"></A> autoedit</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>これと 
<A HREF="#edit_headers">$edit_headers</A>
が設定されていると、Mutt は最初の送信メニューを飛ばして、
即座にメッセイジ本文を編集し始めさせてくれる。
送信メニューには、後でメッセイジ本文を編集し終えてから行くことができる。
<P>
<A HREF="#fast_reply">$fast_reply</A> も参照のこと。
<P>
<P>
<H3><A NAME="auto_tag"></A> auto_tag</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されているときに <EM>インデックス</EM> メニューから
メッセイジに影響を与える関数を実行すると、その関数は
タグ付けされたメッセイジすべて (もしあれば) に適用される。
(訳注：もしタグがなければ、カーソル位置のメッセイジに適用されるので注意。
<A HREF="#tags">「タグを使う」の説明</A>を参照。)
設定されていないときは、まず tag-prefix 関数 (既定値: &quot;;&quot;)
を使って、次の関数をタグ付きメッセイジに適用するようにしなくてはならない。
<P>
<P>
<H3><A NAME="beep"></A> beep</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>この変数が設定されているときにはエラー発生時に Mutt が音を鳴らす。
<P>
<P>
<H3><A NAME="beep_new"></A> beep_new</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数が設定されているとき、Mutt は新着メイルを知らせるメッセイジを
表示するたびに音を鳴らす。これは 
<A HREF="#beep">$beep</A>
変数の設定とは無関係である。
<P>
<P>
<H3><A NAME="bounce"></A> bounce</H3>

<P>Type: quadoption<BR>
Default: ask-yes
<P>
<P>メッセイジ中継で確認のための質問をするかどうかを制御する。
<EM>yes</EM> に設定してあると、本当に中継するかどうかを質問されない。
この変数を <EM>no</EM> にすることは一般的に無益であり、推奨できない。
なぜならメッセイジを中継できなくなってしまうからだ。
<P>
<P>
<H3><A NAME="bounce_delivered"></A> bounce_delivered</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>この変数が設定されているときにはメッセイジ中継の際に
Mutt が Delivered-To ヘッダを付けてくれる。
Postfix ユーザはこの変数を解除したいと思うだろう。
<P>
<P>
<H3><A NAME="charset"></A> charset</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>テキストデイタを端末で表示したり入力したりするのに使う文字セット。
<P>
<P>
<H3><A NAME="check_new"></A> check_new</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P><B>注意:</B> このオプションが有効なのは <EM>Maildir</EM> と <EM>MH</EM>
形式メイルボックスだけである。
<P><EM>yes</EM> のときは、開いている最中のメイルボックスに着信する
新着メイルを調べる。特に MH メイルボックスについて言えることだが、
この調査はかなり時間のかかることがある。というのも、ディレクトリ全体を
走査して、各ファイルを既に見たものかどうか確認する必要があるからだ。
もし <EM>check_new</EM> が <EM>no</EM> なら、
開いているメイルボックスには新着メイルの確認を行わない。
<P>
<P>
<H3><A NAME="collapse_unread"></A> collapse_unread</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P><EM>no</EM> のときは、未読メッセイジが含まれるスレッドを折り畳まない。
<P>
<P>
<H3><A NAME="uncollapse_jump"></A> uncollapse_jump</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P><EM>yes</EM> のときは、カーソル下の折り畳まれて<EM>いた</EM>スレッドが
<EM>広げられる</EM>際、未読メッセイジがあればそこにカーソルを移す。
<P>
<P>
<H3><A NAME="compose_format"></A> compose_format</H3>

<P>Type: string<BR>
Default: &quot;-- Mutt: Compose  [Approx. msg size: %l   Atts: %a]%&gt;-&quot;
<P>
<P>コンポウズメニューで表示されるステイタス行の書式を制御する。
この文字列は 
<A HREF="#status_format">$status_format</A>
とほぼ同じだが、独自の printf() 風シークウェンスを持っている。
<P>
<P>
<DL>
<DT><B>%a </B><DD><P>添付ファイルの総数
<DT><B>%h </B><DD><P>ロウカルのホスト名
<DT><B>%l </B><DD><P>メッセイジのおおよそのサイズ (バイト単位)
<DT><B>%v </B><DD><P>Mutt ヴァージョン文字列
</DL>
<P>
<P>
<A HREF="#compose_format">$compose_format</A>
の設定法に関してさらに情報を得るには、
<A HREF="#status_format">$status_format</A>
オプションの説明文を見よ。
<P>
<P>
<H3><A NAME="config_charset"></A> config_charset</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>定義されていると、設定ファイルのコマンドをこの符号化方式から
(訳注：
<A HREF="#charset">$charset</A> へ) 復号する。
<P>
<P>
<H3><A NAME="confirmappend"></A> confirmappend</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると、
Mutt がメッセイジを既存メイルボックスに追加するときに確認を促す。
<P>
<P>
<H3><A NAME="confirmcreate"></A> confirmcreate</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると、存在しないメイルボックスにメッセイジを保存する際、
メイルボックスを作成する前に確認を促す。
<P>
<P>
<H3><A NAME="connect_timeout"></A> connect_timeout</H3>

<P>Type: number<BR>
Default: 30
<P>
<P>この秒数でネットワーク接続 (IMAP と POP) が確立できなければ
Mutt は時間切れとして諦める。
負の数だと、接続が成功するまで永遠に待ち続ける。
<P>
<P>
<H3><A NAME="content_type"></A> content_type</H3>

<P>Type: string<BR>
Default: &quot;text/plain&quot;
<P>
<P>新規作成メッセイジ本文における既定の Content-Type を設定する。
<P>
<P>
<H3><A NAME="copy"></A> copy</H3>

<P>Type: quadoption<BR>
Default: yes
<P>
<P>この変数は、送信メッセイジのコピーを
後で参照するために保存しておくかどうかを制御する。
<A HREF="#record">$record</A>,
<A HREF="#save_name">$save_name</A>,
<A HREF="#force_name">$force_name</A>,
<A HREF="#fcc-hook">fcc-hook</A> も参照。
<P>
<P>
<H3><A NAME="crypt_use_gpgme"></A> crypt_use_gpgme</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>GPGME を使った暗号バックエンドの使用を制御する。
これが設定されていて、かつ Mutt が gpgme サポートありで構築されていると、
S/MIME と PGP に旧式コウドではなく gpgme コウドが用いられる。
注意が一つ。このオプションは .muttrc で使う必要があり、
実行中に使ってもまったく効果がない。
<P>
<P>
<H3><A NAME="crypt_autopgp"></A> crypt_autopgp</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>この変数は、Mutt がメッセイジに自動で PGP 暗号化/署名を有効にしても
良いかどうかを制御する。
<A HREF="#crypt_autoencrypt">$crypt_autoencrypt</A>,
<A HREF="#crypt_replyencrypt">$crypt_replyencrypt</A>,
<A HREF="#crypt_autosign">$crypt_autosign</A>,
<A HREF="#crypt_replysign">$crypt_replysign</A>,
<A HREF="#smime_is_default">$smime_is_default</A>
も見よ。
<P>
<P>
<H3><A NAME="crypt_autosmime"></A> crypt_autosmime</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>この変数は、自動的な S/MIME 暗号化/署名を有効にするかどうかを制御する。
<A HREF="#crypt_autoencrypt">$crypt_autoencrypt</A>,
<A HREF="#crypt_replyencrypt">$crypt_replyencrypt</A>,
<A HREF="#crypt_autosign">$crypt_autosign</A>,
<A HREF="#crypt_replysign">$crypt_replysign</A>,
<A HREF="#smime_is_default">$smime_is_default</A>
も見よ。
<P>
<P>
<H3><A NAME="date_format"></A> date_format</H3>

<P>Type: string<BR>
Default: &quot;!%a, %b %d, %Y at %I:%M:%S%p %Z&quot;
<P>
<P>この変数は 
<A HREF="#index_format">$index_format</A> 中の
&quot;%d&quot; シークウェンスによって表示される日付の書式を制御する。
これを <EM>strftime</EM> コールに渡して日付を処理する。
正しい文法については <EM>strftime(3)</EM> の man ペイジを参照されたい。
<P>文字列の最初の一字がびっくりマーク (&quot;!&quot;) でない限り、
月の名前や曜日の名前は変数 
<A HREF="#locale">$locale</A>
で指定されているロカールに従って展開される。もし最初がびっくりマークなら、
そのマーク自体は捨てられ、残りの文字列にある月や曜日名が <EM>C</EM>
ロカール (つまり合衆国英語 en_US) で展開される。
<P>
<P>
<H3><A NAME="default_hook"></A> default_hook</H3>

<P>Type: string<BR>
Default: &quot;~f %s !~P | (~P ~C %s)&quot;
<P>
<P>send-hook, message-hook, save-hook, fcc-hook に
合致パターンではなく単なる正規表現だけ指定されたときに
どう解釈するかを制御する。
これらのフックは宣言された時点で展開されるため、
フックの解釈は宣言の時点でこの変数がとっていた値に従うことになる。
既定値が合致するのは、メッセイジの差出人が正規表現に合致するか、
または差出人が自分 (From のアドレスが &quot;alternates&quot;
に合致する) で To か Cc の宛先が正規表現に合致する場合である。
<P>
<P>
<H3><A NAME="delete"></A> delete</H3>

<P>Type: quadoption<BR>
Default: ask-yes
<P>
<P>メイルボックスを閉じたり同期したりするときに
メッセイジを本当に削除するかどうかを制御する。
<EM>yes</EM> に設定されていると、削除予定の印を付けたメッセイジは
自動的に、確認を求めることなく消去される。
<EM>no</EM> に設定されていると、削除予定のメッセイジが
メイルボックスにそのまま残ることになる。
(訳注：quadoption すなわち四択オプションであるから、
ask-yes や ask-no にして毎回確認するようにもできる。)
<P>
<P>
<H3><A NAME="delete_untag"></A> delete_untag</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>このオプションが <EM>yes</EM> だと、Mutt はメッセイジへ削除の印を付ける際に
そのメッセイジのタグを外す。これはメッセイジを明示的に削除するときにも
適用されるし、セイヴして別のフォルダへ移動するときにも適用される。
(訳注：セイヴされたメッセイジは移動先のフォルダに即座に現れるが、
元のフォルダから即座に消え去るわけではない。
通常の削除と同様、削除マークが付くだけなのである。)
<P>
<P>
<H3><A NAME="digest_collapse"></A> digest_collapse</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>受信添付ファイルメニューでは、このオプションが <EM>yes</EM> なら、
multipart/digest の中の各メッセイジについて副パートを表示しない。
副パートを見るには &quot;v&quot; を押す必要がある。
<P>
<P>
<H3><A NAME="display_filter"></A> display_filter</H3>

<P>Type: path<BR>
Default: &quot;&quot;
<P>
<P>設定されているときには、この変数で指定されたコマンドを使ってメッセイジを
フィルタする。メッセイジは閲覧時に標準入力として
<A HREF="#display_filter">$display_filter</A>
に渡され、そのフィルタされたメッセイジが標準出力から読み出される。
<P>
<P>
<H3><A NAME="dotlock_program"></A> dotlock_program</H3>

<P>Type: path<BR>
Default: &quot;/usr/local/bin/mutt_dotlock&quot;
<P>
<P>Mutt が使用する mutt_dotlock (8) バイナリのパス。
<P>
<P>
<H3><A NAME="dsn_notify"></A> dsn_notify</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P><B>注意:</B> Sendmail 8.8.x 以降を使っていないなら有効にすべきではない。
<P>この変数には、どんなときに通知が返ってくるよう要求するかを設定する。
文字列の中身はコンマ区切り (スペイスを入れないこと!) のリストで、
この中から選べる: <EM>never</EM> は通知を一切要求しない、
<EM>failure</EM> は伝達失敗の通知を要求する、
<EM>delay</EM> はメッセイジの遅延を通知させる、
<EM>success</EM> は伝達成功を通知させるという意味である。
<P>例: set dsn_notify=&quot;failure,delay&quot;
<P>
<P>
<H3><A NAME="dsn_return"></A> dsn_return</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P><B>注意:</B> Sendmail 8.8.x 以降を使っているのでない限り、
この変数を有効にすべきではない。
<P>この変数は、メッセイジがどれだけ DSN メッセイジで返ってくるかを制御する。
<EM>hdrs</EM> にしてメッセイジヘッダのみ返ってくるようにするか、
<EM>full</EM> でメッセイジ全体が返ってくるようにするかのいずれかである。
<P>例: set dsn_return=hdrs
<P>
<P>
<H3><A NAME="duplicate_threads"></A> duplicate_threads</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>この変数で制御するのは、Mutt がスレッドで整列しているときに、
同一の message-id を持つメッセイジをスレッドにするかどうかである。
もし設定されていると、そうしたメッセイジを重複だと考えていることを示す等号を
スレッド図に表示する。
<P>
<P>
<H3><A NAME="edit_headers"></A> edit_headers</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>このオプションは、送信メッセイジのヘッダを
本文と一緒に編集できるようにしてくれる。
<P>
<P>
<H3><A NAME="editor"></A> editor</H3>

<P>Type: path<BR>
Default: &quot;&quot;
<P>
<P>Mutt が使うエディタを指定する。
指定しないと、VISUAL あるいは EDITOR 環境変数の値になる。
どれも設定されていなければ &quot;vi&quot; という文字列になる。
<P>
<P>
<H3><A NAME="encode_from"></A> encode_from</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P><EM>yes</EM> のときは、&quot;From &quot; という文字列を行頭に含む
メッセイジを Mutt が quoted-printable に符号化する。
これは、一部の MDA や MTA がメッセイジに行なおうとする不法改変を
避けるのに役立つ。
<P>
<P>
<H3><A NAME="envelope_from"></A> envelope_from</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P><EM>yes</EM> になっているとき、Mutt はメッセイジの
<EM>エンヴェロウプ</EM>送信者を
&quot;From:&quot; ヘッダに基づいて設定しようとする。
この情報が sendmail コマンドに &quot;-f&quot; スウィッチを使って渡される
ということに注意せよ。このため、そのスウィッチを自分で
<A HREF="#sendmail">$sendmail</A> の中に使っている場合や、
マシンの sendmail がこのコマンドラインスウィッチを
サポートしていない場合には、このオプションを設定してはならない。
<P>
<P>
<H3><A NAME="escape"></A> escape</H3>

<P>Type: string<BR>
Default: &quot;~&quot;
<P>
<P>内蔵エディタの各種機能を使うためのエスケイプ文字。
<P>
<P>
<H3><A NAME="fast_reply"></A> fast_reply</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、メッセイジへ返信する際、最初に宛先と題名を入力するのを省く。
転送する際にも題名の入力を省く。
<P><B>メモ:</B> 
<A HREF="#autoedit">$autoedit</A>
が設定されているときには、この変数は意味がない。
<P>
<P>
<H3><A NAME="fcc_attach"></A> fcc_attach</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>この変数は、送信メッセイジの添付ファイルを
本文と共に保存しておくかどうかを制御する。
<P>
<P>
<H3><A NAME="fcc_clear"></A> fcc_clear</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数が設定されているときは、実際のメッセイジが暗号化されたり署名されたり
していても、FCC は暗号化も署名もされずに保管される。(PGP のみ)
<P>
<P>
<H3><A NAME="folder"></A> folder</H3>

<P>Type: path<BR>
Default: &quot;~/Mail&quot;
<P>
<P>メイルボックスの既定位置を指定する。
先頭に &quot;+&quot; や &quot;=&quot; が付いているパスは、
その部分がこの変数の値に展開される。ただし注意点がある。
この変数を既定値から変更するなら、&quot;+&quot; や &quot;=&quot;
を何かの変数に使う<EM>前に</EM>その変更が起こるようにしなくてはならない。
なぜなら展開が生じるのは (訳注：変数の使用時ではなく)
&quot;set&quot; コマンドの実行中だからである。
<P>
<P>
<H3><A NAME="folder_format"></A> folder_format</H3>

<P>Type: string<BR>
Default: &quot;%2C %t %N %F %2l %-8.8u %-8.8g %8s %d %f&quot;
<P>
<P>この変数を使って、ファイルブラウザの表示を自分好みの味わいへと
カスタマイズすることができる。文字列の内容は
<A HREF="#index_format">$index_format</A>
に似ているが、以下に示す独自の printf() 風シークウェンスがある。
<P>
<P>
<DL>
<DT><B>%C  </B><DD><P>ファイル番号
<DT><B>%d  </B><DD><P>フォルダが最後に変更された日付/時刻
<DT><B>%f  </B><DD><P>ファイル名
<DT><B>%F  </B><DD><P>許可属性
<DT><B>%g  </B><DD><P>グループ名 (なければ gid 番号)
<DT><B>%l  </B><DD><P>ハードリンクの数
<DT><B>%N  </B><DD><P>新着メイルがあれば N で、なければ空白
<DT><B>%s  </B><DD><P>バイト数
<DT><B>%t  </B><DD><P>タグ付けられていれば * で、それ以外は空白
<DT><B>%u  </B><DD><P>所有者名 (なければ uid 番号)
<DT><B>%&gt;X </B><DD><P>残りの文字列を右寄せして、間を &quot;X&quot; で詰める
<DT><B>%|X </B><DD><P>行末まで &quot;X&quot; で詰める
</DL>
<P>
<P>
<H3><A NAME="followup_to"></A> followup_to</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>メイル送信時に <EM>Mail-Followup-To</EM> ヘッダフィールドを
生成するかどうかを制御する。<EM>yes</EM> だと、
既知のメイリングリストに返信する際には Mutt がこのフィールドを生成する。
既知というのは subscribe コマンドか 
<A HREF="#lists">lists</A> コマンドで
指定されているということである。
<P>このフィールドには目的が二つある。第一に、メイリングリストに
送ったメッセイジに対して、同じ返信を重複して受け取るのを避けることだ。
そして第二に、購読していない既知のリストに送ったメッセイジへの返信を
個別に受け取れるようにすることである。ヘッダの中には、
購読しているリストに送るときはリストのアドレスだけが含まれ、
未購読のリストにはリストのアドレスと自分のメイルアドレスの両方が含まれる。
このヘッダを付けないで購読中のリストに送信すると、
そのメッセイジに対するグループ返信が
リストにも自分個人のアドレスにも送られるため、
結果として同じメイルが二通送られてくることになるのだ。
<P>
<P>
<H3><A NAME="force_name"></A> force_name</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数は 
<A HREF="#save_name">$save_name</A>
とほとんど同じだが、宛先アドレスのユーザ名と同じメイルボックスに
送信メッセイジのコピーを保管しようとする際、そのメイルボックスが
存在していなくても (訳注：新規作成して) そこに保管するという点だけが異なる。
<P>
<A HREF="#record">$record</A> 変数も参照せよ。
<P>
<P>
<H3><A NAME="forward_decode"></A> forward_decode</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>複雑な MIME メッセイジを転送時に text/plain へ復号化するかどうかを制御する。
(訳注：yes のときは) メッセイジヘッダも RFC2047 復号化される。
この変数が使われるのは
<A HREF="#mime_forward">$mime_forward</A>
が <EM>no</EM> のときだけであり、<EM>yes</EM> のときには
<A HREF="#mime_forward_decode">$mime_forward_decode</A>
が使われる。
<P>
<P>
<H3><A NAME="forward_edit"></A> forward_edit</H3>

<P>Type: quadoption<BR>
Default: yes
<P>
<P>この quadoption (四択オプション) は、メッセイジ転送時にユーザが
自動でエディタに行かされるかどうかを制御する。
常に無変更で転送したいという人は &quot;no&quot; に設定すれば良い。
<P>
<P>
<H3><A NAME="forward_format"></A> forward_format</H3>

<P>Type: string<BR>
Default: &quot;[%a: %s]&quot;
<P>
<P>この変数はメッセイジを転送するときの題名の既定値を制御する。
<A HREF="#index_format">$index_format</A>
変数と同じ書式シークウェンスを使う。
<P>
<P>
<H3><A NAME="forward_quote"></A> forward_quote</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P><EM>yes</EM> のとき、メッセイジ本文中に取り込まれた転送メッセイジは
(
<A HREF="#mime_forward">$mime_forward</A> が
<EM>no</EM> のときには)
<A HREF="#indent_string">$indent_string</A>
を使って引用される。
<P>
<P>
<H3><A NAME="from"></A> from</H3>

<P>Type: e-mail address<BR>
Default: &quot;&quot;
<P>
<P>設定されていると、この変数の中身が既定の From アドレスになる。
これは my_hdr (send-hook からでも使える) や
<A HREF="#reverse_name">$reverse_name</A>
を使って上書きすることができる。
なお、この変数は 
<A HREF="#use_from">$use_from</A>
が設定されていないと無視される。
<P>設定されていないときは環境変数 EMAIL の内容が使われる。
<P>
<P>
<H3><A NAME="gecos_mask"></A> gecos_mask</H3>

<P>Type: regular expression<BR>
Default: &quot;^[^,]*&quot;
<P>
<P>Mutt がエイリアスを展開する際にパスワード項目の GECOS フィールド
(訳注：getent passwd の出力で五番目のフィールド) を読み取るための正規表現。
既定値の正規表現は &quot;^[^,]*&quot; に設定されており、
これは最初に &quot;,&quot; に当たるまでの部分の文字列を返すことになる。
もし GECOS フィールドに &quot;姓, 名&quot; のような文字列が含まれているなら
gecos_mask=&quot;.*&quot; と設定すべきである。
<P>次のような動作に有効である。メイルを stevef というユーザ ID の人に
送るとする。その人の本名は Steve Franklin である。Mutt が stevef
を &quot;Franklin&quot; stevef@foo.bar というように展開してしまう。
この場合は、gecos_mask を名前全体に合致するような正規表現に設定して、
Mutt が &quot;Franklin&quot; から &quot;Franklin, Steve&quot;
へと視野を広げられるようにすべきなのだ。
<P>
<P>
<H3><A NAME="hdrs"></A> hdrs</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていないときには、通常だと追加される
<A HREF="#my_hdr">my_hdr</A> コマンドのヘッダフィールドが
作成されない。この変数の効果を発揮するには、<EM>必ず</EM>その
新規メッセイジの作成や返信の<EM>前に</EM>解除しなくてはならない。
設定されているときにはユーザ定義ヘッダフィールドが
すべての新メッセイジに追加される。
<P>
<P>
<H3><A NAME="header"></A> header</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されているときには、返信元メッセイジのヘッダを
Mutt が編集バッファに取り込むようになる。
<A HREF="#weed">$weed</A> の設定が適用される。
<P>
<P>
<H3><A NAME="header_cache"></A> header_cache</H3>

<P>Type: path<BR>
Default: &quot;&quot;
<P>
<P>header_cache 変数はヘッダキャッシュのデイタベイスを指し示す。
もしディレクトリを指していれば、メイルフォルダ一つにつき
デイタベイス一つが作成される。ディレクトリを指していない場合には
すべてのフォルダに対する単一のキャッシュが用いられる。
既定では設定されていないので、ヘッダキャッシュが使われない。
<P>
<P>
<H3><A NAME="header_cache_pagesize"></A> header_cache_pagesize</H3>

<P>Type: string<BR>
Default: &quot;16384&quot;
<P>
<P>ヘッダキャッシュデイタベイスのペイジサイズを変更する。
大きすぎたり小さすぎたりすると、容量やメモリや CPU
を無駄に使ってしまうことがある。既定値がほぼ最善のはずだ。
詳細については &quot;mutt header cache&quot; で google
検索すること (最初に出てくるサイト)。
<P>
<P>
<H3><A NAME="help"></A> help</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると、各メニューに備わる主な機能のキー割り当て
を説明するヘルプが画面の一行目に表示される。
<P><B>メモ:</B> 操作キーが正しく表示されないことがある。これは関数が
一つのキー押下だけでなく一連の操作に割り当てられている場合だ。
さらに、Mutt 実行中に割り当てが変更されてもヘルプ行は更新されないことがある。
ただ、この変数は基本的に新しいユーザのためにあるので、
どちらもさほど大きな問題とはならないはずだ。
<P>
<P>
<H3><A NAME="hidden_host"></A> hidden_host</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されているときには、Mutt がアドレスにドメイン部分を付ける際、
<A HREF="#hostname">$hostname</A> 変数のホスト名部分を抜く。
この変数は Message-ID の生成に影響しないし、
最上位ドメインまで切除してしまうようなことにもならない。
<P>
<P>
<H3><A NAME="hide_limited"></A> hide_limited</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、スレッド分岐図の中で、
limit (表示制限) によって隠れているメッセイジのある場所を
Mutt が指示しなくなる。
<P>
<P>
<H3><A NAME="hide_missing"></A> hide_missing</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると、スレッド分岐図に欠けているメッセイジの存在を示さなくなる。
<P>
<P>
<H3><A NAME="hide_top_limited"></A> hide_top_limited</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、limit (表示制限) で隠れているメッセイジがあることを
スレッド頂点で示さなくなる。
<A HREF="#hide_missing">$hide_missing</A>
が設定されていると、このオプションがどうなっても効果がないので、
覚えておくように。
<P>
<P>
<H3><A NAME="hide_top_missing"></A> hide_top_missing</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されているとき、スレッド頂点では
メッセイジが欠けているという表示をしなくなる。
ただ、
<A HREF="#hide_limited">$hide_limited</A>
が設定されているときにはこのオプションの効果がないということに注意せよ。
<P>
<P>
<H3><A NAME="history"></A> history</H3>

<P>Type: number<BR>
Default: 10
<P>
<P>この変数は文字列履歴バッファのサイズ (記憶する文字列の数 [訳注：字数ではない])
を制御する。このバッファは、変数が設定されるたびに消去される。
<P>
<P>
<H3><A NAME="honor_followup_to"></A> honor_followup_to</H3>

<P>Type: quadoption<BR>
Default: yes
<P>
<P>この変数は、メッセイジへグループ返信する際に
Mail-Followup-To ヘッダを尊重するかどうかを制御する。
<P>
<P>
<H3><A NAME="hostname"></A> hostname</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>ロウカルメイルアドレスの &quot;@&quot; の後に付けるホスト名を指定する。
これはコンパイル時に /etc/resolv.conf から取得した定義を上書きする。
<P>
<P>
<H3><A NAME="ignore_list_reply_to"></A> ignore_list_reply_to</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>これはメイリングリストからのメッセイジに返信する際の <EM>reply</EM>
関数の動作に影響する。設定されているとき、&quot;Reply-To:&quot;
フィールドが &quot;To:&quot; フィールドと同じ値に設定されていると、
Mutt は &quot;Reply-To:&quot; フィールドがメイリングリストによって
(返事を自動でメイリングリストに送らせるため) 設定されたものとみなして、
そのフィールドを無視する。このオプションが設定されているときに返事を
メイリングリストに向かわせるには <EM>list-reply</EM> を使う。また、
<EM>group-reply</EM> は差出人とリストの両方に返信する。
<P>
<P>
<H3><A NAME="imap_authenticators"></A> imap_authenticators</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>これはコロン区切りによる認証方式の一覧で、Mutt はこれらの方式を使って
IMAP サーバにログインしようとする。並びは Mutt が試行する順になっている。
認証方式には、'login' か IMAP の能力文字列 'AUTH=xxx' の右辺を使う
(例えば 'digest-md5', 'gssapi', 'cram-md5')。このパラメータは大文字と
小文字を区別しない。なおパラメータが未設定 (既定) のときには、Mutt
は利用できる方式をすべて、最も安全な方式から最も安全でない方式の順番に
試行する。
<P>例: set imap_authenticators=&quot;gssapi:cram-md5:login&quot;
<P><B>注記:</B> Mutt が他の認証方式へ移るのは方式が利用できない場合のみ
である。方式が利用できるが認証に失敗したというときには IMAP サーバに
接続しないことになる。
<P>
<P>
<H3><A NAME="imap_delim_chars"></A> imap_delim_chars</H3>

<P>Type: string<BR>
Default: &quot;/.&quot;
<P>
<P>この中には、IMAP パスを表示する際にフォルダの区切りとして扱いたい
文字の一覧が入る。特にこれが役立つのは <EM>folder</EM> 変数
の内容を示すために &quot;=&quot; ショートカットを使うときである。
(訳注：つまり &quot;/.=&quot; のように設定するということか?)
<P>
<P>
<H3><A NAME="imap_force_ssl"></A> imap_force_ssl</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数が設定されていると、Mutt は常に SSL を使って IMAP
サーバに接続する。
<P>
<P>
<H3><A NAME="imap_headers"></A> imap_headers</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>Mutt が既定のヘッダ (&quot;DATE FROM SUBJECT TO CC MESSAGE-ID REFERENCES
CONTENT-TYPE CONTENT-DESCRIPTION IN-REPLY-TO REPLY-TO LINES LIST-POST
X-LABEL&quot;) に加えてさらに IMAP サーバへ要求するヘッダフィールド。
スパム検出のためのヘッダを追加したいときに使う。
<B>注意:</B> これはスペイス区切りのリストである。
<P>
<P>
<H3><A NAME="imap_home_namespace"></A> imap_home_namespace</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>通常、IMAP ブラウザにおいては、自分の個人用フォルダが INBOX の
すぐそばにあってほしいものだ。そのようになっていない場合、
この変数を自分のフォルダへの IMAP パスに設定することができる。
<P>
<P>
<H3><A NAME="imap_keepalive"></A> imap_keepalive</H3>

<P>Type: number<BR>
Default: 900
<P>
<P>この変数には Mutt が IMAP 接続の継続を主張するまで待つ最大秒数を指定する。
その主張をすることにより、Mutt が接続を使い終える前にサーバが
接続を閉じてしまうのを防ぐのである。既定値は、RFC 指定により
サーバ側が接続を閉じるまでに待たねばならない時間の最小値 (30 分) 内に
しっかりおさまっているが、実際はそこかしこで RFC が破られている。
接続を使用していないとみなされて IMAP サーバから切断されるようであれば、
この数値を減らすこと。
<P>
<P>
<H3><A NAME="imap_list_subscribed"></A> imap_list_subscribed</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数は、IMAP フォルダ閲覧で調べるのを購読フォルダのみにするか、
それともフォルダすべてにするかを制御する。これは IMAP ブラウザ内で
<EM>toggle-subscribed</EM> 関数を使って切り替えることもできる。
<P>
<P>
<H3><A NAME="imap_pass"></A> imap_pass</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>IMAP アカウントのパスワードを指定する。設定されていないと、Mutt は
fetch-mail 関数の実行時にパスワードを求めることになる。
<B>警告</B>: このオプションは十分に安全なマシン上でのみ
使うべきである。なぜなら、muttrc ファイルを自分以外が読めないように
したつもりでも、スーパユーザは読めるからだ。
<P>
<P>
<H3><A NAME="imap_passive"></A> imap_passive</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されているときには、新着メイル確認のために Mutt が新しく
IMAP 接続を開くことはない。Mutt は新着メイルを既存の IMAP
接続でのみ確認することになる。これが有用となるのは、Mutt
起動時にユーザ名とパスワードの入力を促されたくない場合や、
接続を開くのに時間がかかる場合などである。
<P>
<P>
<H3><A NAME="imap_peek"></A> imap_peek</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると Mutt は、サーバからメッセイジを取得しただけで
メイルが既読として印付けられてしまうことのないようにする。
これは一般的に良いことであるが、IMAP フォルダを閉じるのが
幾らか遅くなることがある。このオプションはスピード狂の人たちを
なだめるためにのみ存在しているのだ。
<P>
<P>
<H3><A NAME="imap_servernoise"></A> imap_servernoise</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されているときには、IMAP サーバからの警告メッセイジを
Mutt が表示するようになる。こうしたメッセイジはほとんど
無害なことに関するものであったり、サーバ側の設定ミスのために
ユーザからはどうしようもないものであったりすることが多いので、
抑止したいと思うこともあるだろう。
<P>
<P>
<H3><A NAME="imap_user"></A> imap_user</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>IMAP サーバへのログイン名。
<P>この変数の既定値はロウカルマシン上のユーザ名になる。
<P>
<P>
<H3><A NAME="implicit_autoview"></A> implicit_autoview</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>これが &quot;yes&quot; に設定されていると、copiousoutput
フラグの付いた mailcap 項目がないかどうかを、<EM>どんな種類の</EM>
添付ファイルに対して調査する。内部ヴューワが
(訳注：
<A HREF="#auto_view">auto_view</A> で) 定義されていなくてもだ。
そのように調査して項目が見つかったときには、
そこで定義されているヴューワを使って内容をテキスト形式へ変換する。
<P>
<P>
<H3><A NAME="include"></A> include</H3>

<P>Type: quadoption<BR>
Default: ask-yes
<P>
<P>返信しようとしている元のメッセイジ内容を
返信に含めるかどうかを制御する。
<P>
<P>
<H3><A NAME="include_onlyfirst"></A> include_onlyfirst</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>返信の際にメッセイジの最初の添付ファイルのみ引用するかどうかを制御する。
<P>
<P>
<H3><A NAME="indent_string"></A> indent_string</H3>

<P>Type: string<BR>
Default: &quot;&gt; &quot;
<P>
<P>指定した文字列を、相手のメッセイジから引用した文の
行頭に付ける。この値は、変更しないことが強く推奨されている。
変更すると、熱狂的なネット市民を激昂させてしまう傾向があるからだ。
<P>
<P>
<H3><A NAME="index_format"></A> index_format</H3>

<P>Type: string<BR>
Default: &quot;%4C %Z %{%b %d} %-15.15L (%?l?%4l&amp;%4c?) %s&quot;
<P>
<P>この変数によって、メッセイジインデックス画面を好み通りに
調整することができる。
<P>&quot;形式文字列&quot; は &quot;C&quot; の printf 関数で
出力形式を指示するために使う文字列と似ている (詳細は man を参照)。
Mutt では以下のシークウェンスが定義されている。
<P>
<P>
<DL>
<DT><B>%a </B><DD><P>差出人のアドレス
<DT><B>%A </B><DD><P>(もしあれば) reply-to アドレス (なければ差出人アドレス)
<DT><B>%b </B><DD><P>メッセイジフォルダのファイル名 (mailBox の b と考えよ)
(訳注：最後に &quot;/&quot; が付いているディレクトリだと何も表示されない。
((strrchr(path,'/'))+1) のポインタから strfcpy しているためである。)
<DT><B>%B </B><DD><P>宛てられたリスト、なければフォルダ名 (%b)
<DT><B>%c </B><DD><P>メッセイジのバイト数 (英文では文字 [characters] の数)
<DT><B>%C </B><DD><P>メッセイジ番号
<DT><B>%d </B><DD><P>日付と時刻を、送信者の現地時間に変換して
&quot;date_format&quot; の形式にしたもの
<DT><B>%D </B><DD><P>日付と時刻を、自分の地域の時間に変換して
&quot;date_format&quot; の形式にしたもの
<DT><B>%e </B><DD><P>スレッド内におけるメッセイジ番号
<DT><B>%E </B><DD><P>スレッド内のメッセイジ総数
<DT><B>%f </B><DD><P>From: 行の全体 (アドレスも本名も含む)
<DT><B>%F </B><DD><P>差出人の名前、自分からのメッセイジなら宛先の名前
(訳注：後者には To という文字列が前置される)
<DT><B>%H </B><DD><P>このメッセイジのスパム属性
<DT><B>%i </B><DD><P>Message-ID
<DT><B>%l </B><DD><P>行数 (Maildir と MH では使えないし、IMAP でもたぶん不可
[訳注：0 になる])
<DT><B>%L </B><DD><P>To または CC ヘッダフィールドが &quot;subscribe&quot;
コマンドで定義された正規表現に合致すると &quot;To &lt;list-name&gt;&quot;
(訳注：&quot;Cc &lt;list-name&gt;&quot; の場合もある) と表示する。
合致しなければ %F と同じ
<DT><B>%m </B><DD><P>メイルボックス内のメッセイジ総数
<DT><B>%M </B><DD><P>スレッドが折り畳まれているときの非表示メッセイジの数
<DT><B>%N </B><DD><P>得点
<DT><B>%n </B><DD><P>差出人の本名 (なければアドレス)
<DT><B>%O </B><DD><P>(オリジナルセイヴフォルダの O) むかし Mutt が
FCC として使っていたような場所:
リストアドレスの名前部分、なければ宛先アドレスの名前部分
(訳注：
<A HREF="#save_address">$save_address</A>
が設定されていれば @ 以降も含み、そうでなければ @ の前までのみ)
<DT><B>%s </B><DD><P>題名
<DT><B>%S </B><DD><P>メッセイジの状態 (N/D/d/!/r/*)
<DT><B>%t </B><DD><P>To: フィールド (宛先)
<DT><B>%T </B><DD><P>
<A HREF="#to_chars">$to_chars</A>
文字列中の適切な文字
<DT><B>%u </B><DD><P>送信者のユーザ (ログイン) 名
<DT><B>%v </B><DD><P>送信者 (自分が送信者なら宛先人) のファーストネイム
(訳注：日本人だと姓が先なので姓)
<DT><B>%y </B><DD><P>あれば X-Label: フィールド
<DT><B>%Y </B><DD><P>X-Label フィールドがあり、かつ
(1) スレッドトゥリーの一部ではない、(2) スレッドの頂点である、
(3) 前のメッセイジの X-Label と違う X-Label である、の
いずれかであれば X-Label フィールド
<DT><B>%Z </B><DD><P>3 桁の状態フラグ
<DT><B>%{fmt} </B><DD><P>日付と時刻が送信者の現地時間に変換され、
&quot;fmt&quot; がライブラリ関数 &quot;strftime&quot;
により展開される。最初にびっくりマークが付いていると
<A HREF="#locale">$locale</A> が無視される。
(訳注：%{!%b-%d(%a)} のように使う)
<DT><B>%(fmt) </B><DD><P>メッセイジが到着した日付と時刻のロウカル時間表示。
&quot;fmt&quot; はライブラリ関数 &quot;strftime&quot;
により展開され、最初にびっくりマークが付いていると
<A HREF="#locale">$locale</A> が無視される。
<DT><B>%&lt;fmt&gt; </B><DD><P>ロウカルの現在時刻。
&quot;fmt&quot; はライブラリ関数 &quot;strftime&quot;
により展開され、最初にびっくりマークが付いていると
<A HREF="#locale">$locale</A> が無視される。
<DT><B>%&gt;X    </B><DD><P>残りの文字列を右寄せして、間を
&quot;X&quot; 部分の文字で詰める (訳注：日本語文字は未対応)
<DT><B>%|X    </B><DD><P>行末まで &quot;X&quot; 部分の文字で詰める
</DL>
<P>
<P>参照: 
<A HREF="#to_chars">$to_chars</A><P>
<P>
<H3><A NAME="ispell"></A> ispell</H3>

<P>Type: path<BR>
Default: &quot;/usr/bin/ispell&quot;
<P>
<P>どう ispell (GNU スペルチェッカ) を起動するか。
<P>
<P>
<H3><A NAME="keep_flagged"></A> keep_flagged</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、フラグ付き既読メッセイジはスプールメイルボックスから
自分の 
<A HREF="#mbox">$mbox</A> メイルボックス
(または 
<A HREF="#mbox-hook">mbox-hook</A> コマンドの結果) に移さない。
<P>
<P>
<H3><A NAME="locale"></A> locale</H3>

<P>Type: string<BR>
Default: &quot;C&quot;
<P>
<P><EM>strftime(3)</EM> が日付などを整形するために使うロカール。
使うことのできる値は、システムがロカール変数 <EM>LC_TIME</EM>
として受け付ける文字列である。
<P>
<P>
<H3><A NAME="mail_check"></A> mail_check</H3>

<P>Type: number<BR>
Default: 5
<P>
<P>この値は、どれほどの頻度で (何秒に一度) Mutt が新着メイルを
確認するかを制御する。
<P>
<P>
<H3><A NAME="mailcap_path"></A> mailcap_path</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>この変数は、Mutt が直接サポートしていない MIME パートを
表示しようとする際に、どのファイルに問い合わせるかを指定する。
<P>
<P>
<H3><A NAME="mailcap_sanitize"></A> mailcap_sanitize</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると、Mutt は mailcap の %展開に現れる文字を制限して、
ちょうどよく定義された安全な文字に直す。これは安全な設定ではあるが、
これにより高度な MIME 項目が動かなくなることがないとは断言できない。
<P><B>DON'T CHANGE THIS SETTING UNLESS YOU ARE REALLY SURE WHAT YOU ARE
DOING!<BR>
この設定は、完全に理解することなく変更してはならない!</B>
<P>
<P>
<H3><A NAME="maildir_trash"></A> maildir_trash</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、削除予定に印付けられたメッセイジがその後、
削除されるのではなく Maildir の T フラグ (trashed) を付けて保存される。
<B>注意:</B> これは Maildir 形式のメイルボックスにのみ適用される。
他のメイルボックス形式にはまったく効果がない。
<P>
<P>
<H3><A NAME="mark_old"></A> mark_old</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P><EM>新着</EM>で<EM>未読の</EM>メッセイジを読まないまま
メイルボックスを出たときに、Mutt がそれに<EM>古い</EM>という印を
付けるかどうか制御する。このオプションが設定されていると、次回
Mutt を始めたときに、インデックスメニューでメッセイジの隣りに
&quot;O&quot; と表示される。それが古い (old) ということを示すのである。
<P>
<P>
<H3><A NAME="markers"></A> markers</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>内部ペイジャで折り返された行の表示を制御する。設定されていると、
&quot;+&quot; 印が行頭に付いて、折り返し行を表す。
<A HREF="#smart_wrap">$smart_wrap</A> 変数も見よ。
<P>
<P>
<H3><A NAME="mask"></A> mask</H3>

<P>Type: regular expression<BR>
Default: &quot;!^\.[^.]&quot;
<P>
<P>ファイルブラウザで使われる正規表現。
先頭に <EM>NOT</EM> 演算子 &quot;!&quot; を付けることができる。
ファイル名がこの条件に合致するもののみ表示されることになる。
合致条件は常に大文字と小文字を区別する。
<P>
<P>
<H3><A NAME="mbox"></A> mbox</H3>

<P>Type: path<BR>
Default: &quot;~/mbox&quot;
<P>
<P>これに指定したフォルダへ、
<A HREF="#spoolfile">$spoolfile</A>
フォルダの既読メイルを追加する。
<P>
<P>
<H3><A NAME="mbox_type"></A> mbox_type</H3>

<P>Type: folder magic<BR>
Default: mbox
<P>
<P>新しいフォルダを作るときに使う既定のメイルボックス形式。
mbox, MMDF, MH, Maildir のいずれでも良い。
<P>
<P>
<H3><A NAME="metoo"></A> metoo</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていないと、メッセイジへの返信時に宛先リストから自分のアドレス
(
<A HREF="#alternates">alternates</A> コマンドを参照) を除去する。
<P>
<P>
<H3><A NAME="menu_scroll"></A> menu_scroll</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>これが <EM>yes</EM> に設定されているときには、画面の端を
越えようとしたときにメニューが一行ずつスクロウルする。
<EM>no</EM> なら、画面全体が消去されて次のペイジまたは前のペイジが
表示される (こちらの方が、何度も再描画するのを避けられるので
遅い回線に有用である)。
<P>
<P>
<H3><A NAME="meta_key"></A> meta_key</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、高位ビット (8 ビット目) との組み合わせを持つ
キー押下を、ユーザが ESC キーを押してから別のキーを押したものと
判断するよう Mutt に強制する。ESC の後に押したキーは、高位ビットを
取り除いた後に残る部分である。例えば、押されたキーが 0xf4 という
ASCII 値を持っていると、これはユーザが ESC と &quot;x&quot; を
押したものとして扱われる。なぜなら &quot;0xf4&quot; から
高位ビットを除いた結果は &quot;0x74&quot; であり、これは
ASCII 文字の &quot;x&quot; だからである。
<P>
<P>
<H3><A NAME="mh_purge"></A> mh_purge</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていないときには、Mutt が mh の挙動を偽装する。
削除メッセイジを実際には削除せず、そのファイル名を
「<EM>,&lt;旧ファイル名&gt;</EM>」に変更するのである。
もし変数が設定されていれば、メッセイジファイルは単に消されてしまう。
<P>
<P>
<H3><A NAME="mh_seq_flagged"></A> mh_seq_flagged</H3>

<P>Type: string<BR>
Default: &quot;flagged&quot;
<P>
<P>フラグ付きメッセイジに使う MH シークウェンス名。
<P>
<P>
<H3><A NAME="mh_seq_replied"></A> mh_seq_replied</H3>

<P>Type: string<BR>
Default: &quot;replied&quot;
<P>
<P>返信済みメッセイジに使う MH シークウェンス名。
<P>
<P>
<H3><A NAME="mh_seq_unseen"></A> mh_seq_unseen</H3>

<P>Type: string<BR>
Default: &quot;unseen&quot;
<P>
<P>未見メッセイジに使う MH シークウェンス名。
<P>
<P>
<H3><A NAME="mime_forward"></A> mime_forward</H3>

<P>Type: quadoption<BR>
Default: no
<P>
<P>設定されているときには、転送するメッセイジが個別の MIME パートとして
添付される。メッセイジ本文に含めるのではないということだ。これは
MIME メッセイジの転送に便利である。こうすれば相手も、自分に届けられたのと
同じように正しくメッセイジを閲覧することができるのだ。
もしもメイルごとに MIME と非 MIME を選択したいのであれば、
この変数を ask-no か ask-yes に設定すること。
<P>
<A HREF="#forward_decode">$forward_decode</A> および
<A HREF="#mime_forward_decode">$mime_forward_decode</A>
も参照。
<P>
<P>
<H3><A NAME="mime_forward_decode"></A> mime_forward_decode</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>
<A HREF="#mime_forward">$mime_forward</A> が
<EM>yes</EM> のときには、入り組んだ MIME メッセイジを転送時に
text/plain へ復号するかどうかをこの変数が制御する。
<EM>no</EM> のときには
<A HREF="#forward_decode">$forward_decode</A>
が使われる。
<P>
<P>
<H3><A NAME="mime_forward_rest"></A> mime_forward_rest</H3>

<P>Type: quadoption<BR>
Default: yes
<P>
<P>MIME メッセイジの添付ファイルメニューからファイルを複数
(訳注：非 
<A HREF="#mime_forward">MIME</A> で) 転送するとき、
適切な復号方法のないファイルが転送メッセイジに添付されるのは、
このオプションが設定された場合のみである。
(訳注：yes の場合と、ask-yes または ask-no で y と答えた場合のこと。なお、
このオプションは 
<A HREF="#mime_forward">$mime_forward</A>
が解除されているときにのみ意味を持つ。非 MIME 転送をしようとしているときに、
MIME でしか転送できないファイルをあきらめる (no) か MIME で転送する (yes)
かの設定なのだ。転送ファイルが一つだけのときには、あきらめるはずがないと
みなされる。)
<P>
<P>
<H3><A NAME="mix_entry_format"></A> mix_entry_format</H3>

<P>Type: string<BR>
Default: &quot;%4n %c %-16s %a&quot;
<P>
<P>この変数で Mixmaster チェイン選択画面におけるリメイラ行の書式を記述する。
以下に挙げる printf風シークウェンスが使える。
<P>
<P>
<DL>
<DT><B>%n </B><DD><P>メニュー内での番号
<DT><B>%c </B><DD><P>リメイラの能力
<DT><B>%s </B><DD><P>リメイラの省略名
<DT><B>%a </B><DD><P>リメイラのメイルアドレス
</DL>
<P>
<P>
<H3><A NAME="mixmaster"></A> mixmaster</H3>

<P>Type: path<BR>
Default: &quot;mixmaster&quot;
<P>
<P>この変数には自分のシステムの Mixmaster バイナリへのパスを入れる。
これに種々のパラメータを付けて、既知のリメイラ一覧を収集する。
また、最終的にメッセイジを Mixmaster チェイン経由で送信する際にも使う。
<P>
<P>
<H3><A NAME="move"></A> move</H3>

<P>Type: quadoption<BR>
Default: ask-no
<P>
<P>スプールメイルボックスの既読メッセイジを
<A HREF="#mbox">$mbox</A> メイルボックスや
<A HREF="#mbox-hook">mbox-hook</A> コマンドの結果へ
移動するかどうかを制御する。
(訳注：原文は文字通りには「移動するかどうかを確認させるかどうかを制御する」
となっているが、yes にすれば確認なしで移動されるし、no にすれば
確認なしで移動もなしなのだから、原文直訳では不正確になってしまう。)
<P>
<P>
<H3><A NAME="message_format"></A> message_format</H3>

<P>Type: string<BR>
Default: &quot;%s&quot;
<P>
<P>「添付ファイル」メニューで message/rfc822 タイプのファイルの部分に
表示される文字列。定義されている printf()風シークウェンスの
完全な一覧表については
<A HREF="#index_format">$index_format</A>
の項を参照のこと。
<P>
<P>
<H3><A NAME="narrow_tree"></A> narrow_tree</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数が設定されていると、スレッドトゥリーを狭くして、
深いスレッドが画面に収まるようにする。
<P>
<P>
<H3><A NAME="pager"></A> pager</H3>

<P>Type: path<BR>
Default: &quot;builtin&quot;
<P>
<P>この変数にはメッセイジ閲覧に使いたいペイジャを指定する。
builtin は内蔵ペイジャを使うという意味になるが、
それ以外は外部ペイジャのパス名を指定すべきである。
<P>外部ペイジャを使うことには不便な点もある: まず、キーを多く押さなくては
ならない。ペイジャから直接 Mutt の関数を呼び出すことはできないからだ。
さらに、画面の大きさを変更すると、ヘルプメニューで画面の幅より長い行が
ひどいことになってしまう。
<P>
<P>
<H3><A NAME="pager_context"></A> pager_context</H3>

<P>Type: number<BR>
Default: 0
<P>
<P>この変数は、内部ペイジャで次のペイジや前のペイジを表示させる際に
文脈として残す行数を制御する。Mutt は既定では、現時点の画面で
一番下にある行の次からを次ペイジとして表示する (文脈は 0 行ということ)。
<P>
<P>
<H3><A NAME="pager_format"></A> pager_format</H3>

<P>Type: string<BR>
Default: &quot;-%Z- %C/%m: %-20.20n   %s&quot;
<P>
<P>この変数は一行メッセイジである「ステイタス」の形式を制御する。
これは内部ペイジャでも外部ペイジャでも各メッセイジの前に表示される
(訳注：ただし、外部ペイジャの場合には表示内容の前に付加されるが、
内部ペイジャの場合にはインデックスモウドにおけるステイタス行と
同じ位置に常に表示される)。
正しいシークウェンスは
<A HREF="#index_format">$index_format</A> の項で
一覧にされている。
<P>
<P>
<H3><A NAME="pager_index_lines"></A> pager_index_lines</H3>

<P>Type: number<BR>
Default: 0
<P>
<P>ペイジャにいるときに表示する小インデックスの行数を決定する。
ペイジャで表示中のメッセイジは、フォルダの上端や下端に近い場合を除き、
この小インデックス画面の中で上からおよそ三分の一の位置になる。
これによって、メッセイジを読むときに前後いくつかのメッセイジが
文脈として与えられる。これが便利なのは、例えば、そのスレッドに
あといくつ未読メッセイジが残っているのかを見極めるという場合である。
行数のうち一行はインデックスのステイタス行に使われるので、
<EM>pager_index_lines</EM> が 6 であっても、
実際のインデックスは 5 行しか表示されないことになる。
0 という値にするとインデックスが表示されない。
フォルダ内のメッセイジ数が <EM>pager_index_lines</EM>
よりも少ないとき、小インデックスは必要な行数だけを使うようにする。
<P>
<P>
<H3><A NAME="pager_stop"></A> pager_stop</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されているときには、メッセイジの終わりまで来て <EM>next-page</EM>
関数を実行しても、内部ペイジャが次のメッセイジへ移動<B>しない</B>。
<P>
<P>
<H3><A NAME="crypt_autosign"></A> crypt_autosign</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数を設定すると Mutt が送信メッセイジを常に暗号学的に署名しようとする。
署名が不要なときや暗号化も要るときには、<EM>pgp-menu</EM> を使って
上書きすることができる。
<A HREF="#smime_is_default">$smime_is_default</A>
が設定されているのであれば、OpenSSL を使って S/MIME メッセイジを作成する。
この場合は <EM>smime-menu</EM> を使って設定を上書きすることができる。
(Crypto only)
<P>
<P>
<H3><A NAME="crypt_autoencrypt"></A> crypt_autoencrypt</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数を設定すると、Mutt が、常に PGP 暗号化して
メッセイジを送信しようとするようになる。
これはたぶん、<EM>send-hook</EM> コマンドとの組み合わせでのみ有用だろう。
暗号化が不要だったり署名も必要だったりするときには、<EM>pgp-menu</EM>
を使って上書きすることができる。
<A HREF="#smime_is_default">$smime_is_default</A>
が設定されていると OpenSSL が使われて S/MIME メッセイジが作成される。
その際、設定の上書きは <EM>smime-menu</EM> を使うことにより可能である。
(Crypto only)
<P>
<P>
<H3><A NAME="pgp_ignore_subkeys"></A> pgp_ignore_subkeys</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>この変数を設定すると Mutt が OpenPGP 副鍵を無視するようになる。
主鍵が (訳注：画面上でのみ) 副鍵の能力を継承するのだ。
鍵選択遊びを楽しみたいのであれば、この変数を解除すること。
(訳注：通常、主鍵は署名に使い、副鍵は暗号化に使う。
主鍵の有効期間を長くして副鍵の期間を短くすることで安全性を向上させるよう
推奨されている。通常、ひとつの主鍵に対して有効な副鍵はひとつだけなので、
この変数を設定しても不便なことはないはずだ。)
(PGP only)
<P>
<P>
<H3><A NAME="crypt_replyencrypt"></A> crypt_replyencrypt</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると、暗号化されたメッセイジへの返信には
自動的に PGP か OpenSSL で暗号化する。
(Crypto only)
<P>
<P>
<H3><A NAME="crypt_replysign"></A> crypt_replysign</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、署名されたメッセイジへの返信には
自動的に PGP か OpenSSL で署名する。
<P><B>注意:</B> 署名され、<B>かつ暗号化も</B>されているメッセイジには、
この変数が作用しない!
(Crypto only)
<P>
<P>
<H3><A NAME="crypt_replysignencrypted"></A> crypt_replysignencrypted</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、暗号化されたメッセイジへの返信には
自動的に PGP か OpenSSL で署名する。この変数は
<A HREF="#crypt_replyencrypt">$crypt_replyencrypt</A>
との組み合わせにおいて意味を持つ。その組み合わせによって、
自動的に暗号化されるメッセイジに署名することができるからだ。
この変数は 
<A HREF="#crypt_replysign">$crypt_replysign</A>
で注記されている問題の回避策となる。その問題とは、
暗号化されているメッセイジに署名もされているかどうかを調べることが
Mutt にはできない、というものである。
(訳注：それで、replysign を設定するなら、ふつうは
replysignencrypted も設定したいと思うだろう。
ただし、暗号化かつ署名付きメッセイジに暗号化と署名を施しながら、
署名なし暗号化メッセイジへの返信に暗号化のみ実行するためには
フックを使わなければならないであろう。
<A HREF="#patterns">~g および ~G</A> を参照のこと。)
(Crypto only)
<P>
<P>
<H3><A NAME="crypt_timestamp"></A> crypt_timestamp</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると、Mutt は PGP および S/MIME の出力を囲む行に
時刻表示を含める。これにより出力行の偽造がさらに困難になる。
もし、そうした行に色を使って印付けており、
その色を信頼するのであれば、この設定を解除しても構わない。
(訳注：
<A HREF="#allow_ansi">$allow_ansi</A> 参照)
(Crypto only)
<P>
<P>
<H3><A NAME="pgp_use_gpg_agent"></A> pgp_use_gpg_agent</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、Mutt は、
既に起動してあるであろう gpg-agent プロセスを使おうとする。
(訳注：gpg-agent とはパスフレイズを記憶してくれるエイジェントで、
newpg および gnupg-1.9 以上に含まれている。
ssh-agent のように、環境変数で通信経路を指定する。
Mutt は、GPG_TTY および GPG_AGENT_INFO 環境変数が設定されていれば
gpg-agent が起動しているものとみなし、パスフレイズを尋ねない。
それら環境変数が設定されていなければ通常どおりパスフレイズを尋ねる。
gpg-agent を利用するのであれば、
~/.gnupg/gpg.conf に use-agent と書いておくか、
$pgp_*_command 群に --use-agent オプションを
含めておくべきだろう。)
(PGP only)
<P>
<P>
<H3><A NAME="crypt_verify_sig"></A> crypt_verify_sig</H3>

<P>Type: quadoption<BR>
Default: yes
<P>
<P>&quot;yes&quot; なら、常に PGP および S/MIME 署名を検証しようとする。
&quot;ask&quot; (訳注：実際には ask-yes か ask-no) なら、署名を
検証するかどうか尋ねる。
&quot;no&quot; なら、暗号学的署名を一切検証しようとしない。
(Crypto only)
<P>
<P>
<H3><A NAME="smime_is_default"></A> smime_is_default</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>自動での署名/暗号化に関する既定の動作は、すべて PGP を使うというものだ。
それを上書きして OpenSSL を使うには、この変数を設定しなくてはならない。
ただし、この変数は返信には効果がない。というのも、Mutt はもともとの
メッセイジの署名/暗号化に使われているのと同じ方式を
自動的に選択するからである。
(この変数は 
<A HREF="#crypt_autosmime">$crypt_autosmime</A>
を解除することによって上書きされうるので注意。)
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_ask_cert_label"></A> smime_ask_cert_label</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>このフラグは、デイタベイスに追加しようとする証明書のラベル名を
入力するよう求めるかどうかを制御する。既定では設定されている。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_decrypt_use_default_key"></A> smime_decrypt_use_default_key</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されている (既定) なら、Mutt は復号化に既定鍵を使う。
設定されていないとき、証明書と鍵のペアが複数管理されていれば、
Mutt はメイルアドレス
を使って鍵を決定する。それでも見付からなければ鍵を入力するよう求める。
(S/MIME only)
<P>
<P>
<H3><A NAME="pgp_entry_format"></A> pgp_entry_format</H3>

<P>Type: string<BR>
Default: &quot;%4n %t%f %4l/0x%k %-4a %2c %u&quot;
<P>
<P>この変数を使って PGP 鍵選択メニューを自分好みに調整することができる。
この文字列は 
<A HREF="#index_format">$index_format</A>
に似ているが、独自の printf()風シークウェンスがある。
(訳注：%K, %A, %L, %F, %C も使える。
副鍵にも主鍵の情報を表示する点が異なるが、それ以外は小文字と同じ意味だ。)
<P>
<P>
<DL>
<DT><B>%n     </B><DD><P>番号 (number)
<DT><B>%k     </B><DD><P>鍵 ID (key id)
<DT><B>%u     </B><DD><P>ユーザ ID (user id)
<DT><B>%a     </B><DD><P>アルゴリズム (algorithm)
<DT><B>%l     </B><DD><P>鍵の長さ (length)
<DT><B>%f     </B><DD><P>フラグ (flags) (訳注：期限切れや破棄など)
<DT><B>%c     </B><DD><P>能力 (capabilities) (訳注：署名と暗号化)
<DT><B>%t     </B><DD><P>信用度 (trust) / 鍵とユーザ ID の組み合わせの有効性 (訳注：本来、すべての鍵所有者に対して自分で決定した trust から各鍵の validity すなわち有効性を計算するのであり、「信用度」と「有効性」は違うものである。しかし GnuPG では validity という語を使わず、所有者への信用度は owner-trust, 鍵の有効性は calculated trust と呼ぶようだ。ここで表示されるのは後者である。)
<DT><B>%[&lt;s&gt;] </B><DD><P>鍵の日付 (&lt;s&gt; は strftime(3) 表記)
</DL>
<P>
<P>(PGP only)
<P>
<P>
<H3><A NAME="pgp_good_sign"></A> pgp_good_sign</H3>

<P>Type: regular expression<BR>
Default: &quot;&quot;
<P>
<P>この変数に文章 (訳注：正しくは正規表現) を割り当てると、その文章が
<A HREF="#pgp_verify_command">$pgp_verify_command</A>
の出力に含まれているときにのみ PGP 署名が検証できたとみなされる。
不正な署名にもコマンドの返り値が 0 になってしまうなら、この変数を使うこと。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_check_exit"></A> pgp_check_exit</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると、Mutt が署名や暗号化の際に PGP サブプロセスの返り値を
確認するようになる。非ゼロの返り値はサブプロセスの失敗を意味する。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_long_ids"></A> pgp_long_ids</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると 64 ビットの PGP 鍵 ID を使う。
解除時はふつうの 32 ビット鍵 ID を使う。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_retainable_sigs"></A> pgp_retainable_sigs</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、署名と暗号化をしてあるメッセイジの仲間として、
multipart/encrypted パートの中に multipart/signed パートが入っていたりする
メッセイジも含める。
<P>これは暗号化された署名メイリングリストのようなアプリケイションに便利だ。
すなわち、外層 (multipart/encrypted) が簡単に取り除けるが、
内側の multipart/signed パートは守られているというものである。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_create_traditional"></A> <A NAME="pgp_autoinline"></A> pgp_autoinline</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>このオプションは、旧式のインライン (伝統的) PGP 暗号および署名を
生成するかどうかを制御する。ただし特定の状況下でのみ有効だ。
さらに、インラインが必要ないときには <EM>pgp-menu</EM>
を使って上書きすることができる。
<P>Mutt は複数の MIME パートを含むメッセイジには自動的に PGP/MIME
を使用する、ということを覚えておくように。また、インライン (伝統的形式)
がうまくいかなかったときに PGP/MIME で送信するかどうかを尋ねるように
設定することができる。
参照: 
<A HREF="#pgp_mime_auto">$pgp_mime_auto</A><P>なお、旧式 PGP メッセイジ形式は<B>強く否定されている</B>
という点にも注意すべきである。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_auto_traditional"></A> <A NAME="pgp_replyinline"></A> pgp_replyinline</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数を設定すると、インライン (伝統的形式) で暗号化/署名されたメッセイジへ
返信する際は、常にインラインのメッセイジを作成しようとするようになる。
しかしインラインが必要ないときには <EM>pgp-menu</EM> で上書きすることができる。
このオプションは、元のメッセイジがインラインかどうかを自動で
検知するわけではない。事前に確認しフラグが立てられたメッセイジに関する
Mutt 内部デイタを信用するだけである。
<P>複数の MIME パートを含むメッセイジには自動で PGP/MIME を使用するので注意せよ。
また、インライン (伝統的形式) がうまくいかなかったときに
PGP/MIME にするかどうかを送信前に尋ねるよう設定することができる。
参照: 
<A HREF="#pgp_mime_auto">$pgp_mime_auto</A><P>なお、旧式 PGP メッセイジ形式は<B>避ける</B>よう<B>強く</B>
勧められているという点にも注意すべきである。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_show_unusable"></A> pgp_show_unusable</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると、使用不可能な鍵を PGP 鍵選択メニューに表示する。
これには、破棄された鍵、期限切れの鍵、またユーザによって「使用不可」
とされた鍵が含まれる。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_sign_as"></A> pgp_sign_as</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>複数の鍵ペアがあるとき、どの秘密鍵を使うかを
このオプションで指定することができる。
指定には鍵 ID 形式を使うよう推奨されている (例 &quot;0x00112233&quot;)。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_strict_enc"></A> pgp_strict_enc</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると PGP/MIME 署名メッセイジを自動的に
<EM>quoted-printable</EM> で符号化する。
この変数を解除すると PGP 署名が検証できなくなるかもしれないので注意せよ。
この変数の意味をよく理解している場合にのみ変更するように。
(訳注：日本語環境においては QP を理解しない PGP プラグインを利用する
MUA もあるため、この変数を設定していると、相手がメッセイジを読むことすら
できないかもしれない。訳者はこの問題で悩んだことがあるので、
解除しておくことを勧める。)
(PGP only)
<P>
<P>
<H3><A NAME="pgp_timeout"></A> pgp_timeout</H3>

<P>Type: number<BR>
Default: 300
<P>
<P>キャッシュされたパスフレイズが使用されない場合に期限切れになるまでの秒数。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_sort_keys"></A> pgp_sort_keys</H3>

<P>Type: sort order<BR>
Default: address
<P>
<P>PGP 鍵メニューの項目をどう整列するか指定する。
以下が有効な値である。
<P>
<P>
<DL>
<DT><B>address </B><DD><P>ユーザ ID でアルファベット順に整列
<DT><B>keyid   </B><DD><P>鍵 ID でアルファベット順に整列
<DT><B>date    </B><DD><P>鍵の作成日付で整列
<DT><B>trust   </B><DD><P>鍵の信用度で整列
</DL>
<P>
<P>逆順にしたければ、上記の値の頭に &quot;reverse-&quot; を付加する。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_mime_auto"></A> pgp_mime_auto</H3>

<P>Type: quadoption<BR>
Default: ask-yes
<P>
<P>インライン (伝統的形式) の署名/暗号化に (いかなる理由にせよ) 失敗したときに
自動的に PGP/MIME で送信するか尋ねるかを、このオプションで制御する。
<P>旧式 PGP メッセイジ形式の使用は<B>まったく推奨されない</B>ことに注意。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_auto_traditional"></A> pgp_auto_traditional</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>旧式インライン PGP で暗号化や署名をしてあるメッセイジへ返信する際は
旧式メッセイジを生成させ、PGP/MIME メッセイジへ返信する際は PGP/MIME
にするオプションである。ただし、
<A HREF="#crypt_replyencrypt">$crypt_replyencrypt</A>,
<A HREF="#crypt_replysign">$crypt_replysign</A>,
<A HREF="#crypt_replysignencrypted">$crypt_replysignencrypted</A>
を使っている場合にのみ有効である。
<P>さらに注意すべきことに、us-ascii 以外の文字セットや複数 MIME パートで
構成されたメッセイジは自動的に PGP/MIME が使われる。
<P>このオプションは
<A HREF="#pgp_create_traditional">$pgp_create_traditional</A>
を上書きする。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_decode_command"></A> pgp_decode_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>この形式化文字列で、application/pgp
添付ファイルを復号化するためのコマンドを指定する。
<P>PGP コマンドの形式には独自の printf風シークウェンスがある。
<P>
<P>
<DL>
<DT><B>%p </B><DD><P>パスフレイズが必要なときには PGPPASSFD=0 と展開され、必要ないときには空文字列になる。
メモ: これは %? 構造にも使うことができる。
<DT><B>%f </B><DD><P>メッセイジの入っているファイルの名前に展開される。
<DT><B>%s </B><DD><P>multipart/signed の検証時に、署名パートの入っているファイル名に展開される。
<DT><B>%a </B><DD><P>
<A HREF="#pgp_sign_as">$pgp_sign_as</A> の値。
<DT><B>%r </B><DD><P>鍵 ID (複数になることもある)
</DL>
<P>
<P>世の中に出廻っている各種ヴァージョンの PGP に合わせて設定する方法の例は、
pgp*.rc および gpg.rc というファイルが、文書と同じあたりの
samples/ サブディレクトリ内にインストールされているので、参照すること。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_getkeys_command"></A> pgp_getkeys_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>Mutt が公開鍵情報を必要とするたびに起動するコマンド。
%r が、唯一ここで使われる printf風シークウェンスである。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_verify_command"></A> pgp_verify_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドが PGP 署名の検証に使われる。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_decrypt_command"></A> pgp_decrypt_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドが PGP 暗号化メッセイジの復号に使われる。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_clearsign_command"></A> pgp_clearsign_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>旧式の「クリア署名」による PGP メッセイジを作成するために使われる。
ただし、この形式を使うことは<B>まったく推奨されない</B>。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_sign_command"></A> pgp_sign_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドを使って分離式の PGP 署名を作り、multipart/signed の
PGP/MIME パートに使う。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_encrypt_sign_command"></A> pgp_encrypt_sign_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドを使って、本文に署名と暗号化を両方おこなう。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_encrypt_only_command"></A> pgp_encrypt_only_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドを使って本文を暗号化する。署名はしない。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_import_command"></A> pgp_import_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドを使って、鍵をメッセイジから公開鍵束へ取り込む。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_export_command"></A> pgp_export_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドを使って、ユーザの鍵束から公開鍵を取り出す。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_verify_key_command"></A> pgp_verify_key_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>鍵選択メニューで鍵の情報を検証するために、このコマンドを用いる。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_list_secring_command"></A> pgp_list_secring_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドで秘密鍵束の内容を一覧出力する。
出力形式は gpg --list-keys --with-colons と同様でなくてはならない。
(訳注：詳細は gnupg の文書ファイル DETAILS に書かれている。)
<P>この形式は、Mutt に付属する pgpring ユーティリティでも生成される。
(PGP only)
<P>
<P>
<H3><A NAME="pgp_list_pubring_command"></A> pgp_list_pubring_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドで公開鍵束の内容を一覧にする。
出力形式は gpg --list-keys --with-colons と同様でなくてはならない。
<P>この形式は、Mutt 付属の pgpring ユーティリティでも生成される。
(PGP only)
<P>
<P>
<H3><A NAME="forward_decrypt"></A> forward_decrypt</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>転送時における暗号化メッセイジの扱いを制御する。
設定されていると、暗号化という外層が除去される。
この変数は、
<A HREF="#mime_forward">$mime_forward</A>
が<EM>設定</EM>され、
<A HREF="#mime_forward_decode">$mime_forward_decode</A>
が<EM>解除</EM>されているときにのみ用いられる。
(PGP only)
<P>
<P>
<H3><A NAME="smime_timeout"></A> smime_timeout</H3>

<P>Type: number<BR>
Default: 300
<P>
<P>キャッシュされたパスフレイズが使用されない場合に期限切れになるまでの秒数。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_encrypt_with"></A> smime_encrypt_with</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>暗号化に用いるアルゴリズムを設定する。
有効な選択肢は &quot;des&quot;, &quot;des3&quot;, &quot;rc2-40&quot;,
&quot;rc2-64&quot;, &quot;rc2-128&quot; である。
設定されていないと &quot;des3&quot; (トリプルDES) が用いられる。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_keys"></A> smime_keys</H3>

<P>Type: path<BR>
Default: &quot;&quot;
<P>
<P>OpenSSL には PGP における鍵束のようなものがないため、Mutt は
鍵や証明書の格納および取得を自分で扱わなければならない。
この仕組みは現在のところ非常に簡易的なもので、鍵と証明書を二つの異なる
ディレクトリに格納し、ともに OpenSSL で取得したハッシュ値を
ファイル名にしている。各ディレクトリには index ファイルがあって、
メイルアドレスと鍵 ID の組み合わせが入っており、自分の手で
編集することができる。この変数は、秘密鍵の場所を指し示すものである。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_ca_location"></A> smime_ca_location</H3>

<P>Type: path<BR>
Default: &quot;&quot;
<P>
<P>OpenSSL に使うための、信用できる証明書が入ったディレクトリかファイルの
名前を入れる。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_certificates"></A> smime_certificates</H3>

<P>Type: path<BR>
Default: &quot;&quot;
<P>
<P>OpenSSL には PGP における鍵束のようなものがないため、Mutt は
鍵や証明書の格納および取得を自分で扱わなければならない。
この仕組みは現在のところ非常に簡易的なもので、鍵と証明書を二つの異なる
ディレクトリに格納し、ともに OpenSSL で取得したハッシュ値を
ファイル名にしている。各ディレクトリには index ファイルがあって、
メイルアドレスと鍵 ID の組み合わせが入っており、自分の手で
編集することができる。この変数は、証明書の場所を指し示すものである。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_decrypt_command"></A> smime_decrypt_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>この形式化文字列で指定したコマンドを使って application/x-pkcs7-mime
ファイルを復号化する。
<P>OpenSSL コマンドの指定形式には、PGP に似た独自の printf風シークウェンスがある。
<P>
<P>
<DL>
<DT><B>%f </B><DD><P>メッセイジの入っているファイルの名前に展開される。
<DT><B>%s </B><DD><P>multipart/signed の検証時に、署名パートの入っているファイル名に展開される。
<DT><B>%k </B><DD><P>
<A HREF="#smime_default_key">$smime_default_key</A> で指定された鍵ペア。
<DT><B>%c </B><DD><P>証明書 ID (複数になることもある)
<DT><B>%a </B><DD><P>暗号化に用いるアルゴリズム。
<DT><B>%C </B><DD><P>CA 位置: 
<A HREF="#smime_ca_location">$smime_ca_location</A> がディレクトリを指すかファイルを指すかにより、&quot;-CApath 
<A HREF="#smime_ca_location">$smime_ca_location</A>&quot; か &quot;-CAfile 
<A HREF="#smime_ca_location">$smime_ca_location</A>&quot; に展開される。
</DL>
<P>
<P>この形式の設定方法の例については、smime.rc というファイルを参照せよ。
文書のそばの samples/ サブディレクトリにインストールされている。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_verify_command"></A> smime_verify_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドを使って multipart/signed タイプの S/MIME 署名を検証する。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_verify_opaque_command"></A> smime_verify_opaque_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドを使って application/x-pkcs7-mime タイプの S/MIME 署名を検証する。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_sign_command"></A> smime_sign_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドは multipart/signed タイプの
S/MIME 署名を作成するために用いられる。
このタイプはあらゆるメイルクライアントから読める。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_sign_opaque_command"></A> smime_sign_opaque_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドは application/x-pkcs7-signature タイプの
S/MIME 署名を作成するために用いられる。
このタイプは S/MIME 拡張に対応したメイルクライアントからのみ扱える。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_encrypt_command"></A> smime_encrypt_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドは暗号化 S/MIME メッセイジを作成するために用いられる。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_pk7out_command"></A> smime_pk7out_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドを用いて S/MIME 署名の PKCS7 構造を抽出する。
その目的は、そこからさらに X509 公開証明書を抽出することにある。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_get_cert_command"></A> smime_get_cert_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>PKCS7 構造から X509 証明書を抽出するために用いるコマンド。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_get_signer_cert_command"></A> smime_get_signer_cert_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドで署名者の X509 証明書だけを S/MIME 署名から抽出する。
そうして証明書の所有者とメイルの From フィールドを比較できるようにするのだ。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_import_cert_command"></A> smime_import_cert_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>証明書を smime_keys で取り込むために使うコマンド。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_get_cert_email_command"></A> smime_get_cert_email_command</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>このコマンドを使って、
用途の検証 (証明書がその送信者のアドレス用に発行されたのかどうかの確認のため)
と X509 証明書の格納のために用いられるメイルアドレスを抽出する。
(S/MIME only)
<P>
<P>
<H3><A NAME="smime_default_key"></A> smime_default_key</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>署名に使う既定の鍵ペア。鍵 ID (OpenSSL が生成するハッシュ値)
に設定されていないと正常に動作しない。
(S/MIME only)
<P>
<P>
<H3><A NAME="ssl_starttls"></A> ssl_starttls</H3>

<P>Type: quadoption<BR>
Default: yes
<P>
<P>設定されている (既定) とき、STARTTLS 能力を公言するサーバでは
Mutt が STARTTLS を使おうとする。解除されていると、サーバの能力に
関わらず STARTTLS を使おうとしない。
<P>
<P>
<H3><A NAME="certificate_file"></A> certificate_file</H3>

<P>Type: path<BR>
Default: &quot;~/.mutt_certificates&quot;
<P>
<P>この変数で指定したファイルに、信用する証明書を保存する。
未知の証明書に遭遇すると、受け入れるかどうか尋ねられる。
受け入れると証明書がこのファイルに保存され、以後の接続では
自動的に受け入れられる。
<P>自分の手で CA 証明書をこのファイルに追加することもできる。
すると、その CA に署名されたサーバ証明書もすべて自動的に受け入れられる。
<P>例: set certificate_file=~/.mutt/certificates
<P>
<P>
<H3><A NAME="ssl_usesystemcerts"></A> ssl_usesystemcerts</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P><EM>yes</EM> に設定されていると、
信用できる CA からサーバ証明書が署名されているかどうかを確認する際に、
システム全体用の証明書格納所にあるCA 証明書を使う。
<P>
<P>
<H3><A NAME="entropy_file"></A> entropy_file</H3>

<P>Type: path<BR>
Default: &quot;&quot;
<P>
<P>SSL ライブラリ関数の初期化に用いる乱数デイタの入ったファイル。
<P>
<P>
<H3><A NAME="ssl_use_sslv2"></A> ssl_use_sslv2</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>SSL 認証処理に SSLv2 を使おうとするかどうか指定する。
<P>
<P>
<H3><A NAME="ssl_use_sslv3"></A> ssl_use_sslv3</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>SSL 認証処理に SSLv3 を使おうとするかどうか指定する。
<P>
<P>
<H3><A NAME="ssl_use_tlsv1"></A> ssl_use_tlsv1</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>SSL 認証処理に TLSv1 を使おうとするかどうか指定する。
<P>
<P>
<H3><A NAME="pipe_split"></A> pipe_split</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P><EM>pipe-message</EM> コマンドおよび &quot;tag-prefix&quot; 演算子との
関連で用いられる。この変数が解除されていると、複数のタグ付けされた
メッセイジをパイプする際に Mutt はすべて連結させて単一ファイル
としてパイプする。設定されていると、Mutt はメッセイジごとに一つずつパイプする。
どちらの場合も、その時点での整列方法の順にメッセイジがパイプされ、
<A HREF="#pipe_sep">$pipe_sep</A> が各メッセイジの
後に付加される。
<P>
<P>
<H3><A NAME="pipe_decode"></A> pipe_decode</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P><EM>pipe-message</EM> コマンドと関連して使われる。
解除されていると Mutt は何も前処理をせずにメッセイジをパイプする。
設定されていると、まずヘッダを間引きしたり PGP/MIME 復号化したりしようとする。
<P>
<P>
<H3><A NAME="pipe_sep"></A> pipe_sep</H3>

<P>Type: string<BR>
Default: &quot;\n&quot;
<P>
<P>タグ付けされた複数のメッセイジを外部 Unix コマンドへパイプする際、
メッセイジとメッセイジの間を区切るために付加される文字列。
<P>
<P>
<H3><A NAME="pop_authenticators"></A> pop_authenticators</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>コロン区切りで列挙された認証方法。POP サーバにログインするために、
その順で試行する。認証方法は &quot;user&quot;, &quot;apop&quot;
およびいずれかの SASL 機構、例えば &quot;digest-md5&quot; や
&quot;gssapi&quot;, &quot;cram-md5&quot; である。
このパラメータは大文字と小文字を区別しない。
もし設定されていなければ (既定)、Mutt はあらゆる利用可能な方法を、
最も安全なものから始めて、最も安全でないものまで試行する。
<P>例: set pop_authenticators=&quot;digest-md5:apop:user&quot;
<P>
<P>
<H3><A NAME="pop_auth_try_all"></A> pop_auth_try_all</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると、Mutt は利用可能な方法をすべて試行する。
解除されていると、前の方法が利用できなかったときにのみ他の認証方法に移る。
認証方法は利用できるけれども認証が失敗したという場合には、
POP サーバへの接続をやめるのだ。
<P>
<P>
<H3><A NAME="pop_checkinterval"></A> pop_checkinterval</H3>

<P>Type: number<BR>
Default: 60
<P>
<P>この変数は、何秒ごとに POP で新着メイルを探すかを調整する。
<P>
<P>
<H3><A NAME="pop_delete"></A> pop_delete</H3>

<P>Type: quadoption<BR>
Default: ask-no
<P>
<P>設定されていると、fetch-mail 関数を使って POP サーバから
ダウンロードすることに成功したメッセイジを削除する。
解除されていると、メッセイジはダウンロードするものの、
POP サーバにも残しておく。
<P>
<P>
<H3><A NAME="pop_host"></A> pop_host</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>fetch-mail 関数の POP サーバ名。
次のように、代替ポート、ユーザ名、パスワードも指定することができる。
<P>[pop[s]://][ユーザ名[:パスワード]@]サーバ[:ポート]
<P>
<P>
<H3><A NAME="pop_last"></A> pop_last</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数が設定されていると、fetch-mail 関数の使用時に POP コマンド
&quot;LAST&quot; を使って POP サーバから未読メッセイジのみを
取得しようとする。
<P>
<P>
<H3><A NAME="pop_reconnect"></A> pop_reconnect</H3>

<P>Type: quadoption<BR>
Default: ask-yes
<P>
<P>POP サーバとの接続が切れたときに再接続を試みるかどうかを制御する。
<P>
<P>
<H3><A NAME="pop_user"></A> pop_user</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>POP サーバへのログイン名。
<P>既定ではロウカルマシンでのユーザ名になる。
<P>
<P>
<H3><A NAME="pop_pass"></A> pop_pass</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>POP アカウントのパスワードを指定する。設定されていないと、
POP メイルボックスを開くときにパスワードの入力を求める。
<B>警告</B>: このオプションは、確実に安全なマシンでのみ使うべきである。
自分しか読めないファイルであっても、スーパユーザは読むことができるからだ。
<P>
<P>
<H3><A NAME="post_indent_string"></A> post_indent_string</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>
<A HREF="#attribution">$attribution</A> 変数と似ており、
Mutt はこの文字列を、返信するメッセイジの引用のあとに追加する。
<P>
<P>
<H3><A NAME="postpone"></A> postpone</H3>

<P>Type: quadoption<BR>
Default: ask-yes
<P>
<P>メッセイジをその場で送らないことにした際に
<A HREF="#postponed">$postponed</A> メイルボックスへ
保存するかどうかを制御する。
<P>
<P>
<H3><A NAME="postponed"></A> postponed</H3>

<P>Type: path<BR>
Default: &quot;~/postponed&quot;
<P>
<P>編集中のメッセイジは、いつまででも送信を
<A HREF="#postpone">延期 (postpone)</A> しておくことができる。
延期することにした際、Mutt はこの変数で指定されたメイルボックスに保存する。
これに関しては 
<A HREF="#postpone">$postpone</A> も参照のこと。
<P>
<P>
<H3><A NAME="preconnect"></A> preconnect</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>設定されていると、サーバとの接続を確立できなかったときに
このシェルコマンドが実行される。これは ssh(1) などで安全な接続経路を
作るために使える。もしコマンドが非ゼロの結果を返すなら、Mutt は
そこでサーバを開くことをあきらめる。例:
<P>preconnect=&quot;ssh -f -q -L 1234:example.net:143 example.net
sleep 20 &lt; /dev/null &gt; /dev/null&quot;
<P>example.net のメイルボックス 'foo' は、これで '{localhost:1234}foo'
として扱うことができる。
<P>注意: この例がうまくいくためには、このリモウトマシンに
パスワードなしでログインできなくてはならない。
<P>
<P>
<H3><A NAME="print"></A> print</H3>

<P>Type: quadoption<BR>
Default: ask-no
<P>
<P>印刷前に確認を求めるかどうかを制御する。
(訳注：no にすると印刷できなくなる。yes にすると確認せずに印刷する。
ask-yes や ask-no にすると確認する。)
よく間違って &quot;p&quot; を押してしまう (私のような) 人に有用である。
<P>
<P>
<H3><A NAME="print_command"></A> print_command</H3>

<P>Type: path<BR>
Default: &quot;lpr&quot;
<P>
<P>これに指定したコマンドへパイプしてメッセイジを印刷する。
<P>
<P>
<H3><A NAME="print_decode"></A> print_decode</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>print-message コマンドと関連して用いられる。このオプションが設定されていると
メッセイジを復号化してから外部コマンド
<A HREF="#print_command">$print_command</A>
に渡す。解除されていると、何の処理もせずにメッセイジを印刷する。
後者は、メイルメッセイジを印刷にふさわしく整形することのできる
高度なプリンタフィルタを使っている場合に有用であろう。
<P>
<P>
<H3><A NAME="print_split"></A> print_split</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>print-message コマンドとの関連で用いる。設定されていると、
<A HREF="#print_command">$print_command</A>
で指定されたコマンドが、印刷メッセイジごとに毎回実行される。
解除されていると、
<A HREF="#print_command">$print_command</A>
は一度だけ実行され、メッセイジがすべて連結される。
その際、フォームフィード (訳注：0x0c や \f として知られるもの)
がメッセイジの区切りとして使われる。
<P><B>enscript</B>(1) プログラムのメイル印刷モウドを使っている人は
このオプションを設定したいと思うはずだ。
<P>
<P>
<H3><A NAME="prompt_after"></A> prompt_after</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P><EM>外部</EM>
<A HREF="#pager">ペイジャ</A>を使っている場合、
この変数を設定しておくと、ペイジャ終了時にインデックスメニューへ戻らず、
コマンド入力を求めるようになる。
解除されていると、すぐインデックスメニューに戻る。
<P>
<P>
<H3><A NAME="query_command"></A> query_command</H3>

<P>Type: path<BR>
Default: &quot;&quot;
<P>
<P>この変数で指定したコマンドを使ってアドレスの外部問い合わせをおこなう。
この文字列には %s を含むべきで、その部分がユーザの入力する
問い合わせ文字列に置換される。より詳細な情報は
<A HREF="#query">アドレスの外部問い合わせ</A>を参照。
<P>
<P>
<H3><A NAME="quit"></A> quit</H3>

<P>Type: quadoption<BR>
Default: yes
<P>
<P>この変数は、&quot;quit&quot; と &quot;exit&quot; が実際に
Mutt を終了させるかどうかを制御する。終了させようとしたとき、
yes に設定されていると終了させ、no に設定されていると無効で、
ask-yes か ask-no に設定されていると確認を求められる。
<P>
<P>
<H3><A NAME="quote_regexp"></A> quote_regexp</H3>

<P>Type: regular expression<BR>
Default: &quot;^([ \t]*[|&gt;:}#])+&quot;
<P>
<P>内部ペイジャで、メッセイジ本文の引用部分を見極めるために使う正規表現。
<P><B>注意:</B> 内部ペイジャで <EM>quoted</EM><B>x</B> のような
着色パターンを使うためには、引用行の冒頭の引用文字に<EM>正確に</EM>
合致する正規表現を設定する必要がある。
(訳注：すなわち、引用記号全体に合致し、かつ、引用記号のみに合致する
表現でなくてはならない。
&quot;&gt; &gt; &gt;&quot; のような多層になった引用であっても、
この正規表現ひとつで合致する必要があるのだ。)
<P>
<P>
<H3><A NAME="read_inc"></A> read_inc</H3>

<P>Type: number<BR>
Default: 10
<P>
<P>0 より大きな値に設定されていると、メイルボックス読み出し中に
Mutt が現在どのメッセイジまで来たのかを表示するようになる。
その表示は <EM>read_inc</EM> 通のメッセイジが読み出されるたびに
おこなわれる (例えば 25 だと、25 番目のメッセイジを読んだときに表示し、
さらにまた 50 番目のときにも表示する)。この変数の意味は、時間のかかる
大きなメイルボックスを読み出す際に、進行状況を示すということだ。
0 に設定されているときは、メイルボックスの読み出し前に一度
メッセイジが表示されるだけになる。
<P>
<A HREF="#write_inc">$write_inc</A> 変数も参照のこと。
<P>
<P>
<H3><A NAME="read_only"></A> read_only</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、フォルダがすべて読み出し専用モウドで開かれる。
<P>
<P>
<H3><A NAME="realname"></A> realname</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>メッセイジ送信時に使う「本名」すなわち「個人名」を指定する。
<P>既定では /etc/passwd の GECOS フィールドになる。
なお、ユーザが 
<A HREF="#from">$from</A> に本名を設定していると、
この変数が使われ<EM>ない</EM>ので注意。
<P>
<P>
<H3><A NAME="recall"></A> recall</H3>

<P>Type: quadoption<BR>
Default: ask-yes
<P>
<P>新規メッセイジを作成する際に、延期メッセイジから続けるかどうかを制御する。
<A HREF="#postponed">$postponed</A> も参照。
<P>この変数を &quot;yes&quot; に設定することが一般的に有用であるとは
言えないので、そのような設定は推奨されていない。
(訳注：&quot;yes&quot; だと、ひとつでも延期されているメッセイジがあると、
いつまでも新規メッセイジが作成できなくなる。返信はできる。)
<P>
<P>
<H3><A NAME="record"></A> record</H3>

<P>Type: path<BR>
Default: &quot;&quot;
<P>
<P>送信メッセイジをどのファイルに追加して保存すべきかを指定する。
(これはメッセイジのコピーを保存する基本的な方法であるが、
ほかにも、
<A HREF="#my_hdr">my_hdr</A> コマンドで
自分のメイルアドレスの <EM>Bcc:</EM> フィールドを作成するという方法もある。)
<P><EM>
<A HREF="#record">$record</A></EM> の値は、
<A HREF="#force_name">$force_name</A> および
<A HREF="#save_name">$save_name</A> 変数、
また 
<A HREF="#fcc-hook">fcc-hook</A> コマンドにより上書きされる。
(訳注：さらに、この変数は Fcc ヘッダの既定値に過ぎないので、
Fcc を変更すれば上書きされる。Fcc と 
<A HREF="#record">$record</A>
の両方に保存されるわけではないので注意。)
<P>
<P>
<H3><A NAME="reply_regexp"></A> reply_regexp</H3>

<P>Type: regular expression<BR>
Default: &quot;^(re([\[0-9\]+])*|aw):[ \t]*&quot;
<P>
<P>返信メッセイジを認識するための正規表現。
スレッドを作ったり返信したりするときに使う。
既定値は英語の &quot;Re:&quot; とドイツ語の &quot;Aw:&quot;
に対応している。(訳注：ただし、Re[3]: や Re3: には合致するが
Aw[3]: や Aw3: には合致しない。)
<P>
<P>
<H3><A NAME="reply_self"></A> reply_self</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>自分の送ったメッセイジに返信するとき、これが解除されていれば、
自分に返信したいのではなく、そのメッセイジの宛先に返信したいのだとみなされる。
<P>
<P>
<H3><A NAME="reply_to"></A> reply_to</H3>

<P>Type: quadoption<BR>
Default: ask-yes
<P>
<P>(訳注：ask-yes か ask-no に) 設定されていると、返信しようとする際に
メッセイジの Reply-To: ヘッダフィールドで挙げられているアドレスを
使いたいかどうかを聞いてくる。no と答えると From: ヘッダフィールドの
アドレスを代わりに用いる。このオプションは、Reply-To: ヘッダフィールドを
リストのアドレスに設定してくるメイリングリストを読んでいて、
メッセイジの送信者へ個人的にメッセイジを送りたい場合に便利である。
<P>
<P>
<H3><A NAME="resolve"></A> resolve</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されているときには、メッセイジを変更するコマンドが実行されると
カーソルが自動で進み、(あれば) 次の未削除メッセイジへ動く。
<P>
<P>
<H3><A NAME="reverse_alias"></A> reverse_alias</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数は、メッセイジの送信者に合致するエイリアスがあるときに、
エイリアスの「個人名」部分をインデックスメニューで表示するかどうかを制御する。
例として、次のエイリアスがあるとする。
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
alias juser abd30425@somewhere.net (Joe User)
</PRE>
</CODE></BLOCKQUOTE>
<P>そして、このようなヘッダを含むメイルを受け取ったとする。
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
From: abd30425@somewhere.net
</PRE>
</CODE></BLOCKQUOTE>
<P>すると、(訳注：$reverse_alias が yes のときには)
インデックスメニューに &quot;abd30425@somewhere.net&quot;
ではなく &quot;Joe User&quot; と表示されるであろう。
これは、その人物のメイルアドレスが人間向きでない (CompuServe
のアドレスのような) ときに便利である。
<P>
<P>
<H3><A NAME="reverse_name"></A> reverse_name</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>メイルをあるマシンで受信し、別のマシンへ移して、そこから返信する
ということが時々あるかもしれない。この変数が設定されていると、
返信したいメッセイジを受け取ったアドレスが alternates に
合致しているときには、そのアドレスを使って既定の <EM>From:</EM>
行が作成される。この変数が設定されていなかったり、アドレスが
alternates に合致しなかったりした場合には、
<EM>From:</EM> 行には返信時のマシンのアドレスが使われる。
<P>
<P>
<H3><A NAME="reverse_realname"></A> reverse_realname</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>この変数は 
<A HREF="#reverse_name">reverse_name</A> 機能の
動作を微調整する。これが設定されていると、Mutt は受信メッセイジのアドレスを
そのまま丸ごと使う。あれば本名部分まで含めて使うのだ。もし解除されていると、
そうした本名部分は 
<A HREF="#realname">realname</A> 変数の設定で
上書きするようになる。
<P>
<P>
<H3><A NAME="rfc2047_parameters"></A> rfc2047_parameters</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数が設定されていると、RFC-2047 で符号化された MIME
パラメータを復号化する。Mutt が添付ファイルを
=?iso-8859-1?Q?file=5F=E4=5F991116=2Ezip?=
のようなファイル名で保存するよう提案してくるときには、
この変数を設定したいと思うであろう。
<P>この変数を実行中に設定したときには、フォルダを変更するまで
望み通りの効果はあらわれない。
<P>注意すべき点がある。このような RFC 2047 符号化方式の使い方は、
その規格によって明示的に禁止されていること、
しかしながら実際にはよく見かけるということだ。
加えて、このパラメータを設定しても Mutt がこのような符号化ファイル名を
<EM>生成</EM>するという効果は<EM>ない</EM>という点にも注意せよ。
そうではなく、Mutt は常に RFC 2231 で指示されている符号化方式を用いる。
<P>
<P>
<H3><A NAME="save_address"></A> save_address</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、メイルを保存する既定フォルダに送信者のアドレス全体を使う。
<A HREF="#save_name">$save_name</A> や
<A HREF="#force_name">$force_name</A> が設定されていると、
Fcc フォルダの選択も変わる。(訳注：$save_name が yes なら、
アドレスと同じフォルダ名が Fcc に使われるようになる。$force_name
が yes なら、そのようなフォルダが存在しなくても作成して Fcc するようになる。)
<P>
<P>
<H3><A NAME="save_empty"></A> save_empty</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>解除されていると、メッセイジの保存されていないメイルボックスが、
閉じるときに削除される (例外は 
<A HREF="#spoolfile">$spoolfile</A>
である。これはどんな場合にも削除されない)。
設定されていると、どのメイルボックスも削除されない。
<P><B>注意:</B> これが適用されるのは mbox と MMDF のフォルダのみであり、
Mutt が MH や Maildir のディレクトリを削除することはない。
<P>
<P>
<H3><A NAME="save_name"></A> save_name</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数は、どのように送信メッセイジのコピーを保存するかを制御する。
設定されているときには、宛先アドレスで指定されるメイルボックスが
あるかどうかを確認する (これは 
<A HREF="#folder">$folder</A>
ディレクトリ内で、アドレスの<EM>ユーザ名</EM>部分に該当するメイルボックスを
検索することによる)。そのメイルボックスが存在していれば、送信メッセイジは
そこに保存される。存在しなければ 
<A HREF="#record">$record</A>
メイルボックスに保存される。
<P>
<A HREF="#force_name">$force_name</A> 変数も参照。
<P>
<P>
<H3><A NAME="score"></A> score</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>この変数が <EM>no</EM> のときには得点付けが停止される。
これを使えばフォルダによって得点付けを無効にすることができるので、
<A HREF="#score_threshold_delete">$score_threshold_delete</A>
やその仲間たちを使っているときに便利かもしれない。
<P>
<P>
<H3><A NAME="score_threshold_delete"></A> score_threshold_delete</H3>

<P>Type: number<BR>
Default: -1
<P>
<P>得点がこの値以下のメッセイジは、自動的に削除予定の印が付けられる。
Mutt のスコアは常にゼロ以上なので、既定の設定では
いかなるメッセイジも削除予定にされることはない。
<P>
<P>
<H3><A NAME="score_threshold_flag"></A> score_threshold_flag</H3>

<P>Type: number<BR>
Default: 9999
<P>
<P>割り当てられた得点がこの変数の値以上になるメッセイジには自動的に
「重要」フラグが付けられる。
<P>
<P>
<H3><A NAME="score_threshold_read"></A> score_threshold_read</H3>

<P>Type: number<BR>
Default: -1
<P>
<P>メッセイジに、この変数と同じかそれより小さい得点が付いたとき、Mutt
が既読として印付ける。Mutt では得点が常にゼロかゼロ以上なので、
既定の設定でメッセイジを既読にしてしまうことはありえない。
<P>
<P>
<H3><A NAME="send_charset"></A> send_charset</H3>

<P>Type: string<BR>
Default: &quot;us-ascii:iso-8859-1:utf-8&quot;
<P>
<P>送信メッセイジの文字セットを列挙する。
Mutt は、その文字セットへ正しく文章を変換できた最初のものを使う。
(訳注：
<A HREF="#charset">$charset</A> から
$send_charset へ変換する。)
もし 
<A HREF="#charset">$charset</A> が iso-8859-1
でなく、しかも宛先の人が UTF-8 を理解できないのであれば、
適切な、広く用いられている標準的な文字セット (iso-8859-2,
koi8-r, iso-2022-jp など) を &quot;iso-8859-1&quot; の代わり、
あるいはその後に含めることが推奨されている。
(訳注：MS の似非 iso-2022-jp を送信しなくてはならないとしても、
content type には iso-2022-jp と書かねばならないので、
この変数には iso-2022-jp と指定すべきである。
その場合には 
<A HREF="#charset-hook">iconv-hook</A> で調整する。)
<P>
<P>
<H3><A NAME="sendmail"></A> sendmail</H3>

<P>Type: path<BR>
Default: &quot;/usr/sbin/sendmail -oem -oi&quot;
<P>
<P>Mutt で送信するメイルの配送に用いられるプログラムと引数を指定する。
Mutt は、続く引数をこのプログラムが宛先アドレスとして解釈するものと
想定している。
<P>
<P>
<H3><A NAME="sendmail_wait"></A> sendmail_wait</H3>

<P>Type: number<BR>
Default: 0
<P>
<P>
<A HREF="#sendmail">$sendmail</A> プロセスが終わるのを
あきらめて配送をバックグラウンドへ追いやるまで待つ秒数。
<P>Mutt はこの変数の値を以下のように解釈する。
<P>
<DL>
<DT><B>&gt;0 </B><DD><P>sendmail の終了を待つ秒数
<DT><B>0  </B><DD><P>sendmail の終了をいつまでも待ち続ける
<DT><B>&lt;0 </B><DD><P>常に sendmail をバックグラウンドで実行し、待たない
</DL>
<P>
<P>注意すべき点がある。もしも 0 以外の値を指定すると、sendmail
子プロセスの出力が一時ファイルへ置かれることになるのだ。
何かエラーがあった場合には、その出力がどこにあるかを知らされることになる。
<P>
<P>
<H3><A NAME="shell"></A> shell</H3>

<P>Type: path<BR>
Default: &quot;&quot;
<P>
<P>内部でサブシェルを実行する際に使うコマンド。既定では、/etc/passwd を見て
ユーザのログインシェルを用いる。
<P>
<P>
<H3><A NAME="sig_dashes"></A> sig_dashes</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると、&quot;-- &quot; という行が
<A HREF="#signature">署名 ($signature)</A> の前に挿入される。
署名が名前だけでない限りこの変数を解除しないことを、<B>強く</B>推奨する。
その理由は、多くのソフトウェアが &quot;-- \n&quot; を使って
署名を検出するからである。例えば Mutt は内蔵ペイジャで署名を別の色に
目立たせる能力を持っている。
<P>
<P>
<H3><A NAME="sig_on_top"></A> sig_on_top</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると署名が引用文や転送文の前に付けられる。
この変数を設定することの意味をよく理解し、
ネチケットの番人たちの憤りを買う準備ができているのでない限り、
この変数は設定しないよう<B>強く</B>推奨されている。
<P>
<P>
<H3><A NAME="signature"></A> signature</H3>

<P>Type: path<BR>
Default: &quot;~/.signature&quot;
<P>
<P>署名のファイル名を指定する。この署名はあらゆる送信メッセイジに付加される。
ファイル名がパイプ (&quot;|&quot;) で終わっていると、ファイル名が
シェルコマンドとみなされ、その標準出力から読み出される。
<P>
<P>
<H3><A NAME="simple_search"></A> simple_search</H3>

<P>Type: string<BR>
Default: &quot;~f %s | ~s %s&quot;
<P>
<P>単純検索を実際の検索パターンへ展開する方法を指定する。
単純検索とは ~ 演算子を含まない検索のことだ。
検索パターンに関してさらに情報を得るには
<A HREF="#patterns">「パターン」</A>の節を参照せよ。
<P>例えば、検索や表示制限の入力時にただ joe とだけ入力すると、
Mutt は自動でこの変数の値へ展開し、既定値ではこうなる。
<P>~f joe | ~s joe
<P>
<P>
<H3><A NAME="smart_wrap"></A> smart_wrap</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>内部ペイジャで画面幅より長い行を表示する方法を制御する。
設定されていると、長い行は語の区切りで折り返される (訳注：英語では
スペイスで語が区切られるので実装可能なのである)。
解除されていると、単純に画面の端で折り返される。
<A HREF="#markers">$markers</A> 変数も参照のこと。
<P>
<P>
<H3><A NAME="smileys"></A> smileys</H3>

<P>Type: regular expression<BR>
Default: &quot;(&gt;From )|(:[-^]?[][)(&gt;&lt;}{|/DP])&quot;
<P>
<P><EM>ペイジャ</EM>がこの変数を使って、
<A HREF="#quote_regexp">$quote_regexp</A> の
よくある誤検出を補正する。おもに、行頭に顔文字 (smileys) がある場合である。
<P>
<P>
<H3><A NAME="sleep_time"></A> sleep_time</H3>

<P>Type: number<BR>
Default: 1
<P>
<P>フォルダからフォルダへ移動する際にメッセイジを元のフォルダから消去した
あと、通知メッセイジを表示するための停止時間。秒数で指定する。
既定では一秒間だけ止まって表示する。それで、このオプションをゼロにすると
停止しなくなる。(訳注：すぐに再描画されるので読むことができなくなる。)
<P>
<P>
<H3><A NAME="sort"></A> sort</H3>

<P>Type: sort order<BR>
Default: date
<P>
<P><EM>インデックス</EM>メニューでメッセイジを整列する方法を指定する。
正しい値は以下の通り。
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
   date すなわち date-sent
   date-received
   from
   mailbox-order (整列なし)
   score
   size
   spam
   subject
   threads
   to
</PRE>
</CODE></BLOCKQUOTE>
<P>これに加えて、reverse- を頭に付けることで逆順に整列させることができる
(例: set sort=reverse-date-sent)。
<P>
<P>
<H3><A NAME="sort_alias"></A> sort_alias</H3>

<P>Type: sort order<BR>
Default: alias
<P>
<P>エイリアスメニューの項目を整列する方法を指定する。
以下が適正な値である。
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
   address (メイルアドレスでアルファベット順に整列)
   alias (エイリアス名でアルファベット順に整列)
   unsorted (.muttrc で指定された順番のまま)
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3><A NAME="sort_aux"></A> sort_aux</H3>

<P>Type: sort order<BR>
Default: date
<P>
<P>スレッドで整列しているとき、スレッドどうしをどのように比較・整列するかを、
この変数で制御する。
また、スレッド内の分岐した枝どうしを整列する方法も制御する。
この変数には、
<A HREF="#sort">$sort</A> で使える値をどれでも
使うことができるが、threads は無効である (この場合、Mutt は単に date-sent
を使う)。また、reverse- に加えて last- 接頭辞も指定することができる。
ただし、last- は reverse- の後に来なくてはならない。
この last- 接頭辞は、兄弟どうしのメッセイジをそれぞれの一番下の子孫で
比較させるもので、その「一番下」を決定するために sort_aux の
残りの部分を使う。例えば set sort_aux=last-date-received
の意味は、あるスレッドに新着メッセイジが届くと、そのスレッドが
最後に表示されるということである (set sort=reverse-threads してあれば
最初になる)。注意: 
<A HREF="#sort">$sort</A> が逆順指定だと、
<A HREF="#sort_aux">$sort_aux</A> も
また逆順になってしまう (これは正しい動作ではないが、既存の設定を
だめにしてしまわないよう、放置されている)。
(訳注：sort=reverse-threads で sort_aux=date だと、
スレッド内の各メッセイジが reverse-date のような順番に整列される
ということ。)
<P>
<P>
<H3><A NAME="sort_browser"></A> sort_browser</H3>

<P>Type: sort order<BR>
Default: alpha
<P>
<P>ファイルブラウザで項目をどのように整列するかを指定する。
既定ではアルファベット順に整列される。正しい値は次のとおり。
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
   alpha (アルファベット順)
   date
   size
   unsorted
</PRE>
</CODE></BLOCKQUOTE>
<P>これに reverse- 接頭辞を付けて逆順に整列させることもできる
(例: set sort_browser=reverse-date)。
<P>
<P>
<H3><A NAME="sort_re"></A> sort_re</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>この変数が有効なのは、スレッドで整列していて
<A HREF="#strict_threads">$strict_threads</A>
が解除されているときだけである。
そのような場合には Mutt の使う発見的手法が変わり、メッセイジを
題名でスレッドにするようになる。sort_re が設定されていると、
あるメッセイジを題名で別のメッセイジの子どもと判断してスレッドに入れるのは、
その題名が 
<A HREF="#reply_regexp">$reply_regexp</A>
の設定と合致する文字列で始まっているものだけである。
sort_re が解除されていると、それ以外のものも、
<A HREF="#reply_regexp">$reply_regexp</A> でない部分が
同じである限りスレッドに入れてしまう。
<P>
<P>
<H3><A NAME="spam_separator"></A> spam_separator</H3>

<P>Type: string<BR>
Default: &quot;,&quot;
<P>
<P><CODE>$spam_separator</CODE> は複数のスパムヘッダが
<A HREF="#spam">spam</A> コマンドに合致した際の挙動を制御する。
解除されていると、あとから合致したヘッダが
以前の合致によるスパムラベルの値を上書きしてゆく。
設定されていると (訳注：空の &quot;&quot; も含めて)、
あとから合致したものが以前の値に追記されてゆく。
その際の区切り文字として <CODE>$spam_separator</CODE> が使われる。
<P>
<P>
<H3><A NAME="spoolfile"></A> spoolfile</H3>

<P>Type: path<BR>
Default: &quot;&quot;
<P>
<P>スプールメイルボックスが既定と違う場所にあって Mutt が見付けられないなら、
その場所をこの変数で指定することができる。設定されていないと、Mutt
は自動的に環境変数 $MAIL の値にする。
<P>
<P>
<H3><A NAME="status_chars"></A> status_chars</H3>

<P>Type: string<BR>
Default: &quot;-*%A&quot;
<P>
<P>
<A HREF="#status_format">$status_format</A> の
&quot;%r&quot; で使われる文字を制御する。
メイルボックスに変更がないときは最初の文字が用いられる。
二番目はメイルボックスが変更されて同期が必要なときに使われる。
三番目の文字が使われるのは、メイルボックスが読み出し専用モウドの場合、
すなわち、そのメイルボックスを抜ける際に書き込まれない場合である
(変更を書き込むかどうかは toggle-write 関数で切替できる。
これは既定では &quot;%&quot; に割り当てられている)。
四番目はフォルダがメッセイジ添付モウドで開かれていることを示すために
用いられる (このモウドでは、新規メッセイジ作成や返信、転送などの
動作が禁止されている)。
<P>
<P>
<H3><A NAME="status_format"></A> status_format</H3>

<P>Type: string<BR>
Default: &quot;-%r-Mutt: %f [Msgs:%?M?%M/?%m%?n? New:%n?%?o? Old:%o?%?d? Del:%d?%?F? Flag:%F?%?t? Tag:%t?%?p? Post:%p?%?b? Inc:%b?%?l? %l?]---(%s/%S)-%&gt;-(%P)---&quot;
<P>
<P><EM>インデックス</EM>メニューで表示されるステイタス行の書式を制御する。
この文字列は 
<A HREF="#index_format">$index_format</A>
と似ているが、独自の printf()風シークウェンスを持っている。
<P>
<P>
<DL>
<DT><B>%b  </B><DD><P>新着メイルのある
<A HREF="#mailboxes">メイルボックス</A>の数 *
<DT><B>%d  </B><DD><P>削除メッセイジの数 *
<DT><B>%f  </B><DD><P>メイルボックスのフルパス名
<DT><B>%F  </B><DD><P>フラグ付きメッセイジの数 *
<DT><B>%h  </B><DD><P>ロウカルのホスト名
<DT><B>%l  </B><DD><P>メイルボックスのバイト数 *
<DT><B>%L  </B><DD><P>表示されるメッセイジのバイト数
(すなわち、表示制限で隠されていないものの合計サイズ) *
<DT><B>%m  </B><DD><P>メイルボックス内のメッセイジ数 *
<DT><B>%M  </B><DD><P>表示されるメッセイジの数 (すなわち、表示制限で隠されていないものの数) *
<DT><B>%n  </B><DD><P>メイルボックス内の新着メッセイジ数 *
<DT><B>%o  </B><DD><P>古い未読メッセイジの数 *
<DT><B>%p  </B><DD><P>延期メッセイジの数 *
<DT><B>%P  </B><DD><P>現在位置の、インデックス中におけるパーセンテイジ
<DT><B>%r  </B><DD><P><B>変更/書込/メッセイジ添付</B> を
<A HREF="#status_chars">$status_chars</A> に基づいて示す
<DT><B>%s  </B><DD><P>整列のモウド (
<A HREF="#sort">$sort</A>)
<DT><B>%S  </B><DD><P>補助整列モウド (
<A HREF="#sort_aux">$sort_aux</A>)
<DT><B>%t  </B><DD><P>タグ付きメッセイジの数 *
<DT><B>%u  </B><DD><P>未読メッセイジの数 *
<DT><B>%v  </B><DD><P>Mutt ヴァージョン文字列
<DT><B>%V  </B><DD><P>表示制限パターン (有効なものがあれば) *
<DT><B>%&gt;X </B><DD><P>残りの文字列を右寄せして間を &quot;X&quot; で詰める
<DT><B>%|X </B><DD><P>行の最後まで &quot;X&quot; で詰める
</DL>
<P>
<P>* = 非ゼロのときのみ表示するようにできる
<P>上記シークウェンスの中には、値が非ゼロのときのみ選択的に
文字列を表示するという使い方のできるものがある。例えば、
フラグ付きメッセイジの数は、そのようなメッセイジが存在するときにのみ
見たいと思うだろう。ゼロには特に意味があるわけではないのだから。
そのように上記シークウェンスに基づいて選択的に文字列を表示するには、
次のような構造が使われる。
<P>%?&lt;シークウェンス文字&gt;?&lt;選択的文字列&gt;?
<P>ここで、<EM>シークウェンス文字</EM>の部分には上記の表にある文字が入る。
<EM>選択的文字列</EM>の部分は、その<EM>シークウェンス</EM>が
非ゼロのときに表示したい文字列である。<EM>選択的文字列</EM>には
他のシークウェンスも普通の文章も含めることが<B>できる</B>が、
選択的文字列を再帰的に使用することは<B>できない</B>。
<P>メイルボックス中にある新着メッセイジの数を選択的に
表示する方法を説明する例を次に挙げる:
%?n?%n new messages.?
<P>加えて、二つの文字列を選択することもできる。第一の文字列は値がゼロのとき、
第二の文字列は値が非ゼロのときである。これには次の構造を用いる:
%?&lt;シークウェンス文字&gt;?&lt;ゼロ文字列&gt;&amp;&lt;非ゼロ文字列&gt;?
<P>さらに、どの printf風シークウェンスに対しても、結果を強制的に
小文字にすることができる。これはシークウェンス文字の前にアンダスコア
(_) 記号を付ければ良い。例えば、ロウカルのホスト名を
小文字で表示したいなら %_h とする。
<P>シークウェンス文字の前にコロン (:) 文字を付けると、Mutt
は展開結果中のドット (.) をアンダスコアに置換する。
これは、フォルダ名にドットを使えない IMAP フォルダで役立つかもしれない。
(訳注：$status_format というよりは、
<A HREF="#save-hook">save-hook</A> などで使うことを想定しているのであろう。)
<P>
<P>
<H3><A NAME="status_on_top"></A> status_on_top</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>この変数を設定すると「ステイタスバー」が画面の下のほうではなく
一番上の行に表示されるようになる。
<P>
<P>
<H3><A NAME="strict_threads"></A> strict_threads</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、スレッドで
<A HREF="#sort">整列</A>する際の
スレッド構築に &quot;In-Reply-To&quot; と &quot;References&quot;
フィールドだけを用いる。既定では、同じ題のメッセイジが「擬似スレッド」
として一括りにされる。これが常に望ましいとは言えない。例えば
私的なメイルのメイルボックスで、「こんにちは」というような題の
無関係なメッセイジがすべて一括りにされてしまうような場合もある。
<P>
<P>
<H3><A NAME="suspend"></A> suspend</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P><EM>no</EM> のときは、ユーザが端末の <EM>susp</EM> キーを押しても
Mutt が停止しない。そのキーは通常 &quot;control-Z&quot; である。
これが便利なのは Mutt を xterm -e mutt のようなコマンドで
xterm 内に実行している場合である。(訳注：このような場合に C-z
を押してしまったら、別の端末から killall -CONT mutt などとして
CONT シグナルを送る必要がある。)
<P>
<P>
<H3><A NAME="text_flowed"></A> text_flowed</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると Mutt は text/plain; format=flowed 添付ファイルを生成する。
この形式は通常の形式よりも一部のメイリングソフトウェアから扱いやすいが、
一般的には通常の文書と同じように見える。ただし、実際にこの形式の特徴を
活用するには、エディタの対応が必要になる。
<P>このオプションが設定されていると
<A HREF="#indent_string">$indent_string</A>
が無視されるので注意すること。
<P>
<P>
<H3><A NAME="thread_received"></A> thread_received</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、メッセイジを題名でスレッドにする際に
送信日付ではなく受信日付を使用する。
<P>
<P>
<H3><A NAME="thorough_search"></A> thorough_search</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P><EM>~b</EM> と <EM>~h</EM> の検索に影響する。
これらの意味は
<A HREF="#patterns">「パターン」</A>の節に記述されている。
この変数が設定されていると、検索するメッセイジのヘッダや添付ファイルが
復号化されてから検索される。解除されているとフォルダにあるままで検索される。
(訳注：日本語の場合は、この変数を設定しないと使いものにならない。)
<P>
<P>
<H3><A NAME="tilde"></A> tilde</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P>設定されていると、内部ペイジャは画面の下端まで空行をティルド (~)
で詰める。
<P>
<P>
<H3><A NAME="timeout"></A> timeout</H3>

<P>Type: number<BR>
Default: 600
<P>
<P>Mutt は、キーが押されるのをこの変数の<EM>秒数</EM>だけメインメニュー
(訳注：インデックスメニュー) で待ち続け、それを過ぎると、キーを
押さなくても新着メイルを確認する。ゼロか負の値の場合には
いつまでも確認せずに待ち続ける。
<P>
<P>
<H3><A NAME="tmpdir"></A> tmpdir</H3>

<P>Type: path<BR>
Default: &quot;&quot;
<P>
<P>この変数で、メッセイジの表示や作成に必要な一時ファイルを
Mutt が置く場所を指定することができる。設定されていないときには
環境変数 TMPDIR が用いられる。TMPDIR も設定されていないなら
&quot;/tmp&quot; が用いられる。
<P>
<P>
<H3><A NAME="to_chars"></A> to_chars</H3>

<P>Type: string<BR>
Default: &quot; +TCFL&quot;
<P>
<P>自分に来たメイルを示すために使われる文字を制御する。
一番目の文字は、メイルが自分のアドレスに宛てられて「いない」
ときに使われる (既定: スペイス)。
二番目は自分がそのメッセイジ唯一の宛先である場合に用いられる (既定: +)。
三番目は、自分のアドレスが TO ヘッダフィールドにあるものの、
自分以外にも宛てられているというメッセイジに使われる (既定: T)。
四番目の文字が使われるのは、自分のアドレスが CC ヘッダフィールドに
指定されていて他の人にも宛てられている場合である (既定: C)。
五番目の文字はメイルの送信者が<EM>自分</EM>であるという場合に用いられる
(既定: F)。
六番目の文字は、メイルが購読メイリングリストに送られていることを
示すために使われる (既定: L)。
<P>
<P>
<H3><A NAME="tunnel"></A> tunnel</H3>

<P>Type: string<BR>
Default: &quot;&quot;
<P>
<P>この変数を設定すると Mutt がソケットではなくコマンドへのパイプを開く。
これを使って、IMAP/POP3 サーバへの認証済み接続を作ることができる。
例:
<P>tunnel=&quot;ssh -q mailhost.net /usr/local/libexec/imapd&quot;
<P>注意: この例がうまくいくには、リモウトマシンにパスワードの入力なしで
ログインすることができなくてはならない。
(訳注：ssh-agent などを使う。)
<P>
<P>
<H3><A NAME="use_8bitmime"></A> use_8bitmime</H3>

<P>Type: boolean<BR>
Default: no
<P>
<P><B>警告:</B> 自分の使っているヴァージョンの sendmail が
-B8BITMIME フラグに対応している (sendmail 8.8.x など) のでない限り、
この変数を設定してはいけない。さもないとメイルを送れなくなってしまう。
<P><EM>yes</EM> に設定されているとき、8ビットのメッセイジ送信時に Mutt は
<A HREF="#sendmail">$sendmail</A> を -B8BITMIME
フラグ付きで起動して ESMTP 通信を有効にする。
<P>
<P>
<H3><A NAME="use_domain"></A> use_domain</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると Mutt はすべてのロウカルアドレス (@host 部分のないもの)
を 
<A HREF="#hostname">$hostname</A> の値で補完する。
<EM>解除</EM>すると、どのアドレスもそのままにする。
<P>
<P>
<H3><A NAME="use_from"></A> use_from</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P><EM>yes</EM> のときはメッセイジ送信時に &quot;From:&quot;
ヘッダフィールドを Mutt が生成する。<EM>no</EM> だと、
ユーザが明示的に 
<A HREF="#my_hdr">my_hdr</A> コマンドで
設定しないと生成されない。
<P>
<P>
<H3><A NAME="use_ipv6"></A> use_ipv6</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P><EM>設定されている</EM>とき、Mutt は接続しようとするホストの
IPv6 アドレスを調べる。このオプションが解除されていると、
IPv4 アドレスだけに絞って動作する。通常は既定値で問題なく動くはずだ。
<P>
<P>
<H3><A NAME="user_agent"></A> user_agent</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P><EM>設定されている</EM>と、Mutt は &quot;User-Agent&quot; ヘッダを
送信メッセイジに付加する。これはどのヴァージョンの Mutt を使って
作成されたのかを示すものである。
<P>
<P>
<H3><A NAME="visual"></A> visual</H3>

<P>Type: path<BR>
Default: &quot;&quot;
<P>
<P>内蔵エディタの <EM>~v</EM> コマンドで起動する
ヴィジュアルエディタを指定する。
<P>
<P>
<H3><A NAME="wait_key"></A> wait_key</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>Mutt が <EM>shell-escape</EM>, <EM>pipe-message</EM>, <EM>pipe-entry</EM>,
<EM>print-message</EM>, <EM>print-entry</EM> コマンドのあとに
キー押下を求めるかどうかを制御する。
<P>また、
<A HREF="#auto_view">auto_view</A> で添付ファイルを
閲覧する際にも、対応する mailcap 項目に <EM>needsterminal</EM>
フラグがあって外部プログラムが対話的に動作する場合は、この変数が用いられる。
<P>設定されていると、常にキー入力を求める。解除されていると、
外部コマンドが非ゼロを返した場合にのみキーを待つ。
<P>
<P>
<H3><A NAME="weed"></A> weed</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>設定されていると、メッセイジの表示、転送、印刷、返信の際にヘッダを間引きする。
<P>
<P>
<H3><A NAME="wrap_search"></A> wrap_search</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>検索がメイルボックスの最後まで行っても続けるかどうかを制御する。
<P>設定されているときには最初 (または最後) のメッセイジに飛んで検索を続ける。
解除されているときにはそこで終わる。
<P>
<P>
<H3><A NAME="wrapmargin"></A> wrapmargin</H3>

<P>Type: number<BR>
Default: 0
<P>
<P>Mutt のペイジャが語単位で行を折り返す際に
端末の右側に残す余白の大きさを制御する。
<P>
<P>
<H3><A NAME="write_inc"></A> write_inc</H3>

<P>Type: number<BR>
Default: 10
<P>
<P>メイルボックスを書き込む際、<EM>write_inc</EM> 通ごとに
進行状況を示すメッセイジが表示される。
0 に設定されると、書き込み前に一度表示されるだけになる。
<P>
<A HREF="#read_inc">$read_inc</A> 変数も参照。
<P>
<P>
<H3><A NAME="write_bcc"></A> write_bcc</H3>

<P>Type: boolean<BR>
Default: yes
<P>
<P>メッセイジを送信に備える際、Mutt が Bcc ヘッダを書いておくかどうかを
制御する。Exim ユーザはこれを使いたいであろう。
(訳注：exim は Bcc を消してくれないので、解除すべきだということ。)
<P>
<P>
<H2><A NAME="functions"></A> 6.4 関数</H2>

<P>以下は利用可能な関数の一覧です。
それぞれが利用可能なマップに挙げられています。
既定のキー設定が取り上げられており、関数が何をするかについても
説明されています。これらのキー割り当ては 
<A HREF="#bind">bind</A>
コマンドで変更することができます。
<P>
<H3>generic</H3>

<P>
<P><EM>generic</EM> メニューは実在のメニューではなく、
<EM>pager</EM> と <EM>editor</EM> を除くあらゆるメニューで利用できる
共通の関数 (カーソル移動など) を指定するものです。
このメニューへの変更は、それらすべてのメニューの既定割り当てに
影響を与えます。
<P>
<PRE>
bottom-page                L   move to the bottom of the page
current-bottom     not bound   move current entry to bottom of page
current-middle     not bound   move current entry to middle of page
current-top        not bound   move current entry to top of page
enter-command              :   enter a muttrc command
exit                       q   exit this menu
first-entry                =   move to the first entry
half-down                  ]   scroll down 1/2 page
half-up                    [   scroll up 1/2 page
help                       ?   this screen
jump                  number   jump to an index number
last-entry                 *   move to the last entry
middle-page                M   move to the middle of the page
next-entry                 j   move to the next entry
next-line                  >   scroll down one line
next-page                  z   move to the next page
previous-entry             k   move to the previous entry
previous-line              &lt;   scroll up one line
previous-page              Z   move to the previous page
refresh                   ^L   clear and redraw the screen
search                     /   search for a regular expression
search-next                n   search for next match
search-opposite    not bound   search for next match in opposite direction
search-reverse         ESC /   search backwards for a regular expression
select-entry             RET   select the current entry
shell-escape               !   run a program in a subshell
tag-entry                  t   toggle the tag on the current entry
tag-prefix                 ;   apply next command to tagged entries
tag-prefix-cond    not bound   apply next function ONLY to tagged messages
top-page                   H   move to the top of the page
what-key           not bound   display the keycode for a key press
</PRE>
<H3>index</H3>

<P>
<PRE>
bounce-message             b   remail a message to another user
change-folder              c   open a different folder
change-folder-readonly ESC c   open a different folder in read only mode
check-traditional-pgp  ESC P   check for classic pgp
clear-flag                 W   clear a status flag from a message
copy-message               C   copy a message to a file/mailbox
create-alias               a   create an alias from a message sender
decode-copy            ESC C   decode a message and copy it to a file/mailbox
decode-save            ESC s   decode a message and save it to a file/mailbox
delete-message             d   delete the current entry
delete-pattern             D   delete messages matching a pattern
delete-subthread       ESC d   delete all messages in subthread
delete-thread             ^D   delete all messages in thread
display-address            @   display full address of sender
display-toggle-weed        h   display message and toggle header weeding
display-message          RET   display a message
edit                       e   edit the current message
edit-type                 ^E   edit the current message's Content-Type
exit                       x   exit without saving changes
extract-keys              ^K   extract PGP public keys
fetch-mail                 G   retrieve mail from POP server
flag-message               F   toggle a message's 'important' flag
forget-passphrase         ^F   wipe PGP passphrase from memory
forward-message            f   forward a message with comments
group-reply                g   reply to all recipients
limit                      l   show only messages matching a pattern
list-reply                 L   reply to specified mailing list
mail                       m   compose a new mail message
mail-key               ESC k   mail a PGP public key
next-new                 TAB   jump to the next new message
next-subthread         ESC n   jump to the next subthread
next-thread               ^N   jump to the next thread
next-undeleted             j   move to the next undeleted message
next-unread        not bound   jump to the next unread message
parent-message             P   jump to parent message in thread
pipe-message               |   pipe message/attachment to a shell command
previous-new         ESC TAB   jump to the previous new message
previous-page              Z   move to the previous page
previous-subthread     ESC p   jump to previous subthread
previous-thread           ^P   jump to previous thread
previous-undeleted         k   move to the last undelete message
previous-unread    not bound   jump to the previous unread message
print-message              p   print the current entry
query                      Q   query external program for addresses
quit                       q   save changes to mailbox and quit
read-subthread         ESC r   mark the current subthread as read
read-thread               ^R   mark the current thread as read
recall-message             R   recall a postponed message
reply                      r   reply to a message
resend-message         ESC e   resend message and preserve MIME structure
save-message               s   save message/attachment to a file
set-flag                   w   set a status flag on a message
show-version               V   show the Mutt version number and date
show-limit             ESC l   show currently active limit pattern, if any
sort-mailbox               o   sort messages
sort-reverse               O   sort messages in reverse order
sync-mailbox               $   save changes to mailbox
tag-pattern                T   tag messages matching a pattern
tag-thread             ESC t   tag/untag all messages in the current thread
toggle-new                 N   toggle a message's 'new' flag
toggle-write               %   toggle whether the mailbox will be rewritten
undelete-message           u   undelete the current entry
undelete-pattern           U   undelete messages matching a pattern
undelete-subthread     ESC u   undelete all messages in subthread
undelete-thread           ^U   undelete all messages in thread
untag-pattern             ^T   untag messages matching a pattern
view-attachments           v   show MIME attachments
</PRE>
<H3>pager</H3>

<P>
<PRE>
bottom             not bound   jump to the bottom of the message
bounce-message             b   remail a message to another user
change-folder              c   open a different folder
change-folder-readonly ESC c   open a different folder in read only mode
check-traditional-pgp  ESC P   check for classic pgp
copy-message               C   copy a message to a file/mailbox
create-alias               a   create an alias from a message sender
decode-copy            ESC C   decode a message and copy it to a file/mailbox
decode-save            ESC s   decode a message and save it to a file/mailbox
delete-message             d   delete the current entry
delete-subthread       ESC d   delete all messages in subthread
delete-thread             ^D   delete all messages in thread
display-address            @   display full address of sender
display-toggle-weed        h   display message and toggle header weeding
edit                       e   edit the current message
edit-type                 ^E   edit the current message's Content-Type
enter-command              :   enter a muttrc command
exit                       i   return to the main-menu
extract-keys              ^K   extract PGP public keys
flag-message               F   toggle a message's 'important' flag
forget-passphrase         ^F   wipe PGP passphrase from memory
forward-message            f   forward a message with comments
group-reply                g   reply to all recipients
half-up            not bound   move up one-half page
half-down          not bound   move down one-half page
help                       ?   this screen
list-reply                 L   reply to specified mailing list
mail                       m   compose a new mail message
mail-key               ESC k   mail a PGP public key
mark-as-new                N   toggle a message's 'new' flag
next-line                RET   scroll down one line
next-entry                 J   move to the next entry
next-new                 TAB   jump to the next new message
next-page                      move to the next page
next-subthread         ESC n   jump to the next subthread
next-thread               ^N   jump to the next thread
next-undeleted             j   move to the next undeleted message
next-unread        not bound   jump to the next unread message
parent-message             P   jump to parent message in thread
pipe-message               |   pipe message/attachment to a shell command
previous-line      BackSpace   scroll up one line
previous-entry             K   move to the previous entry
previous-new       not bound   jump to the previous new message
previous-page              -   move to the previous page
previous-subthread     ESC p   jump to previous subthread
previous-thread           ^P   jump to previous thread
previous-undeleted         k   move to the last undelete message
previous-unread    not bound   jump to the previous unread message
print-message              p   print the current entry
quit                       Q   save changes to mailbox and quit
read-subthread         ESC r   mark the current subthread as read
read-thread               ^R   mark the current thread as read
recall-message             R   recall a postponed message
redraw-screen             ^L   clear and redraw the screen
reply                      r   reply to a message
save-message               s   save message/attachment to a file
search                     /   search for a regular expression
search-next                n   search for next match
search-opposite    not bound   search for next match in opposite direction
search-reverse         ESC /   search backwards for a regular expression
search-toggle              \   toggle search pattern coloring
shell-escape               !   invoke a command in a subshell
show-version               V   show the Mutt version number and date
skip-quoted                S   skip beyond quoted text
sync-mailbox               $   save changes to mailbox
tag-message                t   tag a message
toggle-quoted              T   toggle display of quoted text
top                        ^   jump to the top of the message
undelete-message           u   undelete the current entry
undelete-subthread     ESC u   undelete all messages in subthread
undelete-thread           ^U   undelete all messages in thread
view-attachments           v   show MIME attachments
</PRE>
<H3>alias</H3>

<P>
<PRE>
search                     /   search for a regular expression
search-next                n   search for next match
search-reverse         ESC /   search backwards for a regular expression
</PRE>
<H3>query</H3>

<P>
<PRE>
create-alias               a   create an alias from a message sender
mail                       m   compose a new mail message
query                      Q   query external program for addresses
query-append               A   append new query results to current results
search                     /   search for a regular expression
search-next                n   search for next match
search-opposite    not bound   search for next match in opposite direction
search-reverse         ESC /   search backwards for a regular expression
</PRE>
<H3>attach</H3>

<P>
<PRE>
bounce-message             b   remail a message to another user
collapse-parts             v   toggle display of subparts
delete-entry               d   delete the current entry
display-toggle-weed        h   display message and toggle header weeding
edit-type                 ^E   edit the current entry's Content-Type
extract-keys              ^K   extract PGP public keys
forward-message            f   forward a message with comments
group-reply                g   reply to all recipients
list-reply                 L   reply to specified mailing list
pipe-entry                 |   pipe message/attachment to a shell command
print-entry                p   print the current entry
reply                      r   reply to a message
resend-message         ESC e   resend message and preserve MIME structure
save-entry                 s   save message/attachment to a file
undelete-entry             u   undelete the current entry
view-attach              RET   view attachment using mailcap entry if necessary
view-mailcap               m   force viewing of attachment using mailcap
view-text                  T   view attachment as text
</PRE>
<H3>compose</H3>

<P>
<PRE>
attach-file                a   attach a file(s) to this message
attach-message             A   attach message(s) to this message
attach-key             ESC k   attach a PGP public key
copy-file                  C   save message/attachment to a file
detach-file                D   delete the current entry
display-toggle-weed        h   display message and toggle header weeding
edit-bcc                   b   edit the BCC list
edit-cc                    c   edit the CC list
edit-description           d   edit attachment description
edit-encoding             ^E   edit attachment transfer-encoding
edit-fcc                   f   enter a file to save a copy of this message in
edit-from              ESC f   edit the from: field
edit-file               ^X e   edit the file to be attached
edit-headers               E   edit the message with headers
edit                       e   edit the message
edit-mime                  m   edit attachment using mailcap entry
edit-reply-to              r   edit the Reply-To field
edit-subject               s   edit the subject of this message
edit-to                    t   edit the TO list
edit-type                 ^T   edit attachment type
filter-entry               F   filter attachment through a shell command
forget-passphrase         ^F   wipe PGP passphrase from memory
ispell                     i   run ispell on the message
new-mime                   n   compose new attachment using mailcap entry
pgp-menu                   p   show PGP options
pipe-entry                 |   pipe message/attachment to a shell command
postpone-message           P   save this message to send later
print-entry                l   print the current entry
rename-file                R   rename/move an attached file
send-message               y   send the message
toggle-unlink              u   toggle whether to delete file after sending it
view-attach              RET   view attachment using mailcap entry if necessary
write-fcc                  w   write the message to a folder
</PRE>
<H3>postpone</H3>

<P>
<PRE>
delete-entry               d   delete the current entry
undelete-entry             u   undelete the current entry
</PRE>
<H3>browser</H3>

<P>
<PRE>
change-dir                 c   change directories
check-new                TAB   check mailboxes for new mail
enter-mask                 m   enter a file mask
search                     /   search for a regular expression
search-next                n   search for next match
search-reverse         ESC /   search backwards for a regular expression
select-new                 N   select a new file in this directory
sort                       o   sort messages
sort-reverse               O   sort messages in reverse order
toggle-mailboxes         TAB   toggle whether to browse mailboxes or all files
view-file              SPACE   view file
subscribe                  s   subscribe to current mailbox (IMAP Only)
unsubscribe                u   unsubscribe to current mailbox (IMAP Only)
toggle-subscribed          T   toggle view all/subscribed mailboxes (IMAP Only)
</PRE>
<H3>pgp</H3>

<P>
<PRE>
view-name                  %   view the key's user id
verify-key                 c   verify a PGP public key
</PRE>
<H3>editor</H3>

<P>
<PRE>
backspace          BackSpace   delete the char in front of the cursor
backward-char             ^B   move the cursor one character to the left
backward-word          ESC b   move the cursor to the previous word
bol                       ^A   jump to the beginning of the line
buffy-cycle            Space   cycle among incoming mailboxes
capitalize-word        ESC c   uppercase the first character in the word
complete                 TAB   complete filename or alias
complete-query            ^T   complete address with query
delete-char               ^D   delete the char under the cursor
downcase-word          ESC l   lowercase all characters in current word
eol                       ^E   jump to the end of the line
forward-char              ^F   move the cursor one character to the right
forward-word           ESC f   move the cursor to the next word
history-down       not bound   scroll down through the history list
history-up         not bound   scroll up through the history list
kill-eol                  ^K   delete chars from cursor to end of line
kill-eow               ESC d   delete chars from cursor to end of word
kill-line                 ^U   delete all chars on the line
kill-word                 ^W   delete the word in front of the cursor
quote-char                ^V   quote the next typed key
transpose-chars    not bound   transpose character under cursor with previous
upcase-word            ESC u   uppercase all characters in current word
</PRE>
<P>
<H2><A NAME="s7">7. 雑録</A></H2>

<P>
<P>
<H2>7.1 謝辞</H2>

<P>Kari Hurtta
<A HREF="mailto:kari.hurtta@fmi.fi">&lt;kari.hurtta@fmi.fi&gt;</A>
は、かつて ELM-ME の日々に MIME 解釈コウドの原型を共同開発してくれました。
<P>以下の人々が Mutt 開発に対して大きな力になってくれてきました。
<P>Vikas Agnihotri 
<A HREF="mailto:vikasa@writeme.com">&lt;vikasa@writeme.com&gt;</A>,<BR>
Francois Berjon 
<A HREF="mailto:Francois.Berjon@aar.alcatel-alsthom.fr">&lt;Francois.Berjon@aar.alcatel-alsthom.fr&gt;</A>,<BR>
Aric Blumer 
<A HREF="mailto:aric@fore.com">&lt;aric@fore.com&gt;</A>,<BR>
John Capo 
<A HREF="mailto:jc@irbs.com">&lt;jc@irbs.com&gt;</A>,<BR>
David Champion 
<A HREF="mailto:dgc@uchicago.edu">&lt;dgc@uchicago.edu</A>,<BR>
Brendan Cully 
<A HREF="mailto:brendan@kublai.com">&lt;brendan@kublai.com&gt;</A>,<BR>
Liviu Daia 
<A HREF="mailto:daia@stoilow.imar.ro">&lt;daia@stoilow.imar.ro&gt;</A>,<BR>
Thomas E. Dickey 
<A HREF="mailto:dickey@herndon4.his.com">&lt;dickey@herndon4.his.com&gt;</A>,<BR>
David DeSimone 
<A HREF="mailto:fox@convex.hp.com">&lt;fox@convex.hp.com&gt;</A>,<BR>
Nickolay N. Dudorov 
<A HREF="mailto:nnd@wint.itfs.nsk.su">&lt;nnd@wint.itfs.nsk.su&gt;</A>,<BR>
Ruslan Ermilov 
<A HREF="mailto:ru@freebsd.org">&lt;ru@freebsd.org&gt;</A>,<BR>
Edmund Grimley Evans 
<A HREF="mailto:edmundo@rano.org">&lt;edmundo@rano.org</A>,<BR>
Michael Finken 
<A HREF="mailto:finken@conware.de">&lt;finken@conware.de&gt;</A>,<BR>
Sven Guckes 
<A HREF="mailto:guckes@math.fu-berlin.de">&lt;guckes@math.fu-berlin.de&gt;</A>,<BR>
Lars Hecking 
<A HREF="mailto:lhecking@nmrc.ie">&lt;lhecking@nmrc.ie&gt;</A>,<BR>
Mark Holloman 
<A HREF="mailto:holloman@nando.net">&lt;holloman@nando.net&gt;</A>,<BR>
Andreas Holzmann 
<A HREF="mailto:holzmann@fmi.uni-passau.de">&lt;holzmann@fmi.uni-passau.de&gt;</A>,<BR>
Marco d'Itri 
<A HREF="mailto:md@linux.it">&lt;md@linux.it&gt;</A>,<BR>
Bjoern Jacke 
<A HREF="mailto:bjacke@suse.com">&lt;bjacke@suse.com&gt;</A>,<BR>
Byrial Jensen 
<A HREF="mailto:byrial@image.dk">&lt;byrial@image.dk&gt;</A>,<BR>
David Jeske 
<A HREF="mailto:jeske@igcom.net">&lt;jeske@igcom.net&gt;</A>,<BR>
Christophe Kalt 
<A HREF="mailto:kalt@hugo.int-evry.fr">&lt;kalt@hugo.int-evry.fr&gt;</A>,<BR>
Tommi Komulainen 
<A HREF="mailto:Tommi.Komulainen@iki.fi">&lt;Tommi.Komulainen@iki.fi&gt;</A>,<BR>
Felix von Leitner (a.k.a ``Fefe'') 
<A HREF="mailto:leitner@math.fu-berlin.de">&lt;leitner@math.fu-berlin.de&gt;</A>,<BR>
Brandon Long 
<A HREF="mailto:blong@fiction.net">&lt;blong@fiction.net&gt;</A>,<BR>
Jimmy Makela 
<A HREF="mailto:jmy@flashback.net">&lt;jmy@flashback.net&gt;</A>,<BR>
Lars Marowsky-Bree 
<A HREF="mailto:lmb@pointer.in-minden.de">&lt;lmb@pointer.in-minden.de&gt;</A>,<BR>
Thomas ``Mike'' Michlmayr 
<A HREF="mailto:mike@cosy.sbg.ac.at">&lt;mike@cosy.sbg.ac.at&gt;</A>,<BR>
Andrew W. Nosenko 
<A HREF="mailto:awn@bcs.zp.ua">&lt;awn@bcs.zp.ua&gt;</A>,<BR>
David O'Brien 
<A HREF="mailto:obrien@Nuxi.cs.ucdavis.edu">&lt;obrien@Nuxi.cs.ucdavis.edu&gt;</A>,<BR>
Clint Olsen 
<A HREF="mailto:olsenc@ichips.intel.com">&lt;olsenc@ichips.intel.com&gt;</A>,<BR>
Park Myeong Seok 
<A HREF="mailto:pms@romance.kaist.ac.kr">&lt;pms@romance.kaist.ac.kr&gt;</A>,<BR>
Thomas Parmelan 
<A HREF="mailto:tom@ankh.fr.eu.org">&lt;tom@ankh.fr.eu.org&gt;</A>,<BR>
Ollivier Robert 
<A HREF="mailto:roberto@keltia.freenix.fr">&lt;roberto@keltia.freenix.fr&gt;</A>,<BR>
Thomas Roessler 
<A HREF="mailto:roessler@does-not-exist.org">&lt;roessler@does-not-exist.org&gt;</A>,<BR>
Roland Rosenfeld 
<A HREF="roland@spinnaker.de">&lt;roland@spinnaker.de&gt;</A>,<BR>
TAKIZAWA Takashi 
<A HREF="taki@luna.email.ne.jp">&lt;taki@luna.email.ne.jp&gt;</A>,<BR>
Allain Thivillon 
<A HREF="mailto:Allain.Thivillon@alma.fr">&lt;Allain.Thivillon@alma.fr&gt;</A>,<BR>
Gero Treuner 
<A HREF="mailto:gero@faveve.uni-stuttgart.de">&lt;gero@faveve.uni-stuttgart.de&gt;</A>,<BR>
Vsevolod Volkov 
<A HREF="mailto:vvv@lucky.net">&lt;vvv@lucky.net&gt;</A>,<BR>
Ken Weinert 
<A HREF="mailto:kenw@ihs.com">&lt;kenw@ihs.com&gt;</A><P>
<H2>7.2 この文書について</H2>

<P>この文書は SGML で書かれ、
<A HREF="http://www.sgmltools.org/">sgml-tools</A>
パッケイジを用いて他の形式へ整形されました。
<P>
<H2>7.3 日本語訳について</H2>

<P><B>Note: The original manual does not have this section.<BR>
注意: この章は原文には存在しません。</B>
<P>日本語で読める完全な Mutt マニュアルは、西岡氏と人見氏による翻訳しか
手に入らない状態が続いています。そこで tamomo こと高橋全は、
sourceforge.jp の mutt-j プロジェクトという場を借りて、
一つの仮想ライヴァルを作り出そうと考えました。
目標は、この翻訳がシェアを握ることではありません
(この翻訳は「訳注」が多すぎるし、カタカナが変で、読みづらいですからね)。
この翻訳が契機となって西岡・人見訳がより良いものとなり、
Mutt ユーザにとって、より快適な日本語環境が整備されることです。
また、この翻訳の特色として、原文 SGML との対応が見やすいという点があります。
<CODE>diff -du manual.sgml manual.ja.sgml</CODE> としてみると、
原文と日本語が並んで見えるため、誤訳なのか
原文が間違っているのかが一目瞭然です。
これによって原文の質が向上されることも視野に入れています。
翻訳中に、実際いくつか原文の誤りなどを見付けました。
<P>ライセンスについては、原文に何も付け足しません。
参考にしたのは、原文とソース (1.5.6, 1.5.7 および CVS 版)、および
西岡・人見訳 (1.4) のみです。
<P>改善要求などは sourceforge.jp の mutt-j プロジェクトの
バグ報告機能かフォーラムを使うと良いでしょう。
あるいは高橋全に直接メイルを送っても構いません。
<P><CODE>Translation to Japanese: (C) 2004, 2005 TAKAHASHI Tamotsu</CODE>
<P>
</BODY>
</HTML>
